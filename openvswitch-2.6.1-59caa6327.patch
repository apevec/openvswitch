diff --git a/.travis.yml b/.travis.yml
index 9f967ad08..3004ce57d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -49,4 +49,4 @@ script: ./.travis/${TRAVIS_OS_NAME}-build.sh $OPTS
 notifications:
   email:
     recipients:
-      - build@openvswitch.org
+      - ovs-build@openvswitch.org
diff --git a/.travis/linux-build.sh b/.travis/linux-build.sh
index 3bcec93cb..21e4a2091 100755
--- a/.travis/linux-build.sh
+++ b/.travis/linux-build.sh
@@ -52,13 +52,13 @@ function install_kernel()
 function install_dpdk()
 {
     if [ -n "$DPDK_GIT" ]; then
-        git clone $DPDK_GIT dpdk-$1
-        cd dpdk-$1
-        git checkout v$1
+        git clone $DPDK_GIT dpdk-stable-$1
+        cd dpdk-stable-$1
+        git checkout tags/v$1
     else
-        wget http://www.dpdk.org/browse/dpdk/snapshot/dpdk-$1.tar.gz
+        wget http://fast.dpdk.org/rel/dpdk-$1.tar.gz
         tar xzvf dpdk-$1.tar.gz > /dev/null
-        cd dpdk-$1
+        cd dpdk-stable-$1
     fi
     find ./ -type f | xargs sed -i 's/max-inline-insns-single=100/max-inline-insns-single=400/'
     echo 'CONFIG_RTE_BUILD_FPIC=y' >>config/common_linuxapp
@@ -80,14 +80,14 @@ fi
 
 if [ "$DPDK" ]; then
     if [ -z "$DPDK_VER" ]; then
-        DPDK_VER="16.07"
+        DPDK_VER="16.07.2"
     fi
     install_dpdk $DPDK_VER
     if [ "$CC" = "clang" ]; then
         # Disregard cast alignment errors until DPDK is fixed
         CFLAGS="$CFLAGS -Wno-cast-align"
     fi
-    EXTRA_OPTS="$EXTRA_OPTS --with-dpdk=./dpdk-$DPDK_VER/build"
+    EXTRA_OPTS="$EXTRA_OPTS --with-dpdk=./dpdk-stable-$DPDK_VER/build"
 elif [ "$CC" != "clang" ]; then
     # DPDK headers currently trigger sparse errors
     SPARSE_FLAGS="$SPARSE_FLAGS -Wsparse-error"
@@ -101,16 +101,16 @@ if [ "$KERNEL" ] && [ ! "$TESTSUITE" ] && [ ! "$DPDK" ]; then
 fi
 
 if [ "$CC" = "clang" ]; then
-    make CFLAGS="$CFLAGS -Wno-error=unused-command-line-argument"
+    make -j2 CFLAGS="$CFLAGS -Wno-error=unused-command-line-argument"
 elif [[ $BUILD_ENV =~ "-m32" ]]; then
     # Disable sparse for 32bit builds on 64bit machine
-    make CFLAGS="$CFLAGS $BUILD_ENV"
+    make -j2 CFLAGS="$CFLAGS $BUILD_ENV"
 else
-    make CFLAGS="$CFLAGS $BUILD_ENV $SPARSE_FLAGS" C=1
+    make -j2 CFLAGS="$CFLAGS $BUILD_ENV $SPARSE_FLAGS" C=1
 fi
 
 if [ "$TESTSUITE" ] && [ "$CC" != "clang" ]; then
-    if ! make distcheck RECHECK=yes; then
+    if ! make distcheck TESTSUITEFLAGS=-j4 RECHECK=yes; then
         # testsuite.log is necessary for debugging.
         cat */_build/tests/testsuite.log
         exit 1
diff --git a/.travis/linux-prepare.sh b/.travis/linux-prepare.sh
index 1f2e3dda4..5f5fd54c8 100755
--- a/.travis/linux-prepare.sh
+++ b/.travis/linux-prepare.sh
@@ -1,7 +1,12 @@
 #!/bin/bash
 
+# Build and install sparse.
+#
+# Explicitly disable sparse support for llvm because some travis
+# environments claim to have LLVM (llvm-config exists and works) but
+# linking against it fails.
 git clone git://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git
-cd sparse && make && make install && cd ..
+cd sparse && make HAVE_LLVM= install && cd ..
 
 # Incompatibility between flake8 3.0.x and the hacking plugin:
 # https://gitlab.com/pycqa/flake8/issues/153
diff --git a/.travis/osx-prepare.sh b/.travis/osx-prepare.sh
index 611c0709d..ae0771867 100755
--- a/.travis/osx-prepare.sh
+++ b/.travis/osx-prepare.sh
@@ -2,4 +2,5 @@
 set -ev
 pip install --user six
 
+brew update || true
 brew uninstall libtool && brew install libtool || true
diff --git a/AUTHORS b/AUTHORS
index 48ec51b87..63201d05c 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -3,6 +3,7 @@ vSwitch source code or webpage version control repository.
 
 Aaron Conole            aconole@redhat.com
 Aaron Rosen             arosen@clemson.edu
+Alan Pevec              alan.pevec@redhat.com
 Alexander Duyck         alexander.h.duyck@redhat.com
 Alexandru Copot         alex.mihai.c@gmail.com
 Alexei Starovoitov      ast@plumgrid.com
@@ -165,6 +166,7 @@ Maxime Coquelin         maxime.coquelin@redhat.com
 Mehak Mahajan           mmahajan@nicira.com
 Michael Arnaldi         arnaldimichael@gmail.com
 Michal Weglicki         michalx.weglicki@intel.com
+Mika Vaisanen           mika.vaisanen@gmail.com
 Mijo Safradin           mijo@linux.vnet.ibm.com
 Minoru TAKAHASHI        takahashi.minoru7@gmail.com
 Murphy McCauley         murphy.mccauley@gmail.com
@@ -244,6 +246,7 @@ Thomas Lacroix          thomas.lacroix@citrix.com
 Timo Puha               timox.puha@intel.com
 Todd Deshane            deshantm@gmail.com
 Tom Everman             teverman@google.com
+Torgny Lindberg         torgny.lindberg@ericsson.com
 Tsvi Slonim             tsvi@toroki.com
 Tuan Nguyen             tuan.nguyen@veriksystems.com
 Tyler Coumbes           coumbes@gmail.com
@@ -257,6 +260,7 @@ William Fulton
 William Tu              u9012063@gmail.com
 YAMAMOTO Takashi        yamamoto@midokura.com
 Yasuhito Takamiya       yasuhito@gmail.com
+Yi-Hung Wei             yihung.wei@gmail.com
 Yin Lin                 linyi@vmware.com
 Yu Zhiguo               yuzg@cn.fujitsu.com
 Yuanhan Liu             yuanhan.liu@linux.intel.com
@@ -443,6 +447,7 @@ Srini Seetharaman       seethara@stanford.edu
 Sabyasachi Sengupta     Sabyasachi.Sengupta@alcatel-lucent.com
 Salvatore Cambria       salvatore.cambria@citrix.com
 Soner Sevinc            sevincs@vmware.com
+Stepan Andrushko        stepanx.andrushko@intel.com
 Stephen Hemminger       shemminger@vyatta.com
 Stuart Cardall          developer@it-offshore.co.uk
 Suganya Ramachandran    suganyar@vmware.com
diff --git a/FAQ.md b/FAQ.md
index 8b73ab35b..75a393b4e 100644
--- a/FAQ.md
+++ b/FAQ.md
@@ -142,7 +142,7 @@ A: All official releases have been through a comprehensive testing
    LTS release, we will provide an updated release that includes the
    fix.  Releases that are not LTS may not be fixed and may just be
    supplanted by the next major release.  The current LTS release is
-   2.3.x.
+   2.5.x.
 
    For more information on the Open vSwitch release process, please
    see [release-process.md].
@@ -256,12 +256,12 @@ A: The following table lists the DPDK version against which the
    given versions of Open vSwitch will successfully build.
 
 | Open vSwitch | DPDK
-|:------------:|:-----:
+|:------------:|:-------:
 |    2.2.x     | 1.6
 |    2.3.x     | 1.6
 |    2.4.x     | 2.0
 |    2.5.x     | 2.2
-|    2.6.x     | 16.07
+|    2.6.x     | 16.07.2
 
 ### Q: I get an error like this when I configure Open vSwitch:
 
diff --git a/INSTALL.DPDK-ADVANCED.md b/INSTALL.DPDK-ADVANCED.md
index e3603a184..ae21aca80 100755
--- a/INSTALL.DPDK-ADVANCED.md
+++ b/INSTALL.DPDK-ADVANCED.md
@@ -46,7 +46,7 @@ for DPDK and OVS.
     For IVSHMEM case, set `export DPDK_TARGET=x86_64-ivshmem-linuxapp-gcc`
 
     ```
-    export DPDK_DIR=/usr/src/dpdk-16.07
+    export DPDK_DIR=/usr/src/dpdk-stable-16.07.2
     export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET
     make install T=$DPDK_TARGET DESTDIR=install
     ```
@@ -342,7 +342,7 @@ For users wanting to do packet forwarding using kernel stack below are the steps
        cd /usr/src/cmdline_generator
        wget https://raw.githubusercontent.com/netgroup-polito/un-orchestrator/master/orchestrator/compute_controller/plugins/kvm-libvirt/cmdline_generator/cmdline_generator.c
        wget https://raw.githubusercontent.com/netgroup-polito/un-orchestrator/master/orchestrator/compute_controller/plugins/kvm-libvirt/cmdline_generator/Makefile
-       export RTE_SDK=/usr/src/dpdk-16.07
+       export RTE_SDK=/usr/src/dpdk-stable-16.07.2
        export RTE_TARGET=x86_64-ivshmem-linuxapp-gcc
        make
        ./build/cmdline_generator -m -p dpdkr0 XXX
@@ -366,7 +366,7 @@ For users wanting to do packet forwarding using kernel stack below are the steps
        mount -t hugetlbfs nodev /dev/hugepages (if not already mounted)
 
        # Build the DPDK ring application in the VM
-       export RTE_SDK=/root/dpdk-16.07
+       export RTE_SDK=/root/dpdk-stable-16.07.2
        export RTE_TARGET=x86_64-ivshmem-linuxapp-gcc
        make
 
diff --git a/INSTALL.DPDK.md b/INSTALL.DPDK.md
index 30e925887..f4d39ff93 100644
--- a/INSTALL.DPDK.md
+++ b/INSTALL.DPDK.md
@@ -21,7 +21,7 @@ The DPDK support of Open vSwitch is considered 'experimental'.
 
 ### Prerequisites
 
-* Required: DPDK 16.07
+* Required: DPDK 16.07.2
 * Hardware: [DPDK Supported NICs] when physical ports in use
 
 ## <a name="build"></a> 2. Building and Installation
@@ -42,10 +42,9 @@ advanced install guide [INSTALL.DPDK-ADVANCED.md]
 
      ```
      cd /usr/src/
-     wget http://dpdk.org/browse/dpdk/snapshot/dpdk-16.07.zip
-     unzip dpdk-16.07.zip
-
-     export DPDK_DIR=/usr/src/dpdk-16.07
+     wget http://fast.dpdk.org/rel/dpdk-16.07.2.tar.xz
+     tar xf dpdk-16.07.2.tar.xz
+     export DPDK_DIR=/usr/src/dpdk-stable-16.07.2
      cd $DPDK_DIR
      ```
 
@@ -215,7 +214,9 @@ advanced install guide [INSTALL.DPDK-ADVANCED.md]
 
      * dpdk-socket-mem
      Comma separated list of memory to pre-allocate from hugepages on specific
-     sockets.
+     sockets. Please note when using this param for some NUMA nodes, that
+     subsequent NUMA nodes will be assigned 0 MB if they are not explicitly
+     assigned a value.
 
      * dpdk-hugepage-dir
      Directory where hugetlbfs is mounted
@@ -372,9 +373,9 @@ can be found in [Vhost Walkthrough].
 
   ```
   cd /root/dpdk/
-  wget http://dpdk.org/browse/dpdk/snapshot/dpdk-16.07.zip
-  unzip dpdk-16.07.zip
-  export DPDK_DIR=/root/dpdk/dpdk-16.07
+  wget http://fast.dpdk.org/rel/dpdk-16.07.2.tar.xz
+  tar xf dpdk-16.07.2.tar.xz
+  export DPDK_DIR=/usr/src/dpdk-stable-16.07.2
   export DPDK_TARGET=x86_64-native-linuxapp-gcc
   export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET
   cd $DPDK_DIR
@@ -530,7 +531,7 @@ can be found in [Vhost Walkthrough].
            </disk>
            <disk type='dir' device='disk'>
              <driver name='qemu' type='fat'/>
-             <source dir='/usr/src/dpdk-16.07'/>
+             <source dir='/usr/src/dpdk-stable-16.07.2'/>
              <target dev='vdb' bus='virtio'/>
              <readonly/>
            </disk>
@@ -599,10 +600,9 @@ can be found in [Vhost Walkthrough].
     DPDK. It is recommended that users update Network Interface firmware to
     match what has been validated for the DPDK release.
 
-    For DPDK 16.07, the list of validated firmware versions can be found at:
-
-    http://dpdk.org/doc/guides/rel_notes/release_16.07.html
+    For DPDK 16.07.2, the list of validated firmware versions can be found at:
 
+    http://dpdk.org/doc/guides-16.07/rel_notes/release_16_07.html
 
 Bug Reporting:
 --------------
diff --git a/INSTALL.Fedora.md b/INSTALL.Fedora.md
index cb41d5c3f..44e85af29 100644
--- a/INSTALL.Fedora.md
+++ b/INSTALL.Fedora.md
@@ -22,6 +22,7 @@ documented in [INSTALL.md]. Specific packages (by package name) include:
   - desktop-file-utils
   - groff graphviz
   - procps-ng
+  - checkpolicy selinux-policy-devel
 
 And (optionally):
 
diff --git a/INSTALL.RHEL.md b/INSTALL.RHEL.md
index 3c3f1a77d..4448a6ca6 100644
--- a/INSTALL.RHEL.md
+++ b/INSTALL.RHEL.md
@@ -41,7 +41,7 @@ $HOME/rpmbuild/SOURCES.
    ```
    yum install gcc make python-devel openssl-devel kernel-devel graphviz \
        kernel-debug-devel autoconf automake rpm-build redhat-rpm-config \
-       libtool
+       libtool checkpolicy selinux-policy-devel
    ```
 
 2. If you are building from a distribution tarball, skip to step 3.
diff --git a/Makefile.am b/Makefile.am
index 49010b3b5..90eb9a0a8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -371,7 +371,7 @@ ALL_LOCAL += flake8-check
 #   H233 Python 3.x incompatible use of print operator
 #   H238 old style class declaration, use new style (inherit from `object`)
 flake8-check: $(FLAKE8_PYFILES)
-	$(AM_V_GEN) if flake8 $^ --select=H231,H232,H233,H238 ${FLAKE8_FLAGS} && \
+	$(FLAKE8_WERROR)$(AM_V_GEN) if flake8 $^ --select=H231,H232,H233,H238 ${FLAKE8_FLAGS} && \
 		flake8 $^ --ignore=E121,E123,E125,E126,E127,E128,E129,E131,W503,F811,D,H ${FLAKE8_FLAGS}; then \
 		touch $@; else exit 1; fi
 endif
diff --git a/NEWS b/NEWS
index 4c1f3919f..99702975a 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,7 @@
+v2.6.2 - xx xxx xxxx
+---------------------
+
+
 v2.6.1 - 01 Nov 2016
 ---------------------
    - Fedora packaging:
diff --git a/acinclude.m4 b/acinclude.m4
index 2c500a8d1..cf71026d6 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -23,7 +23,16 @@ AC_DEFUN([OVS_ENABLE_WERROR],
    AC_CONFIG_COMMANDS_PRE(
      [if test "X$enable_Werror" = Xyes; then
         OVS_CFLAGS="$OVS_CFLAGS -Werror"
-      fi])])
+      fi])
+
+   # Unless --enable-Werror is specified, report but do not fail the build
+   # for errors reported by flake8.
+   if test "X$enable_Werror" = Xyes; then
+     FLAKE8_WERROR=
+   else
+     FLAKE8_WERROR=-
+   fi
+   AC_SUBST([FLAKE8_WERROR])])
 
 dnl OVS_CHECK_LINUX
 dnl
diff --git a/build-aux/extract-ofp-errors b/build-aux/extract-ofp-errors
index 9642593d2..2312b76ed 100755
--- a/build-aux/extract-ofp-errors
+++ b/build-aux/extract-ofp-errors
@@ -391,7 +391,8 @@ static const char *error_comments[OFPERR_N_ERRORS] = {
 static enum ofperr
 %s_decode(uint32_t vendor, uint16_t type, uint16_t code)
 {
-    switch (((uint64_t) vendor << 32) | (type << 16) | code) {""" % name)
+    switch (((uint64_t) vendor << 32) | (uint32_t) (type << 16) | code) {"""
+               % name)
         found = set()
         for enum in names:
             if enum not in map:
@@ -405,7 +406,8 @@ static enum ofperr
                 vendor_s = "(%#xULL << 32) | " % vendor
             else:
                 vendor_s = ""
-            print ("    case %s(%d << 16) | %d:" % (vendor_s, type_, code))
+            print ("    case %s(uint32_t) (%d << 16) | %d:" % (vendor_s,
+                                                               type_, code))
             print ("        return OFPERR_%s;" % enum)
         print ("""\
     }
diff --git a/configure.ac b/configure.ac
index da3bbaeb4..0338fd52f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -13,7 +13,7 @@
 # limitations under the License.
 
 AC_PREREQ(2.63)
-AC_INIT(openvswitch, 2.6.1, bugs@openvswitch.org)
+AC_INIT(openvswitch, 2.6.2, bugs@openvswitch.org)
 AC_CONFIG_SRCDIR([datapath/datapath.c])
 AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_AUX_DIR([build-aux])
diff --git a/datapath/conntrack.c b/datapath/conntrack.c
index 824a33f2e..1f7e1b6f8 100644
--- a/datapath/conntrack.c
+++ b/datapath/conntrack.c
@@ -80,6 +80,8 @@ struct ovs_conntrack_info {
 #endif
 };
 
+static bool labels_nonzero(const struct ovs_key_ct_labels *labels);
+
 static void __ovs_ct_free_action(struct ovs_conntrack_info *ct_info);
 
 static u16 key_to_nfproto(const struct sw_flow_key *key)
@@ -136,31 +138,20 @@ static u32 ovs_ct_get_mark(const struct nf_conn *ct)
 #endif
 }
 
-static size_t ovs_ct_get_labels_len(struct nf_conn_labels *cl)
-{
-#ifdef HAVE_NF_CONN_LABELS_WITH_WORDS
-	return cl->words * sizeof(long);
-#else
-	return sizeof(cl->bits);
+/* Guard against conntrack labels max size shrinking below 128 bits. */
+#if NF_CT_LABELS_MAX_SIZE < 16
+#error NF_CT_LABELS_MAX_SIZE must be at least 16 bytes
 #endif
-}
 
 static void ovs_ct_get_labels(const struct nf_conn *ct,
 			      struct ovs_key_ct_labels *labels)
 {
 	struct nf_conn_labels *cl = ct ? nf_ct_labels_find(ct) : NULL;
 
-	if (cl) {
-		size_t len = ovs_ct_get_labels_len(cl);
-
-		if (len > OVS_CT_LABELS_LEN)
-			len = OVS_CT_LABELS_LEN;
-		else if (len < OVS_CT_LABELS_LEN)
-			memset(labels, 0, OVS_CT_LABELS_LEN);
-		memcpy(labels, cl->bits, len);
-	} else {
+	if (cl)
+		memcpy(labels, cl->bits, OVS_CT_LABELS_LEN);
+	else
 		memset(labels, 0, OVS_CT_LABELS_LEN);
-	}
 }
 
 static void __ovs_ct_update_key(struct sw_flow_key *key, u8 state,
@@ -245,23 +236,17 @@ int ovs_ct_put_key(const struct sw_flow_key *key, struct sk_buff *skb)
 	return 0;
 }
 
-static int ovs_ct_set_mark(struct sk_buff *skb, struct sw_flow_key *key,
+static int ovs_ct_set_mark(struct nf_conn *ct, struct sw_flow_key *key,
 			   u32 ct_mark, u32 mask)
 {
 #if IS_ENABLED(CONFIG_NF_CONNTRACK_MARK)
-	enum ip_conntrack_info ctinfo;
-	struct nf_conn *ct;
 	u32 new_mark;
 
-	/* The connection could be invalid, in which case set_mark is no-op. */
-	ct = nf_ct_get(skb, &ctinfo);
-	if (!ct)
-		return 0;
-
 	new_mark = ct_mark | (ct->mark & ~(mask));
 	if (ct->mark != new_mark) {
 		ct->mark = new_mark;
-		nf_conntrack_event_cache(IPCT_MARK, ct);
+		if (nf_ct_is_confirmed(ct))
+			nf_conntrack_event_cache(IPCT_MARK, ct);
 		key->ct.mark = new_mark;
 	}
 
@@ -271,19 +256,9 @@ static int ovs_ct_set_mark(struct sk_buff *skb, struct sw_flow_key *key,
 #endif
 }
 
-static int ovs_ct_set_labels(struct sk_buff *skb, struct sw_flow_key *key,
-			     const struct ovs_key_ct_labels *labels,
-			     const struct ovs_key_ct_labels *mask)
+static struct nf_conn_labels *ovs_ct_get_conn_labels(struct nf_conn *ct)
 {
-	enum ip_conntrack_info ctinfo;
 	struct nf_conn_labels *cl;
-	struct nf_conn *ct;
-	int err;
-
-	/* The connection could be invalid, in which case set_label is no-op.*/
-	ct = nf_ct_get(skb, &ctinfo);
-	if (!ct)
-		return 0;
 
 	cl = nf_ct_labels_find(ct);
 	if (!cl) {
@@ -291,15 +266,76 @@ static int ovs_ct_set_labels(struct sk_buff *skb, struct sw_flow_key *key,
 		cl = nf_ct_labels_find(ct);
 	}
 
-	if (!cl || ovs_ct_get_labels_len(cl) < OVS_CT_LABELS_LEN)
+	return cl;
+}
+
+/* Initialize labels for a new, yet to be committed conntrack entry.  Note that
+ * since the new connection is not yet confirmed, and thus no-one else has
+ * access to it's labels, we simply write them over.
+ */
+static int ovs_ct_init_labels(struct nf_conn *ct, struct sw_flow_key *key,
+			      const struct ovs_key_ct_labels *labels,
+			      const struct ovs_key_ct_labels *mask)
+{
+	struct nf_conn_labels *cl, *master_cl;
+	bool have_mask = labels_nonzero(mask);
+
+	/* Inherit master's labels to the related connection? */
+	master_cl = ct->master ? nf_ct_labels_find(ct->master) : NULL;
+
+	if (!master_cl && !have_mask)
+		return 0;   /* Nothing to do. */
+
+	cl = ovs_ct_get_conn_labels(ct);
+	if (!cl)
+		return -ENOSPC;
+
+	/* Inherit the master's labels, if any.  Must use memcpy for backport
+	 * as struct assignment only copies the length field in older
+	 * kernels.
+	 */
+	if (master_cl)
+		memcpy(cl->bits, master_cl->bits, OVS_CT_LABELS_LEN);
+
+	if (have_mask) {
+		u32 *dst = (u32 *)cl->bits;
+		int i;
+
+		for (i = 0; i < OVS_CT_LABELS_LEN_32; i++)
+			dst[i] = (dst[i] & ~mask->ct_labels_32[i]) |
+				(labels->ct_labels_32[i]
+				 & mask->ct_labels_32[i]);
+	}
+
+	/* Labels are included in the IPCTNL_MSG_CT_NEW event only if the
+	 * IPCT_LABEL bit it set in the event cache.
+	 */
+	nf_conntrack_event_cache(IPCT_LABEL, ct);
+
+	memcpy(&key->ct.labels, cl->bits, OVS_CT_LABELS_LEN);
+
+	return 0;
+}
+
+static int ovs_ct_set_labels(struct nf_conn *ct, struct sw_flow_key *key,
+			     const struct ovs_key_ct_labels *labels,
+			     const struct ovs_key_ct_labels *mask)
+{
+	struct nf_conn_labels *cl;
+	int err;
+
+	cl = ovs_ct_get_conn_labels(ct);
+	if (!cl)
 		return -ENOSPC;
 
-	err = nf_connlabels_replace(ct, (u32 *)labels, (u32 *)mask,
-				    OVS_CT_LABELS_LEN / sizeof(u32));
+	err = nf_connlabels_replace(ct, labels->ct_labels_32,
+				    mask->ct_labels_32,
+				    OVS_CT_LABELS_LEN_32);
 	if (err)
 		return err;
 
-	ovs_ct_get_labels(ct, &key->ct.labels);
+	memcpy(&key->ct.labels, cl->bits, OVS_CT_LABELS_LEN);
+
 	return 0;
 }
 
@@ -314,6 +350,11 @@ static int ovs_ct_helper(struct sk_buff *skb, u16 proto)
 	u8 nexthdr;
 	int err;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	bool dst_set = false;
+	struct rtable rt = { .rt_flags = 0 };
+#endif
+
 	ct = nf_ct_get(skb, &ctinfo);
 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
 		return NF_ACCEPT;
@@ -352,43 +393,25 @@ static int ovs_ct_helper(struct sk_buff *skb, u16 proto)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
 	/* Linux 4.5 and older depend on skb_dst being set when recalculating
 	 * checksums after NAT helper has mangled TCP or UDP packet payload.
-	 * This dependency is avoided when skb is CHECKSUM_PARTIAL or when UDP
-	 * has no checksum.
-	 *
-	 * The dependency is not triggered when the main NAT code updates
-	 * checksums after translating the IP header (address, port), so this
-	 * fix only needs to be executed on packets that are both being NATted
-	 * and that have a helper assigned.
+	 * skb_dst is cast to a rtable struct and the flags examined.
+	 * Forcing these flags to have RTCF_LOCAL not set ensures checksum mod
+	 * is carried out in the same way as kernel versions > 4.5
 	 */
-	if (ct->status & IPS_NAT_MASK && skb->ip_summed != CHECKSUM_PARTIAL) {
-		u8 ipproto = (proto == NFPROTO_IPV4)
-			? ip_hdr(skb)->protocol : nexthdr;
-		u16 offset = 0;
-
-		switch (ipproto) {
-		case IPPROTO_TCP:
-			offset = offsetof(struct tcphdr, check);
-			break;
-		case IPPROTO_UDP:
-			/* Skip if no csum. */
-			if (udp_hdr(skb)->check)
-				offset = offsetof(struct udphdr, check);
-			break;
-		}
-		if (offset) {
-			if (unlikely(!pskb_may_pull(skb, protoff + offset + 2)))
-				return NF_DROP;
-
-			skb->csum_start = skb_headroom(skb) + protoff;
-			skb->csum_offset = offset;
-			skb->ip_summed = CHECKSUM_PARTIAL;
-		}
+	if (ct->status & IPS_NAT_MASK && skb->ip_summed != CHECKSUM_PARTIAL
+	    && !skb_dst(skb)) {
+		dst_set = true;
+		skb_dst_set(skb, &rt.dst);
 	}
 #endif
 	err = helper->help(skb, protoff, ct, ctinfo);
 	if (err != NF_ACCEPT)
 		return err;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	if (dst_set)
+		skb_dst_set(skb, NULL);
+#endif
+
 	/* Adjust seqs after helper.  This is needed due to some helpers (e.g.,
 	 * FTP with NAT) adusting the TCP payload size when mangling IP
 	 * addresses and/or port numbers in the text-based control connection.
@@ -424,8 +447,11 @@ static int handle_fragments(struct net *net, struct sw_flow_key *key,
 		skb_orphan(skb);
 		memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
 		err = nf_ct_frag6_gather(net, skb, user);
-		if (err)
+		if (err) {
+			if (err != -EINPROGRESS)
+				kfree_skb(skb);
 			return err;
+		}
 
 		key->ip.proto = ipv6_hdr(skb)->nexthdr;
 		ovs_cb.dp_cb.mru = IP6CB(skb)->frag_max_size;
@@ -481,7 +507,7 @@ ovs_ct_get_info(const struct nf_conntrack_tuple_hash *h)
  */
 static struct nf_conn *
 ovs_ct_find_existing(struct net *net, const struct nf_conntrack_zone *zone,
-		     u8 l3num, struct sk_buff *skb)
+		     u8 l3num, struct sk_buff *skb, bool natted)
 {
 	struct nf_conntrack_l3proto *l3proto;
 	struct nf_conntrack_l4proto *l4proto;
@@ -504,6 +530,17 @@ ovs_ct_find_existing(struct net *net, const struct nf_conntrack_zone *zone,
 		return NULL;
 	}
 
+	/* Must invert the tuple if skb has been transformed by NAT. */
+	if (natted) {
+		struct nf_conntrack_tuple inverse;
+
+		if (!nf_ct_invert_tuple(&inverse, &tuple, l3proto, l4proto)) {
+			pr_debug("ovs_ct_find_existing: Inversion failed!\n");
+			return NULL;
+		}
+		tuple = inverse;
+	}
+
 	/* look for tuple match */
 	h = nf_conntrack_find_get(net, zone, &tuple);
 	if (!h)
@@ -511,6 +548,13 @@ ovs_ct_find_existing(struct net *net, const struct nf_conntrack_zone *zone,
 
 	ct = nf_ct_tuplehash_to_ctrack(h);
 
+	/* Inverted packet tuple matches the reverse direction conntrack tuple,
+	 * select the other tuplehash to get the right 'ctinfo' bits for this
+	 * packet.
+	 */
+	if (natted)
+		h = &ct->tuplehash[!h->tuple.dst.dir];
+
 	skb->nfct = &ct->ct_general;
 	skb->nfctinfo = ovs_ct_get_info(h);
 	return ct;
@@ -534,7 +578,9 @@ static bool skb_nfct_cached(struct net *net,
 	if (!ct && key->ct.state & OVS_CS_F_TRACKED &&
 	    !(key->ct.state & OVS_CS_F_INVALID) &&
 	    key->ct.zone == info->zone.id)
-		ct = ovs_ct_find_existing(net, &info->zone, info->family, skb);
+		ct = ovs_ct_find_existing(net, &info->zone, info->family, skb,
+					  !!(key->ct.state
+					     & OVS_CS_F_NAT_MASK));
 	if (!ct)
 		return false;
 	if (!net_eq(net, read_pnet(&ct->ct_net)))
@@ -565,7 +611,7 @@ static int ovs_ct_nat_execute(struct sk_buff *skb, struct nf_conn *ct,
 	int hooknum, nh_off, err = NF_ACCEPT;
 
 	nh_off = skb_network_offset(skb);
-	skb_pull(skb, nh_off);
+	skb_pull_rcsum(skb, nh_off);
 
 	/* See HOOK2MANIP(). */
 	if (maniptype == NF_NAT_MANIP_SRC)
@@ -630,6 +676,7 @@ static int ovs_ct_nat_execute(struct sk_buff *skb, struct nf_conn *ct,
 	err = nf_nat_packet(ct, ctinfo, hooknum, skb);
 push:
 	skb_push(skb, nh_off);
+	skb_postpush_rcsum(skb, skb->data, nh_off);
 
 	return err;
 }
@@ -779,12 +826,8 @@ static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
 			skb->nfctinfo = IP_CT_NEW;
 		}
 
-		/* Repeat if requested, see nf_iterate(). */
-		do {
-			err = nf_conntrack_in(net, info->family,
-					      NF_INET_FORWARD, skb);
-		} while (err == NF_REPEAT);
-
+		err = nf_conntrack_in(net, info->family,
+				      NF_INET_FORWARD, skb);
 		if (err != NF_ACCEPT)
 			return -ENOENT;
 
@@ -886,8 +929,8 @@ static bool labels_nonzero(const struct ovs_key_ct_labels *labels)
 {
 	size_t i;
 
-	for (i = 0; i < sizeof(*labels); i++)
-		if (labels->ct_labels[i])
+	for (i = 0; i < OVS_CT_LABELS_LEN_32; i++)
+		if (labels->ct_labels_32[i])
 			return true;
 
 	return false;
@@ -898,24 +941,36 @@ static int ovs_ct_commit(struct net *net, struct sw_flow_key *key,
 			 const struct ovs_conntrack_info *info,
 			 struct sk_buff *skb)
 {
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
 	int err;
 
 	err = __ovs_ct_lookup(net, key, info, skb);
 	if (err)
 		return err;
 
+	/* The connection could be invalid, in which case this is a no-op.*/
+	ct = nf_ct_get(skb, &ctinfo);
+	if (!ct)
+		return 0;
+
 	/* Apply changes before confirming the connection so that the initial
 	 * conntrack NEW netlink event carries the values given in the CT
 	 * action.
 	 */
 	if (info->mark.mask) {
-		err = ovs_ct_set_mark(skb, key, info->mark.value,
+		err = ovs_ct_set_mark(ct, key, info->mark.value,
 				      info->mark.mask);
 		if (err)
 			return err;
 	}
-	if (labels_nonzero(&info->labels.mask)) {
-		err = ovs_ct_set_labels(skb, key, &info->labels.value,
+	if (!nf_ct_is_confirmed(ct)) {
+		err = ovs_ct_init_labels(ct, key, &info->labels.value,
+					 &info->labels.mask);
+		if (err)
+			return err;
+	} else if (labels_nonzero(&info->labels.mask)) {
+		err = ovs_ct_set_labels(ct, key, &info->labels.value,
 					&info->labels.mask);
 		if (err)
 			return err;
@@ -941,7 +996,7 @@ int ovs_ct_execute(struct net *net, struct sk_buff *skb,
 
 	/* The conntrack module expects to be working at L3. */
 	nh_ofs = skb_network_offset(skb);
-	skb_pull(skb, nh_ofs);
+	skb_pull_rcsum(skb, nh_ofs);
 
 	if (key->ip.frag != OVS_FRAG_TYPE_NONE) {
 		err = handle_fragments(net, key, info->zone.id, skb);
@@ -955,6 +1010,7 @@ int ovs_ct_execute(struct net *net, struct sk_buff *skb,
 		err = ovs_ct_lookup(net, key, info, skb);
 
 	skb_push(skb, nh_ofs);
+	skb_postpush_rcsum(skb, skb->data, nh_ofs);
 	if (err)
 		kfree_skb(skb);
 	return err;
@@ -1143,8 +1199,8 @@ static int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,
 
 	nla_for_each_nested(a, attr, rem) {
 		int type = nla_type(a);
-		int maxlen = ovs_ct_attr_lens[type].maxlen;
-		int minlen = ovs_ct_attr_lens[type].minlen;
+		int maxlen;
+		int minlen;
 
 		if (type > OVS_CT_ATTR_MAX) {
 			OVS_NLERR(log,
@@ -1152,6 +1208,9 @@ static int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,
 				  type, OVS_CT_ATTR_MAX);
 			return -EINVAL;
 		}
+
+		maxlen = ovs_ct_attr_lens[type].maxlen;
+		minlen = ovs_ct_attr_lens[type].minlen;
 		if (nla_len(a) < minlen || nla_len(a) > maxlen) {
 			OVS_NLERR(log,
 				  "Conntrack attr type has unexpected length (type=%d, length=%d, expected=%d)",
diff --git a/datapath/flow.c b/datapath/flow.c
index 390286c98..6d5664497 100644
--- a/datapath/flow.c
+++ b/datapath/flow.c
@@ -141,7 +141,8 @@ void ovs_flow_stats_get(const struct sw_flow *flow,
 	*tcp_flags = 0;
 	memset(ovs_stats, 0, sizeof(*ovs_stats));
 
-	for_each_node(node) {
+	/* We open code this to make sure node 0 is always considered */
+	for (node = 0; node < MAX_NUMNODES; node = next_node(node, node_possible_map)) {
 		struct flow_stats *stats = rcu_dereference_ovsl(flow->stats[node]);
 
 		if (stats) {
@@ -164,7 +165,8 @@ void ovs_flow_stats_clear(struct sw_flow *flow)
 {
 	int node;
 
-	for_each_node(node) {
+	/* We open code this to make sure node 0 is always considered */
+	for (node = 0; node < MAX_NUMNODES; node = next_node(node, node_possible_map)) {
 		struct flow_stats *stats = ovsl_dereference(flow->stats[node]);
 
 		if (stats) {
diff --git a/datapath/flow_table.c b/datapath/flow_table.c
index d4204e503..3829b920b 100644
--- a/datapath/flow_table.c
+++ b/datapath/flow_table.c
@@ -154,7 +154,8 @@ static void flow_free(struct sw_flow *flow)
 		kfree(flow->id.unmasked_key);
 	if (flow->sf_acts)
 		ovs_nla_free_flow_actions((struct sw_flow_actions __force *)flow->sf_acts);
-	for_each_node(node)
+	/* We open code this to make sure node 0 is always considered */
+	for (node = 0; node < MAX_NUMNODES; node = next_node(node, node_possible_map))
 		if (flow->stats[node])
 			kmem_cache_free(flow_stats_cache,
 					rcu_dereference_raw(flow->stats[node]));
diff --git a/datapath/linux/compat/include/linux/netdevice.h b/datapath/linux/compat/include/linux/netdevice.h
index dd028f6e4..bca279901 100644
--- a/datapath/linux/compat/include/linux/netdevice.h
+++ b/datapath/linux/compat/include/linux/netdevice.h
@@ -22,9 +22,6 @@ struct net;
 #define IFF_LIVE_ADDR_CHANGE 0
 #endif
 
-#ifndef IFF_NO_QUEUE
-#define IFF_NO_QUEUE	0
-#endif
 #ifndef IFF_OPENVSWITCH
 #define IFF_OPENVSWITCH 0
 #endif
diff --git a/datapath/linux/compat/include/linux/openvswitch.h b/datapath/linux/compat/include/linux/openvswitch.h
index 12260d8bf..76a19ed3e 100644
--- a/datapath/linux/compat/include/linux/openvswitch.h
+++ b/datapath/linux/compat/include/linux/openvswitch.h
@@ -472,9 +472,13 @@ struct ovs_key_nd {
 	__u8	nd_tll[ETH_ALEN];
 };
 
-#define OVS_CT_LABELS_LEN	16
+#define OVS_CT_LABELS_LEN_32	4
+#define OVS_CT_LABELS_LEN	(OVS_CT_LABELS_LEN_32 * sizeof(__u32))
 struct ovs_key_ct_labels {
-	__u8	ct_labels[OVS_CT_LABELS_LEN];
+	union {
+		__u8	ct_labels[OVS_CT_LABELS_LEN];
+		__u32	ct_labels_32[OVS_CT_LABELS_LEN_32];
+	};
 };
 
 /* OVS_KEY_ATTR_CT_STATE flags */
diff --git a/datapath/linux/compat/include/net/netfilter/nf_conntrack_core.h b/datapath/linux/compat/include/net/netfilter/nf_conntrack_core.h
index 09a53c325..16b57a647 100644
--- a/datapath/linux/compat/include/net/netfilter/nf_conntrack_core.h
+++ b/datapath/linux/compat/include/net/netfilter/nf_conntrack_core.h
@@ -67,4 +67,25 @@ static inline bool rpl_nf_ct_get_tuple(const struct sk_buff *skb,
 #define nf_ct_get_tuple rpl_nf_ct_get_tuple
 #endif /* HAVE_NF_CT_GET_TUPLEPR_TAKES_STRUCT_NET */
 
+/* Commit 08733a0cb7de ("netfilter: handle NF_REPEAT from nf_conntrack_in()")
+ * introduced behavioural changes to this function which cannot be detected
+ * in the headers. Unconditionally backport to kernels older than the one which
+ * contains this commit. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+static unsigned int rpl_nf_conntrack_in(struct net *net, u_int8_t pf,
+					unsigned int hooknum,
+					struct sk_buff *skb)
+{
+	int err;
+
+	/* Repeat if requested, see nf_iterate(). */
+	do {
+		err = nf_conntrack_in(net, pf, hooknum, skb);
+	} while (err == NF_REPEAT);
+
+	return err;
+}
+#define nf_conntrack_in rpl_nf_conntrack_in
+#endif /* < 4.10 */
+
 #endif /* _NF_CONNTRACK_CORE_WRAPPER_H */
diff --git a/datapath/linux/compat/vxlan.c b/datapath/linux/compat/vxlan.c
index d5dbe8d06..d27a5e293 100644
--- a/datapath/linux/compat/vxlan.c
+++ b/datapath/linux/compat/vxlan.c
@@ -320,7 +320,7 @@ static struct sk_buff **vxlan_gro_receive(struct sk_buff **head,
 
 	flags = vh->vx_flags;
 
-	if ((flags & VXLAN_HF_RCO) && (vs->flags & VXLAN_F_REMCSUM_RX)) {
+	if ((flags & VXLAN_HF_RCO) && vs && (vs->flags & VXLAN_F_REMCSUM_RX)) {
 		vh = vxlan_gro_remcsum(skb, off_vx, vh, sizeof(struct vxlanhdr),
 				       vh->vx_vni, &grc,
 				       !!(vs->flags &
@@ -916,7 +916,7 @@ static struct rtable *vxlan_get_route(struct vxlan_dev *vxlan,
 				      struct dst_cache *dst_cache,
 				      const struct ip_tunnel_info *info)
 {
-	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+	bool use_cache = (dst_cache && ip_tunnel_dst_cache_usable(skb, info));
 	struct rtable *rt = NULL;
 	struct flowi4 fl4;
 
@@ -955,7 +955,7 @@ static struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,
 					  const struct ip_tunnel_info *info)
 {
 	struct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);
-	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
+	bool use_cache = (dst_cache && ip_tunnel_dst_cache_usable(skb, info));
 	struct dst_entry *ndst;
 	struct flowi6 fl6;
 	int err;
@@ -1740,8 +1740,6 @@ static struct vxlan_sock *vxlan_socket_create(struct net *net, bool ipv6,
 
 	sock = vxlan_create_sock(net, ipv6, port, flags);
 	if (IS_ERR(sock)) {
-		pr_info("Cannot bind port %d, err=%ld\n", ntohs(port),
-			PTR_ERR(sock));
 		kfree(vs);
 		return ERR_CAST(sock);
 	}
@@ -1808,17 +1806,21 @@ static int __vxlan_sock_add(struct vxlan_dev *vxlan, bool ipv6)
 
 static int vxlan_sock_add(struct vxlan_dev *vxlan)
 {
-	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
 	bool metadata = vxlan->flags & VXLAN_F_COLLECT_METADATA;
+	bool ipv6 = vxlan->flags & VXLAN_F_IPV6 || metadata;
+	bool ipv4 = !ipv6 || metadata;
 	int ret = 0;
 
 	RCU_INIT_POINTER(vxlan->vn4_sock, NULL);
 #if IS_ENABLED(CONFIG_IPV6)
 	RCU_INIT_POINTER(vxlan->vn6_sock, NULL);
-	if (ipv6 || metadata)
+	if (ipv6) {
 		ret = __vxlan_sock_add(vxlan, true);
+		if (ret < 0 && ret != -EAFNOSUPPORT)
+			ipv4 = false;
+	}
 #endif
-	if (!ret && (!ipv6 || metadata))
+	if (ipv4)
 		ret = __vxlan_sock_add(vxlan, false);
 	if (ret < 0)
 		vxlan_sock_release(vxlan);
diff --git a/debian/changelog b/debian/changelog
index ab76870e3..58fd841af 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,11 @@
+openvswitch (2.6.2-1) unstable; urgency=low
+   [ Open vSwitch team ]
+   * New upstream version
+   - Nothing yet!
+
+ -- Open vSwitch team <dev@openvswitch.org>  Tue, 01 Nov 2016 15:42:39 -0700
+
+
 openvswitch (2.6.1-1) unstable; urgency=low
    [ Open vSwitch team ]
    * New upstream version
diff --git a/debian/control b/debian/control
index da86fe9fd..f33a649f5 100644
--- a/debian/control
+++ b/debian/control
@@ -161,7 +161,7 @@ Description: OVN central components
  databases for OVN that is run at a central location.
 
 Package: ovn-docker
-Architecture: any
+Architecture: linux-any
 Depends: openvswitch-switch (= ${binary:Version}),
          openvswitch-common (= ${binary:Version}),
          python (>= 2.7),
diff --git a/debian/openvswitch-switch.init b/debian/openvswitch-switch.init
index 1e94015d1..5c7c08b3a 100755
--- a/debian/openvswitch-switch.init
+++ b/debian/openvswitch-switch.init
@@ -28,6 +28,7 @@
 (test -x /usr/sbin/ovs-vswitchd && test -x /usr/sbin/ovsdb-server) || exit 0
 
 _SYSTEMCTL_SKIP_REDIRECT=yes
+SYSTEMCTL_SKIP_REDIRECT=yes
 
 . /usr/share/openvswitch/scripts/ovs-lib
 test -e /etc/default/openvswitch-switch && . /etc/default/openvswitch-switch
diff --git a/debian/openvswitch-switch.postinst b/debian/openvswitch-switch.postinst
index 246457249..3f9b0553f 100755
--- a/debian/openvswitch-switch.postinst
+++ b/debian/openvswitch-switch.postinst
@@ -20,19 +20,28 @@ set -e
 
 case "$1" in
     configure)
-	DEFAULT=/etc/default/openvswitch-switch
-	TEMPLATE=/usr/share/openvswitch/switch/default.template
-	if ! test -e $DEFAULT; then
-	    cp $TEMPLATE $DEFAULT
-	else
-            for var in $(awk -F'[ :]' '/^# [_A-Z0-9]+:/{print $2}' $TEMPLATE)
-            do
-                if ! grep $var $DEFAULT >/dev/null 2>&1; then
-	            echo >> $DEFAULT
-	            sed -n "/$var:/,/$var=/p" $TEMPLATE >> $DEFAULT
-                fi
-            done
-	fi
+        DEFAULT=/etc/default/openvswitch-switch
+        TEMPLATE=/usr/share/openvswitch/switch/default.template
+        if ! test -e $DEFAULT; then
+            cp $TEMPLATE $DEFAULT
+        else
+                for var in $(awk -F'[ :]' '/^# [_A-Z0-9]+:/{print $2}' $TEMPLATE)
+                do
+                    if ! grep $var $DEFAULT >/dev/null 2>&1; then
+                        echo >> $DEFAULT
+                        sed -n "/$var:/,/$var=/p" $TEMPLATE >> $DEFAULT
+                    fi
+                done
+        fi
+        # Certain versions of upstream Ubuntu's openvswitch packages (which
+        # are forks) may install upstart files which are incompatible
+        # with the packages generated from this repo. Remove them.
+        if [ -e "/etc/init/openvswitch-switch.conf" ]; then
+            rm /etc/init/openvswitch-switch.conf
+        fi
+        if [ -e "/etc/init/openvswitch-force-reload-kmod.conf" ]; then
+            rm /etc/init/openvswitch-force-reload-kmod.conf
+        fi
         ;;
 
     abort-upgrade|abort-remove|abort-deconfigure)
diff --git a/debian/ovn-central.init b/debian/ovn-central.init
index 0c5b09e6a..60cee95a3 100755
--- a/debian/ovn-central.init
+++ b/debian/ovn-central.init
@@ -16,6 +16,7 @@ test -x /usr/bin/ovn-northd  || exit 0
 test -x /usr/share/openvswitch/scripts/ovn-ctl || exit 0
 
 _SYSTEMCTL_SKIP_REDIRECT=yes
+SYSTEMCTL_SKIP_REDIRECT=yes
 
 . /usr/share/openvswitch/scripts/ovs-lib
 if [ -e /etc/default/ovn-central ]; then
diff --git a/debian/ovn-controller-vtep.init b/debian/ovn-controller-vtep.init
index acba3297d..be0a24358 100755
--- a/debian/ovn-controller-vtep.init
+++ b/debian/ovn-controller-vtep.init
@@ -16,6 +16,7 @@ test -x /usr/bin/ovn-controller-vtep  || exit 0
 test -x /usr/share/openvswitch/scripts/ovn-ctl || exit 0
 
 _SYSTEMCTL_SKIP_REDIRECT=yes
+SYSTEMCTL_SKIP_REDIRECT=yes
 
 . /usr/share/openvswitch/scripts/ovs-lib
 if [ -e /etc/default/ovn-controller-vtep ]; then
diff --git a/debian/ovn-host.init b/debian/ovn-host.init
index bddf62815..39c3bcf16 100755
--- a/debian/ovn-host.init
+++ b/debian/ovn-host.init
@@ -16,6 +16,7 @@ test -x /usr/bin/ovn-controller  || exit 0
 test -x /usr/share/openvswitch/scripts/ovn-ctl || exit 0
 
 _SYSTEMCTL_SKIP_REDIRECT=yes
+SYSTEMCTL_SKIP_REDIRECT=yes
 
 . /usr/share/openvswitch/scripts/ovs-lib
 if [ -e /etc/default/ovn-host ]; then
diff --git a/debian/rules b/debian/rules
index 4c34b07f8..12fb94a3f 100755
--- a/debian/rules
+++ b/debian/rules
@@ -48,7 +48,7 @@ override_dh_auto_clean:
 	rm -f python/ovs/*.pyc python/ovs/db/*.pyc
 	dh_auto_clean
 
-override_dh_install:
+override_dh_install-arch:
 	dh_install
 	# openvswitch-switch
 	cp debian/openvswitch-switch.template debian/openvswitch-switch/usr/share/openvswitch/switch/default.template
@@ -59,6 +59,9 @@ override_dh_install:
 	# ovn-central
 	cp debian/ovn-central.template debian/ovn-central/usr/share/ovn/central/default.template
 
+override_dh_install-indep:
+	dh_install
+
 	# openvswitch-datapath-source
 	cp debian/rules.modules debian/openvswitch-datapath-source/usr/src/modules/openvswitch-datapath/debian/rules
 	chmod 755 debian/openvswitch-datapath-source/usr/src/modules/openvswitch-datapath/debian/rules
diff --git a/include/openflow/openflow-1.4.h b/include/openflow/openflow-1.4.h
index 4599f9566..fcebe4eb3 100644
--- a/include/openflow/openflow-1.4.h
+++ b/include/openflow/openflow-1.4.h
@@ -39,6 +39,12 @@
 
 #include <openflow/openflow-1.3.h>
 
+/* OpenFlow 1.4.1+ specific capabilities
+ * (struct ofp_switch_features, member capabilities). */
+enum ofp14_capabilities {
+    OFPC14_BUNDLES        = 1 << 9,    /* Switch supports bundles. */
+    OFPC14_FLOW_MONITORING = 1 << 10,  /* Switch supports flow monitoring. */
+};
 
 /* ## ---------- ## */
 /* ## ofp14_port ## */
diff --git a/include/openvswitch/ofp-util.h b/include/openvswitch/ofp-util.h
index 177bf2be8..dd4d560dc 100644
--- a/include/openvswitch/ofp-util.h
+++ b/include/openvswitch/ofp-util.h
@@ -609,7 +609,7 @@ struct ofputil_phy_port {
 };
 
 enum ofputil_capabilities {
-    /* OpenFlow 1.0, 1.1, 1.2, and 1.3 share these capability values. */
+    /* All OpenFlow versions share these capability values. */
     OFPUTIL_C_FLOW_STATS     = 1 << 0,  /* Flow statistics. */
     OFPUTIL_C_TABLE_STATS    = 1 << 1,  /* Table statistics. */
     OFPUTIL_C_PORT_STATS     = 1 << 2,  /* Port statistics. */
@@ -622,11 +622,16 @@ enum ofputil_capabilities {
     /* OpenFlow 1.0 only. */
     OFPUTIL_C_STP            = 1 << 3,  /* 802.1d spanning tree. */
 
-    /* OpenFlow 1.1, 1.2, and 1.3 share this capability. */
+    /* OpenFlow 1.1+ only.  Note that this bit value does not match the one
+     * in the OpenFlow message. */
     OFPUTIL_C_GROUP_STATS    = 1 << 4,  /* Group statistics. */
 
-    /* OpenFlow 1.2 and 1.3 share this capability */
+    /* OpenFlow 1.2+ only. */
     OFPUTIL_C_PORT_BLOCKED   = 1 << 8,  /* Switch will block looping ports */
+
+    /* OpenFlow 1.4+ only. */
+    OFPUTIL_C_BUNDLES         = 1 << 9,  /* Switch supports bundles. */
+    OFPUTIL_C_FLOW_MONITORING = 1 << 10, /* Switch supports flow monitoring. */
 };
 
 /* Abstract ofp_switch_features. */
diff --git a/include/openvswitch/vconn.h b/include/openvswitch/vconn.h
index d2fbd16ba..a89547b21 100644
--- a/include/openvswitch/vconn.h
+++ b/include/openvswitch/vconn.h
@@ -56,18 +56,6 @@ int vconn_transact_noreply(struct vconn *, struct ofpbuf *, struct ofpbuf **);
 int vconn_transact_multiple_noreply(struct vconn *, struct ovs_list *requests,
                                     struct ofpbuf **replyp);
 
-/* Bundle errors must be free()d by the caller. */
-struct vconn_bundle_error {
-    struct ovs_list list_node;
-
-    /* OpenFlow header and some of the message contents for error reporting. */
-    union {
-        struct ofp_header ofp_msg;
-        uint8_t ofp_msg_data[64];
-    };
-};
-
-/* Bundle errors must be free()d by the caller. */
 int vconn_bundle_transact(struct vconn *, struct ovs_list *requests,
                           uint16_t bundle_flags,
                           struct ovs_list *errors);
diff --git a/lib/bundle.c b/lib/bundle.c
index 7fc02e204..70a743b17 100644
--- a/lib/bundle.c
+++ b/lib/bundle.c
@@ -123,7 +123,7 @@ bundle_check(const struct ofpact_bundle *bundle, ofp_port_t max_ports,
         if (ofp_port != OFPP_NONE) {
             enum ofperr error = ofpact_check_output_port(ofp_port, max_ports);
             if (error) {
-                VLOG_WARN_RL(&rl, "invalid slave %"PRIu16, ofp_port);
+                VLOG_WARN_RL(&rl, "invalid slave %"PRIu32, ofp_port);
                 return error;
             }
         }
diff --git a/lib/conntrack.c b/lib/conntrack.c
index 7c50a289c..677c0d2a3 100644
--- a/lib/conntrack.c
+++ b/lib/conntrack.c
@@ -247,7 +247,11 @@ process_one(struct conntrack *ct, struct dp_packet *pkt,
             }
         }
     } else {
-        conn = conn_not_found(ct, pkt, ctx, &state, commit, now);
+        if (ctx->related) {
+            state |= CS_INVALID;
+        } else {
+            conn = conn_not_found(ct, pkt, ctx, &state, commit, now);
+        }
     }
 
     write_ct_md(pkt, state, zone, conn ? conn->mark : 0,
@@ -564,15 +568,15 @@ extract_l3_ipv6(struct conn_key *key, const void *data, size_t size,
                 const char **new_data)
 {
     const struct ovs_16aligned_ip6_hdr *ip6 = data;
-    uint8_t nw_proto = ip6->ip6_nxt;
-    uint8_t nw_frag = 0;
-
     if (new_data) {
         if (OVS_UNLIKELY(size < sizeof *ip6)) {
             return false;
         }
     }
 
+    uint8_t nw_proto = ip6->ip6_nxt;
+    uint8_t nw_frag = 0;
+
     data = ip6 + 1;
     size -=  sizeof *ip6;
 
@@ -619,8 +623,11 @@ check_l4_tcp(const struct conn_key *key, const void *data, size_t size,
              const void *l3)
 {
     const struct tcp_header *tcp = data;
-    size_t tcp_len = TCP_OFFSET(tcp->tcp_ctl) * 4;
+    if (size < sizeof *tcp) {
+        return false;
+    }
 
+    size_t tcp_len = TCP_OFFSET(tcp->tcp_ctl) * 4;
     if (OVS_UNLIKELY(tcp_len < TCP_HEADER_LEN || tcp_len > size)) {
         return false;
     }
@@ -633,8 +640,11 @@ check_l4_udp(const struct conn_key *key, const void *data, size_t size,
              const void *l3)
 {
     const struct udp_header *udp = data;
-    size_t udp_len = ntohs(udp->udp_len);
+    if (size < sizeof *udp) {
+        return false;
+    }
 
+    size_t udp_len = ntohs(udp->udp_len);
     if (OVS_UNLIKELY(udp_len < UDP_HEADER_LEN || udp_len > size)) {
         return false;
     }
diff --git a/lib/csum.c b/lib/csum.c
index a0e996716..5951576c0 100644
--- a/lib/csum.c
+++ b/lib/csum.c
@@ -44,7 +44,11 @@ csum_continue(uint32_t partial, const void *data_, size_t n)
         partial = csum_add16(partial, get_unaligned_be16(data));
     }
     if (n) {
+#ifdef WORDS_BIGENDIAN
+        partial += (*(uint8_t *) data) << 8;
+#else
         partial += *(uint8_t *) data;
+#endif
     }
     return partial;
 }
diff --git a/lib/ct-dpif.c b/lib/ct-dpif.c
index 2cdecf668..8f0b4ed63 100644
--- a/lib/ct-dpif.c
+++ b/lib/ct-dpif.c
@@ -202,6 +202,9 @@ ct_dpif_format_ipproto(struct ds *ds, uint16_t ipproto)
         : (ipproto == IPPROTO_TCP) ? "tcp"
         : (ipproto == IPPROTO_UDP) ? "udp"
         : (ipproto == IPPROTO_SCTP) ? "sctp"
+        : (ipproto == IPPROTO_UDPLITE) ? "udplite"
+        : (ipproto == IPPROTO_DCCP) ? "dccp"
+        : (ipproto == IPPROTO_IGMP) ? "igmp"
         : NULL;
 
     if (name) {
diff --git a/lib/daemon-unix.c b/lib/daemon-unix.c
index 28f76da44..2f5113689 100644
--- a/lib/daemon-unix.c
+++ b/lib/daemon-unix.c
@@ -361,11 +361,14 @@ monitor_daemon(pid_t daemon_pid)
                                (unsigned long int) daemon_pid, status_msg);
 
         if (child_ready) {
+            int error;
             do {
                 retval = waitpid(daemon_pid, &status, 0);
-            } while (retval == -1 && errno == EINTR);
-            if (retval == -1) {
-                VLOG_FATAL("waitpid failed (%s)", ovs_strerror(errno));
+                error = retval == -1 ? errno : 0;
+            } while (error == EINTR);
+            vlog_reopen_log_file();
+            if (error) {
+                VLOG_FATAL("waitpid failed (%s)", ovs_strerror(error));
             }
         }
 
diff --git a/lib/db-ctl-base.c b/lib/db-ctl-base.c
index 02eb328e2..9a13d36ec 100644
--- a/lib/db-ctl-base.c
+++ b/lib/db-ctl-base.c
@@ -301,6 +301,8 @@ get_row_by_id(struct ctl_context *ctx, const struct ctl_table_class *table,
         if (uuid->n == 1) {
             final = ovsdb_idl_get_row_for_uuid(ctx->idl, table->class,
                                                &uuid->keys[0].uuid);
+        } else {
+            final = NULL;
         }
     } else {
         final = referrer;
diff --git a/lib/dpif-netdev.c b/lib/dpif-netdev.c
index 44ec1a095..20e4fc5fd 100644
--- a/lib/dpif-netdev.c
+++ b/lib/dpif-netdev.c
@@ -669,7 +669,7 @@ pmd_info_show_stats(struct ds *reply,
                     unsigned long long stats[DP_N_STATS],
                     uint64_t cycles[PMD_N_CYCLES])
 {
-    unsigned long long total_packets = 0;
+    unsigned long long total_packets;
     uint64_t total_cycles = 0;
     int i;
 
@@ -685,13 +685,12 @@ pmd_info_show_stats(struct ds *reply,
         } else {
             stats[i] = 0;
         }
-
-        if (i != DP_STAT_LOST) {
-            /* Lost packets are already included in DP_STAT_MISS */
-            total_packets += stats[i];
-        }
     }
 
+    /* Sum of all the matched and not matched packets gives the total.  */
+    total_packets = stats[DP_STAT_EXACT_HIT] + stats[DP_STAT_MASKED_HIT]
+                    + stats[DP_STAT_MISS];
+
     for (i = 0; i < PMD_N_CYCLES; i++) {
         if (cycles[i] > pmd->cycles_zero[i]) {
            cycles[i] -= pmd->cycles_zero[i];
@@ -1495,18 +1494,30 @@ get_n_pmd_threads_on_numa(struct dp_netdev *dp, int numa_id)
     return n_pmds;
 }
 
-/* Returns 'true' if there is a port with pmd netdev and the netdev
- * is on numa node 'numa_id'. */
+/* Returns 'true' if there is a port with pmd netdev and the netdev is on
+ * numa node 'numa_id' or its rx queue assigned to core on that numa node . */
 static bool
-has_pmd_port_for_numa(struct dp_netdev *dp, int numa_id)
+has_pmd_rxq_for_numa(struct dp_netdev *dp, int numa_id)
     OVS_REQUIRES(dp->port_mutex)
 {
     struct dp_netdev_port *port;
 
     HMAP_FOR_EACH (port, node, &dp->ports) {
-        if (netdev_is_pmd(port->netdev)
-            && netdev_get_numa_id(port->netdev) == numa_id) {
-            return true;
+        if (netdev_is_pmd(port->netdev)) {
+            int i;
+
+            if (netdev_get_numa_id(port->netdev) == numa_id) {
+                return true;
+            }
+
+            for (i = 0; i < port->n_rxq; i++) {
+                unsigned core_id = port->rxqs[i].core_id;
+
+                if (core_id != -1
+                    && ovs_numa_get_numa_id(core_id) == numa_id) {
+                    return true;
+                }
+            }
         }
     }
 
@@ -1530,7 +1541,7 @@ do_del_port(struct dp_netdev *dp, struct dp_netdev_port *port)
         ovs_assert(ovs_numa_numa_id_is_valid(numa_id));
         /* If there is no netdev on the numa node, deletes the pmd threads
          * for that numa. */
-        if (!has_pmd_port_for_numa(dp, numa_id)) {
+        if (!has_pmd_rxq_for_numa(dp, numa_id)) {
             dp_netdev_del_pmds_on_numa(dp, numa_id);
         }
     }
@@ -3398,7 +3409,7 @@ dp_netdev_del_pmds_on_numa(struct dp_netdev *dp, int numa_id)
         /* We cannot call dp_netdev_del_pmd(), since it alters
          * 'dp->poll_threads' (while we're iterating it) and it
          * might quiesce. */
-        if (pmd->numa_id == numa_id) {
+        if (pmd->numa_id == numa_id && pmd->core_id != NON_PMD_CORE_ID) {
             atomic_read_relaxed(&pmd->static_tx_qid, &free_idx[k]);
             pmd_list[k] = pmd;
             ovs_assert(k < n_pmds_on_numa);
@@ -3416,7 +3427,7 @@ dp_netdev_del_pmds_on_numa(struct dp_netdev *dp, int numa_id)
 
         atomic_read_relaxed(&pmd->static_tx_qid, &old_tx_qid);
 
-        if (old_tx_qid >= n_pmds) {
+        if (old_tx_qid >= n_pmds && pmd->core_id != NON_PMD_CORE_ID) {
             int new_tx_qid = free_idx[--k];
 
             atomic_store_relaxed(&pmd->static_tx_qid, new_tx_qid);
@@ -3736,9 +3747,27 @@ dp_netdev_reset_pmd_threads(struct dp_netdev *dp)
 
     HMAP_FOR_EACH (port, node, &dp->ports) {
         if (netdev_is_pmd(port->netdev)) {
-            int numa_id = netdev_get_numa_id(port->netdev);
+            struct hmapx numas = HMAPX_INITIALIZER(&numas);
+            struct hmapx_node *numa_node;
+            uintptr_t numa_id;
+            int i;
+
+            numa_id = netdev_get_numa_id(port->netdev);
+            hmapx_add(&numas, (void *) numa_id);
+            for (i = 0; i < port->n_rxq; i++) {
+                unsigned core_id = port->rxqs[i].core_id;
+
+                if (core_id != -1) {
+                    numa_id = ovs_numa_get_numa_id(core_id);
+                    hmapx_add(&numas, (void *) numa_id);
+                }
+            }
+
+            HMAPX_FOR_EACH (numa_node, &numas) {
+                dp_netdev_set_pmds_on_numa(dp, (uintptr_t) numa_node->data);
+            }
 
-            dp_netdev_set_pmds_on_numa(dp, numa_id);
+            hmapx_destroy(&numas);
         }
         /* Distribute only pinned rx queues first to mark threads as isolated */
         dp_netdev_add_port_rx_to_pmds(dp, port, &to_reload, true);
@@ -3818,7 +3847,7 @@ dp_netdev_upcall(struct dp_netdev_pmd_thread *pmd, struct dp_packet *packet_,
         struct ofpbuf key;
         struct odp_flow_key_parms odp_parms = {
             .flow = flow,
-            .mask = &wc->masks,
+            .mask = wc ? &wc->masks : NULL,
             .support = dp_netdev_support,
         };
 
@@ -4171,7 +4200,6 @@ fast_path_processing(struct dp_netdev_pmd_thread *pmd,
         ofpbuf_uninit(&actions);
         ofpbuf_uninit(&put_actions);
         fat_rwlock_unlock(&dp->upcall_rwlock);
-        dp_netdev_count_packet(pmd, DP_STAT_LOST, lost_cnt);
     } else if (OVS_UNLIKELY(any_miss)) {
         for (i = 0; i < cnt; i++) {
             if (OVS_UNLIKELY(!rules[i])) {
diff --git a/lib/dpif-netlink.c b/lib/dpif-netlink.c
index a39faa230..e91e6a440 100644
--- a/lib/dpif-netlink.c
+++ b/lib/dpif-netlink.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Nicira, Inc.
+ * Copyright (c) 2008-2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1788,10 +1788,9 @@ dpif_netlink_refresh_channels(struct dpif_netlink *dpif, uint32_t n_handlers)
             error = dpif_netlink_handler_init(handler);
             if (error) {
                 size_t j;
-                struct dpif_handler *tmp = &dpif->handlers[i];
-
 
                 for (j = 0; j < i; j++) {
+                    struct dpif_handler *tmp = &dpif->handlers[j];
                     dpif_netlink_handler_uninit(tmp);
                 }
                 free(dpif->handlers);
diff --git a/lib/dpif.c b/lib/dpif.c
index 53958c559..7bc5baa65 100644
--- a/lib/dpif.c
+++ b/lib/dpif.c
@@ -1722,9 +1722,13 @@ log_execute_message(struct dpif *dpif, const struct dpif_execute *execute,
         && !execute->probe) {
         struct ds ds = DS_EMPTY_INITIALIZER;
         char *packet;
+        uint64_t stub[1024 / 8];
+        struct ofpbuf md = OFPBUF_STUB_INITIALIZER(stub);
 
         packet = ofp_packet_to_string(dp_packet_data(execute->packet),
                                       dp_packet_size(execute->packet));
+        odp_key_from_pkt_metadata(&md, &execute->packet->md);
+
         ds_put_format(&ds, "%s: %sexecute ",
                       dpif_name(dpif),
                       (subexecute ? "sub-"
@@ -1735,10 +1739,13 @@ log_execute_message(struct dpif *dpif, const struct dpif_execute *execute,
             ds_put_format(&ds, " failed (%s)", ovs_strerror(error));
         }
         ds_put_format(&ds, " on packet %s", packet);
+        ds_put_format(&ds, " with metadata ");
+        odp_flow_format(md.data, md.size, NULL, 0, NULL, &ds, true);
         ds_put_format(&ds, " mtu %d", execute->mtu);
         vlog(&this_module, error ? VLL_WARN : VLL_DBG, "%s", ds_cstr(&ds));
         ds_destroy(&ds);
         free(packet);
+        ofpbuf_uninit(&md);
     }
 }
 
diff --git a/lib/flow.c b/lib/flow.c
index ba4f8c774..fdffaa080 100644
--- a/lib/flow.c
+++ b/lib/flow.c
@@ -1769,7 +1769,7 @@ flow_hash_symmetric_l3l4(const struct flow *flow, uint32_t basis,
         const uint64_t *a = ALIGNED_CAST(uint64_t *, flow->ipv6_src.s6_addr);
         const uint64_t *b = ALIGNED_CAST(uint64_t *, flow->ipv6_dst.s6_addr);
 
-        for (int i = 0; i < 4; i++) {
+        for (int i = 0; i < sizeof flow->ipv6_src / sizeof *a; i++) {
             hash = hash_add64(hash, a[i] ^ b[i]);
         }
     } else {
@@ -2095,7 +2095,7 @@ flow_count_common_mpls_labels(const struct flow *a, int an,
  */
 void
 flow_push_mpls(struct flow *flow, int n, ovs_be16 mpls_eth_type,
-               struct flow_wildcards *wc)
+               struct flow_wildcards *wc, bool clear_flow_L3)
 {
     ovs_assert(eth_type_mpls(mpls_eth_type));
     ovs_assert(n < FLOW_MAX_MPLS_LABELS);
@@ -2133,11 +2133,13 @@ flow_push_mpls(struct flow *flow, int n, ovs_be16 mpls_eth_type,
 
         flow->mpls_lse[0] = set_mpls_lse_values(ttl, tc, 1, htonl(label));
 
-        /* Clear all L3 and L4 fields and dp_hash. */
-        BUILD_ASSERT(FLOW_WC_SEQ == 36);
-        memset((char *) flow + FLOW_SEGMENT_2_ENDS_AT, 0,
-               sizeof(struct flow) - FLOW_SEGMENT_2_ENDS_AT);
-        flow->dp_hash = 0;
+        if (clear_flow_L3) {
+            /* Clear all L3 and L4 fields and dp_hash. */
+            BUILD_ASSERT(FLOW_WC_SEQ == 36);
+            memset((char *) flow + FLOW_SEGMENT_2_ENDS_AT, 0,
+                   sizeof(struct flow) - FLOW_SEGMENT_2_ENDS_AT);
+            flow->dp_hash = 0;
+        }
     }
     flow->dl_type = mpls_eth_type;
 }
diff --git a/lib/flow.h b/lib/flow.h
index ea24e28db..d2b9acdbd 100644
--- a/lib/flow.h
+++ b/lib/flow.h
@@ -95,7 +95,7 @@ int flow_count_common_mpls_labels(const struct flow *a, int an,
                                   const struct flow *b, int bn,
                                   struct flow_wildcards *wc);
 void flow_push_mpls(struct flow *, int n, ovs_be16 mpls_eth_type,
-                    struct flow_wildcards *);
+                    struct flow_wildcards *, bool clear_flow_L3);
 bool flow_pop_mpls(struct flow *, int n, ovs_be16 eth_type,
                    struct flow_wildcards *);
 void flow_set_mpls_label(struct flow *, int idx, ovs_be32 label);
diff --git a/lib/lacp.c b/lib/lacp.c
index ad6ef8efb..4d6248a02 100644
--- a/lib/lacp.c
+++ b/lib/lacp.c
@@ -536,6 +536,7 @@ lacp_run(struct lacp *lacp, lacp_send_pdu *send_pdu) OVS_EXCLUDED(mutex)
 
     if (lacp->update) {
         lacp_update_attached(lacp);
+        seq_change(connectivity_seq_get());
     }
 
     HMAP_FOR_EACH (slave, node, &lacp->slaves) {
@@ -596,11 +597,13 @@ lacp_update_attached(struct lacp *lacp) OVS_REQUIRES(mutex)
 {
     struct slave *lead, *slave;
     struct lacp_info lead_pri;
+    bool lead_enable;
     static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 10);
 
     lacp->update = false;
 
     lead = NULL;
+    lead_enable = false;
     HMAP_FOR_EACH (slave, node, &lacp->slaves) {
         struct lacp_info pri;
 
@@ -623,9 +626,14 @@ lacp_update_attached(struct lacp *lacp) OVS_REQUIRES(mutex)
 
         slave->attached = true;
         slave_get_priority(slave, &pri);
+        bool enable = slave_may_enable__(slave);
 
-        if (!lead || memcmp(&pri, &lead_pri, sizeof pri) < 0) {
+        if (!lead
+            || enable > lead_enable
+            || (enable == lead_enable
+                && memcmp(&pri, &lead_pri, sizeof pri) < 0)) {
             lead = slave;
+            lead_enable = enable;
             lead_pri = pri;
         }
     }
diff --git a/lib/learning-switch.c b/lib/learning-switch.c
index 82609e80c..f31144c3d 100644
--- a/lib/learning-switch.c
+++ b/lib/learning-switch.c
@@ -451,7 +451,7 @@ lswitch_choose_destination(struct lswitch *sw, const struct flow *flow)
             if (get_mac_entry_ofp_port(sw->ml, mac)
                 != flow->in_port.ofp_port) {
                 VLOG_DBG_RL(&rl, "%016llx: learned that "ETH_ADDR_FMT" is on "
-                            "port %"PRIu16, sw->datapath_id,
+                            "port %"PRIu32, sw->datapath_id,
                             ETH_ADDR_ARGS(flow->dl_src),
                             flow->in_port.ofp_port);
 
diff --git a/lib/mcast-snooping.c b/lib/mcast-snooping.c
index f71321d2e..a3163f57f 100644
--- a/lib/mcast-snooping.c
+++ b/lib/mcast-snooping.c
@@ -942,3 +942,34 @@ mcast_snooping_wait(struct mcast_snooping *ms)
     mcast_snooping_wait__(ms);
     ovs_rwlock_unlock(&ms->rwlock);
 }
+
+void
+mcast_snooping_flush_bundle(struct mcast_snooping *ms, void *port)
+{
+    struct mcast_group *g, *next_g;
+    struct mcast_mrouter_bundle *m, *next_m;
+
+    if (!mcast_snooping_enabled(ms)) {
+        return;
+    }
+
+    ovs_rwlock_wrlock(&ms->rwlock);
+    LIST_FOR_EACH_SAFE (g, next_g, group_node, &ms->group_lru) {
+        if (mcast_group_delete_bundle(ms, g, port)) {
+            ms->need_revalidate = true;
+
+            if (!mcast_group_has_bundles(g)) {
+                mcast_snooping_flush_group__(ms, g);
+            }
+        }
+    }
+
+    LIST_FOR_EACH_SAFE (m, next_m, mrouter_node, &ms->mrouter_lru) {
+        if (m->port == port) {
+            mcast_snooping_flush_mrouter(m);
+            ms->need_revalidate = true;
+        }
+    }
+
+    ovs_rwlock_unlock(&ms->rwlock);
+}
diff --git a/lib/mcast-snooping.h b/lib/mcast-snooping.h
index af7fb9376..f120405da 100644
--- a/lib/mcast-snooping.h
+++ b/lib/mcast-snooping.h
@@ -214,5 +214,6 @@ bool mcast_snooping_is_membership(ovs_be16 igmp_type);
 /* Flush. */
 void mcast_snooping_mdb_flush(struct mcast_snooping *ms);
 void mcast_snooping_flush(struct mcast_snooping *ms);
+void mcast_snooping_flush_bundle(struct mcast_snooping *ms, void *port);
 
 #endif /* mcast-snooping.h */
diff --git a/lib/netdev-bsd.c b/lib/netdev-bsd.c
index 75a330b3d..94c515d5a 100644
--- a/lib/netdev-bsd.c
+++ b/lib/netdev-bsd.c
@@ -1357,7 +1357,11 @@ netdev_bsd_arp_lookup(const struct netdev *netdev OVS_UNUSED,
     mib[2] = 0;
     mib[3] = AF_INET;
     mib[4] = NET_RT_FLAGS;
+#ifdef RTF_LLINFO
     mib[5] = RTF_LLINFO;
+#else
+    mib[5] = 0;
+#endif
     if (sysctl(mib, 6, NULL, &needed, NULL, 0) == -1) {
         error = errno;
         goto error;
diff --git a/lib/netdev-dpdk.c b/lib/netdev-dpdk.c
index 27b4ee24c..8adc723ac 100644
--- a/lib/netdev-dpdk.c
+++ b/lib/netdev-dpdk.c
@@ -553,10 +553,11 @@ netdev_dpdk_mempool_configure(struct netdev_dpdk *dev)
 
     mp = dpdk_mp_get(dev->requested_socket_id, FRAME_LEN_TO_MTU(buf_size));
     if (!mp) {
-        VLOG_ERR("Insufficient memory to create memory pool for netdev "
-                 "%s, with MTU %d on socket %d\n",
-                 dev->up.name, dev->requested_mtu, dev->requested_socket_id);
-        return ENOMEM;
+        VLOG_ERR("Failed to create memory pool for netdev "
+                 "%s, with MTU %d on socket %d: %s\n",
+                 dev->up.name, dev->requested_mtu, dev->requested_socket_id,
+                 rte_strerror(rte_errno));
+        return rte_errno;
     } else {
         dpdk_mp_put(dev->dpdk_mp);
         dev->dpdk_mp = mp;
@@ -1023,6 +1024,10 @@ netdev_dpdk_vhost_destruct(struct netdev *netdev)
     ovs_mutex_unlock(&dev->mutex);
     ovs_mutex_unlock(&dpdk_mutex);
 
+    if (!vhost_id[0]) {
+        goto out;
+    }
+
     if (dpdk_vhost_driver_unregister(dev, vhost_id)) {
         VLOG_ERR("%s: Unable to unregister vhost driver for socket '%s'.\n",
                  netdev->name, vhost_id);
@@ -1030,6 +1035,7 @@ netdev_dpdk_vhost_destruct(struct netdev *netdev)
         /* OVS server mode - remove this socket from list for deletion */
         fatal_signal_remove_file_to_unlink(vhost_id);
     }
+out:
     free(vhost_id);
 }
 
@@ -1063,7 +1069,7 @@ dpdk_set_rxq_config(struct netdev_dpdk *dev, const struct smap *args)
 {
     int new_n_rxq;
 
-    new_n_rxq = MAX(smap_get_int(args, "n_rxq", dev->requested_n_rxq), 1);
+    new_n_rxq = MAX(smap_get_int(args, "n_rxq", NR_QUEUE), 1);
     if (new_n_rxq != dev->requested_n_rxq) {
         dev->requested_n_rxq = new_n_rxq;
         netdev_request_reconfigure(&dev->up);
@@ -1794,10 +1800,10 @@ netdev_dpdk_vhost_get_stats(const struct netdev *netdev,
 
     rte_spinlock_lock(&dev->stats_lock);
     /* Supported Stats */
-    stats->rx_packets += dev->stats.rx_packets;
-    stats->tx_packets += dev->stats.tx_packets;
+    stats->rx_packets = dev->stats.rx_packets;
+    stats->tx_packets = dev->stats.tx_packets;
     stats->rx_dropped = dev->stats.rx_dropped;
-    stats->tx_dropped += dev->stats.tx_dropped;
+    stats->tx_dropped = dev->stats.tx_dropped;
     stats->multicast = dev->stats.multicast;
     stats->rx_bytes = dev->stats.rx_bytes;
     stats->tx_bytes = dev->stats.tx_bytes;
@@ -1927,8 +1933,7 @@ out:
     stats->tx_packets = rte_stats.opackets;
     stats->rx_bytes = rte_stats.ibytes;
     stats->tx_bytes = rte_stats.obytes;
-    /* DPDK counts imissed as errors, but count them here as dropped instead */
-    stats->rx_errors = rte_stats.ierrors - rte_stats.imissed;
+    stats->rx_errors = rte_stats.ierrors;
     stats->tx_errors = rte_stats.oerrors;
 
     rte_spinlock_lock(&dev->stats_lock);
@@ -1949,9 +1954,9 @@ out:
 static int
 netdev_dpdk_get_features(const struct netdev *netdev,
                          enum netdev_features *current,
-                         enum netdev_features *advertised OVS_UNUSED,
-                         enum netdev_features *supported OVS_UNUSED,
-                         enum netdev_features *peer OVS_UNUSED)
+                         enum netdev_features *advertised,
+                         enum netdev_features *supported,
+                         enum netdev_features *peer)
 {
     struct netdev_dpdk *dev = netdev_dpdk_cast(netdev);
     struct rte_eth_link link;
@@ -1989,6 +1994,8 @@ netdev_dpdk_get_features(const struct netdev *netdev,
         *current |= NETDEV_F_AUTONEG;
     }
 
+    *advertised = *supported = *peer = 0;
+
     return 0;
 }
 
@@ -2004,8 +2011,8 @@ netdev_dpdk_policer_construct(uint32_t rate, uint32_t burst)
     rte_spinlock_init(&policer->policer_lock);
 
     /* rte_meter requires bytes so convert kbits rate and burst to bytes. */
-    rate_bytes = rate * 1000/8;
-    burst_bytes = burst * 1000/8;
+    rate_bytes = rate * 1000ULL / 8;
+    burst_bytes = burst * 1000ULL / 8;
 
     policer->app_srtcm_params.cir = rate_bytes;
     policer->app_srtcm_params.cbs = burst_bytes;
@@ -2164,6 +2171,8 @@ netdev_dpdk_update_flags__(struct netdev_dpdk *dev,
         if (!(dev->flags & NETDEV_UP)) {
             rte_eth_dev_stop(dev->port_id);
         }
+
+        netdev_change_seq_changed(&dev->up);
     } else {
         /* If DPDK_DEV_VHOST device's NETDEV_UP flag was changed and vhost is
          * running then change netdev's change_seq to trigger link state
@@ -3012,7 +3021,11 @@ dpdk_vhost_reconfigure_helper(struct netdev_dpdk *dev)
     }
 
     if (netdev_dpdk_get_vid(dev) >= 0) {
-        dev->vhost_reconfigured = true;
+        if (dev->vhost_reconfigured == false) {
+            dev->vhost_reconfigured = true;
+            /* Carrier status may need updating. */
+            netdev_change_seq_changed(&dev->up);
+        }
     }
 }
 
@@ -3356,7 +3369,7 @@ get_dpdk_args(const struct smap *ovs_other_config, char ***argv,
     return i + extra_argc;
 }
 
-static char **dpdk_argv;
+static char **dpdk_argv, **dpdk_argv_release;
 static int dpdk_argc;
 
 static void
@@ -3364,9 +3377,10 @@ deferred_argv_release(void)
 {
     int result;
     for (result = 0; result < dpdk_argc; ++result) {
-        free(dpdk_argv[result]);
+        free(dpdk_argv_release[result]);
     }
 
+    free(dpdk_argv_release);
     free(dpdk_argv);
 }
 
@@ -3472,6 +3486,11 @@ dpdk_init__(const struct smap *ovs_other_config)
         ds_destroy(&eal_args);
     }
 
+    dpdk_argv_release = grow_argv(&dpdk_argv_release, 0, argc);
+    for (argc_tmp = 0; argc_tmp < argc; ++argc_tmp) {
+        dpdk_argv_release[argc_tmp] = argv[argc_tmp];
+    }
+
     /* Make sure things are initialized ... */
     result = rte_eal_init(argc, argv);
     if (result < 0) {
diff --git a/lib/netdev-dummy.c b/lib/netdev-dummy.c
index dec1a8e0c..de74846c3 100644
--- a/lib/netdev-dummy.c
+++ b/lib/netdev-dummy.c
@@ -868,8 +868,8 @@ netdev_dummy_set_config(struct netdev *netdev_, const struct smap *args)
         goto exit;
     }
 
-    new_n_rxq = MAX(smap_get_int(args, "n_rxq", netdev->requested_n_rxq), 1);
-    new_n_txq = MAX(smap_get_int(args, "n_txq", netdev->requested_n_txq), 1);
+    new_n_rxq = MAX(smap_get_int(args, "n_rxq", 1), 1);
+    new_n_txq = MAX(smap_get_int(args, "n_txq", 1), 1);
     new_numa_id = smap_get_int(args, "numa_id", 0);
     if (new_n_rxq != netdev->requested_n_rxq
         || new_n_txq != netdev->requested_n_txq
diff --git a/lib/netdev-linux.c b/lib/netdev-linux.c
index a5a9ec1ab..260872d4b 100644
--- a/lib/netdev-linux.c
+++ b/lib/netdev-linux.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Nicira, Inc.
+ * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -773,10 +773,28 @@ netdev_linux_alloc(void)
     return &netdev->up;
 }
 
-static void
-netdev_linux_common_construct(struct netdev_linux *netdev)
-{
+static int
+netdev_linux_common_construct(struct netdev *netdev_)
+{
+    /* Prevent any attempt to create (or open) a network device named "default"
+     * or "all".  These device names are effectively reserved on Linux because
+     * /proc/sys/net/ipv4/conf/ always contains directories by these names.  By
+     * itself this wouldn't call for any special treatment, but in practice if
+     * a program tries to create devices with these names, it causes the kernel
+     * to fire a "new device" notification event even though creation failed,
+     * and in turn that causes OVS to wake up and try to create them again,
+     * which ends up as a 100% CPU loop. */
+    struct netdev_linux *netdev = netdev_linux_cast(netdev_);
+    const char *name = netdev_->name;
+    if (!strcmp(name, "default") || !strcmp(name, "all")) {
+        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);
+        VLOG_WARN_RL(&rl, "%s: Linux forbids network device with this name",
+                     name);
+        return EINVAL;
+    }
+
     ovs_mutex_init(&netdev->mutex);
+    return 0;
 }
 
 /* Creates system and internal devices. */
@@ -784,9 +802,10 @@ static int
 netdev_linux_construct(struct netdev *netdev_)
 {
     struct netdev_linux *netdev = netdev_linux_cast(netdev_);
-    int error;
-
-    netdev_linux_common_construct(netdev);
+    int error = netdev_linux_common_construct(netdev_);
+    if (error) {
+        return error;
+    }
 
     error = get_flags(&netdev->up, &netdev->ifi_flags);
     if (error == ENODEV) {
@@ -817,9 +836,11 @@ netdev_linux_construct_tap(struct netdev *netdev_)
     static const char tap_dev[] = "/dev/net/tun";
     const char *name = netdev_->name;
     struct ifreq ifr;
-    int error;
 
-    netdev_linux_common_construct(netdev);
+    int error = netdev_linux_common_construct(netdev_);
+    if (error) {
+        return error;
+    }
 
     /* Open tap device. */
     netdev->tap_fd = open(tap_dev, O_RDWR);
@@ -3699,6 +3720,7 @@ htb_parse_class_details__(struct netdev *netdev,
 {
     const struct htb *htb = htb_get__(netdev);
     int mtu, error;
+    unsigned long long int max_rate_bit;
 
     error = netdev_linux_get_mtu__(netdev_linux_cast(netdev), &mtu);
     if (error) {
@@ -3714,10 +3736,8 @@ htb_parse_class_details__(struct netdev *netdev,
     hc->min_rate = MIN(hc->min_rate, htb->max_rate);
 
     /* max-rate */
-    hc->max_rate = smap_get_ullong(details, "max-rate", 0) / 8;
-    if (!hc->max_rate) {
-        hc->max_rate = htb->max_rate;
-    }
+    max_rate_bit = smap_get_ullong(details, "max-rate", 0);
+    hc->max_rate = max_rate_bit ? max_rate_bit / 8 : htb->max_rate;
     hc->max_rate = MAX(hc->max_rate, hc->min_rate);
     hc->max_rate = MIN(hc->max_rate, htb->max_rate);
 
diff --git a/lib/netdev-windows.c b/lib/netdev-windows.c
index 32184906d..b3e7e6467 100644
--- a/lib/netdev-windows.c
+++ b/lib/netdev-windows.c
@@ -159,7 +159,10 @@ netdev_windows_system_construct(struct netdev *netdev_)
 
     /* Query the attributes and runtime status of the netdev. */
     ret = query_netdev(netdev_get_name(&netdev->up), &info, &buf);
-    if (ret) {
+    /* "Internal" netdevs do not exist in the kernel yet.  They need to be
+     * transformed into a netdev object and passed to dpif_port_add(), which
+     * will add them to the kernel.  */
+    if (strcmp(netdev_get_type(&netdev->up), "internal") && ret) {
         return ret;
     }
     ofpbuf_delete(buf);
@@ -226,7 +229,7 @@ netdev_windows_netdev_from_ofpbuf(struct netdev_windows_netdev_info *info,
 
     netdev_windows_info_init(info);
 
-    struct ofpbuf b = ofpbuf_const_initializer(&b, buf->data, buf->size);
+    struct ofpbuf b = ofpbuf_const_initializer(buf->data, buf->size);
     struct nlmsghdr *nlmsg = ofpbuf_try_pull(&b, sizeof *nlmsg);
     struct genlmsghdr *genl = ofpbuf_try_pull(&b, sizeof *genl);
     struct ovs_header *ovs_header = ofpbuf_try_pull(&b, sizeof *ovs_header);
@@ -295,7 +298,7 @@ query_netdev(const char *devname,
         }
     }
 
-    return 0;
+    return error;
 }
 
 static void
@@ -391,12 +394,7 @@ netdev_windows_arp_lookup(const struct netdev *netdev,
         return ENXIO;
     }
 
-    arp_table = (MIB_IPNETTABLE *) malloc(buffer_length);
-
-    if (arp_table == NULL) {
-        VLOG_ERR("Could not allocate memory for all the interfaces");
-        return ENXIO;
-    }
+    arp_table = (MIB_IPNETTABLE *) xmalloc(buffer_length);
 
     ret_val = GetIpNetTable(arp_table, &buffer_length, false);
 
@@ -440,12 +438,7 @@ netdev_windows_get_next_hop(const struct in_addr *host,
         return ENXIO;
     }
 
-    all_addr = (IP_ADAPTER_ADDRESSES *) malloc(buffer_length);
-
-    if (all_addr == NULL) {
-        VLOG_ERR("Could not allocate memory for all the interfaces");
-        return ENXIO;
-    }
+    all_addr = (IP_ADAPTER_ADDRESSES *) xmalloc(buffer_length);
 
     ret_val = GetAdaptersAddresses(AF_INET,
                                    GAA_FLAG_INCLUDE_PREFIX |
diff --git a/lib/netdev.c b/lib/netdev.c
index 6c4c6571e..928e20c62 100644
--- a/lib/netdev.c
+++ b/lib/netdev.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Nicira, Inc.
+ * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016, 2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -332,6 +332,14 @@ netdev_open(const char *name, const char *type, struct netdev **netdevp)
     struct netdev *netdev;
     int error;
 
+    if (!name[0]) {
+        /* Reject empty names.  This saves the providers having to do this.  At
+         * least one screwed this up: the netdev-linux "tap" implementation
+         * passed the name directly to the Linux TUNSETIFF call, which treats
+         * an empty string as a request to generate a unique name. */
+        return EINVAL;
+    }
+
     netdev_initialize();
 
     ovs_mutex_lock(&netdev_mutex);
@@ -1882,7 +1890,7 @@ netdev_get_addrs(const char dev[], struct in6_addr **paddr,
     }
 
     for (ifa = if_addr_list; ifa; ifa = ifa->ifa_next) {
-        if (ifa->ifa_addr != NULL) {
+        if (ifa->ifa_addr && ifa->ifa_name && ifa->ifa_netmask) {
             int family;
 
             family = ifa->ifa_addr->sa_family;
@@ -1903,7 +1911,8 @@ netdev_get_addrs(const char dev[], struct in6_addr **paddr,
     for (ifa = if_addr_list; ifa; ifa = ifa->ifa_next) {
         int family;
 
-        if (strncmp(ifa->ifa_name, dev, IFNAMSIZ) || ifa->ifa_addr == NULL) {
+        if (!ifa->ifa_name || !ifa->ifa_addr || !ifa->ifa_netmask
+            || strncmp(ifa->ifa_name, dev, IFNAMSIZ)) {
             continue;
         }
 
@@ -1913,7 +1922,7 @@ netdev_get_addrs(const char dev[], struct in6_addr **paddr,
 
             sin = ALIGNED_CAST(const struct sockaddr_in *, ifa->ifa_addr);
             in6_addr_set_mapped_ipv4(&addr_array[i], sin->sin_addr.s_addr);
-            sin = (struct sockaddr_in *) &ifa->ifa_netmask;
+            sin = ALIGNED_CAST(const struct sockaddr_in *, ifa->ifa_netmask);
             in6_addr_set_mapped_ipv4(&mask_array[i], sin->sin_addr.s_addr);
             i++;
         } else if (family == AF_INET6) {
@@ -1921,7 +1930,7 @@ netdev_get_addrs(const char dev[], struct in6_addr **paddr,
 
             sin6 = ALIGNED_CAST(const struct sockaddr_in6 *, ifa->ifa_addr);
             memcpy(&addr_array[i], &sin6->sin6_addr, sizeof *addr_array);
-            sin6 = (struct sockaddr_in6 *) &ifa->ifa_netmask;
+            sin6 = ALIGNED_CAST(const struct sockaddr_in6 *, ifa->ifa_netmask);
             memcpy(&mask_array[i], &sin6->sin6_addr, sizeof *mask_array);
             i++;
         }
diff --git a/lib/netlink-conntrack.c b/lib/netlink-conntrack.c
index aab5b1ffd..2aadb1e16 100644
--- a/lib/netlink-conntrack.c
+++ b/lib/netlink-conntrack.c
@@ -463,8 +463,8 @@ nl_ct_parse_tuple_proto(struct nlattr *nla, struct ct_dpif_tuple *tuple)
             tuple->dst_port = nl_attr_get_be16(attrs[CTA_PROTO_DST_PORT]);
         } else {
             /* Unsupported IPPROTO and no ports, leave them zeroed.
-             * We have parsed the ip_proto, so this is not a total failure. */
-            VLOG_INFO_RL(&rl, "Unsupported L4 protocol: %u.", tuple->ip_proto);
+             * We have parsed the ip_proto, so this is not a failure. */
+            VLOG_DBG_RL(&rl, "Unsupported L4 protocol: %u.", tuple->ip_proto);
         }
     } else {
         VLOG_ERR_RL(&rl, "Could not parse nested tuple protocol options. "
diff --git a/lib/netlink-socket.c b/lib/netlink-socket.c
index 7502764de..7105b9b09 100644
--- a/lib/netlink-socket.c
+++ b/lib/netlink-socket.c
@@ -886,6 +886,8 @@ nl_sock_transact_multiple__(struct nl_sock *sock,
         }
 
         if (reply_len != 0) {
+            request_nlmsg = nl_msg_nlmsghdr(txn->request);
+
             if (reply_len < sizeof *reply_nlmsg) {
                 nl_sock_record_errors__(transactions, n, 0);
                 VLOG_DBG_RL(&rl, "insufficient length of reply %#"PRIu32
@@ -894,7 +896,6 @@ nl_sock_transact_multiple__(struct nl_sock *sock,
             }
 
             /* Validate the sequence number in the reply. */
-            request_nlmsg = nl_msg_nlmsghdr(txn->request);
             reply_nlmsg = (struct nlmsghdr *)reply_buf;
 
             if (request_nlmsg->nlmsg_seq != reply_nlmsg->nlmsg_seq) {
@@ -1698,7 +1699,9 @@ nl_transact(int protocol, const struct ofpbuf *request,
 
     error = nl_pool_alloc(protocol, &sock);
     if (error) {
-        *replyp = NULL;
+        if (replyp) {
+            *replyp = NULL;
+        }
         return error;
     }
 
diff --git a/lib/odp-util.c b/lib/odp-util.c
index 6d29b67d5..1bf561869 100644
--- a/lib/odp-util.c
+++ b/lib/odp-util.c
@@ -460,8 +460,7 @@ format_odp_tnl_push_header(struct ds *ds, struct ovs_action_push_tnl *data)
 
     if (eth->eth_type == htons(ETH_TYPE_IP)) {
         /* IPv4 */
-        const struct ip_header *ip;
-        ip = (const struct ip_header *) l3;
+        const struct ip_header *ip = l3;
         ds_put_format(ds, "ipv4(src="IP_FMT",dst="IP_FMT",proto=%"PRIu8
                       ",tos=%#"PRIx8",ttl=%"PRIu8",frag=0x%"PRIx16"),",
                       IP_ARGS(get_16aligned_be32(&ip->ip_src)),
@@ -471,16 +470,20 @@ format_odp_tnl_push_header(struct ds *ds, struct ovs_action_push_tnl *data)
                       ntohs(ip->ip_frag_off));
         l4 = (ip + 1);
     } else {
-        const struct ip6_hdr *ip6;
-        ip6 = (const struct ip6_hdr *) l3;
+        const struct ovs_16aligned_ip6_hdr *ip6 = l3;
+        struct in6_addr src, dst;
+        memcpy(&src, &ip6->ip6_src, sizeof src);
+        memcpy(&dst, &ip6->ip6_dst, sizeof dst);
+        uint32_t ipv6_flow = ntohl(get_16aligned_be32(&ip6->ip6_flow));
+
         ds_put_format(ds, "ipv6(src=");
-        ipv6_format_addr(&ip6->ip6_src, ds);
+        ipv6_format_addr(&src, ds);
         ds_put_format(ds, ",dst=");
-        ipv6_format_addr(&ip6->ip6_dst, ds);
-        ds_put_format(ds, ",label=%i,proto=%"PRIu8",tclass=0x%"PRIx8
+        ipv6_format_addr(&dst, ds);
+        ds_put_format(ds, ",label=%i,proto=%"PRIu8",tclass=0x%"PRIx32
                           ",hlimit=%"PRIu8"),",
-                      ntohl(ip6->ip6_flow) & IPV6_LABEL_MASK, ip6->ip6_nxt,
-                      (ntohl(ip6->ip6_flow) >> 20) & 0xff, ip6->ip6_hlim);
+                      ipv6_flow & IPV6_LABEL_MASK, ip6->ip6_nxt,
+                      (ipv6_flow >> 20) & 0xff, ip6->ip6_hlim);
         l4 = (ip6 + 1);
     }
 
@@ -4520,7 +4523,9 @@ odp_key_to_pkt_metadata(const struct nlattr *key, size_t key_len,
     size_t left;
     uint32_t wanted_attrs = 1u << OVS_KEY_ATTR_PRIORITY |
         1u << OVS_KEY_ATTR_SKB_MARK | 1u << OVS_KEY_ATTR_TUNNEL |
-        1u << OVS_KEY_ATTR_IN_PORT;
+        1u << OVS_KEY_ATTR_IN_PORT | 1u << OVS_KEY_ATTR_CT_STATE |
+        1u << OVS_KEY_ATTR_CT_ZONE | 1u << OVS_KEY_ATTR_CT_MARK |
+        1u << OVS_KEY_ATTR_CT_LABELS;
 
     pkt_metadata_init(md, ODPP_NONE);
 
@@ -5582,7 +5587,10 @@ commit_mpls_action(const struct flow *flow, struct flow *base,
                                       sizeof *mpls);
         mpls->mpls_ethertype = flow->dl_type;
         mpls->mpls_lse = flow->mpls_lse[flow_n - base_n - 1];
-        flow_push_mpls(base, base_n, mpls->mpls_ethertype, NULL);
+        /* Update base flow's MPLS stack, but do not clear L3.  We need the L3
+         * headers if the flow is restored later due to returning from a patch
+         * port or group bucket. */
+        flow_push_mpls(base, base_n, mpls->mpls_ethertype, NULL, false);
         flow_set_mpls_lse(base, 0, mpls->mpls_lse);
         base_n++;
     }
@@ -5945,12 +5953,21 @@ commit_odp_actions(const struct flow *flow, struct flow *base,
                    bool use_masked)
 {
     enum slow_path_reason slow1, slow2;
+    bool mpls_done = false;
 
     commit_set_ether_addr_action(flow, base, odp_actions, wc, use_masked);
+    /* Make packet a non-MPLS packet before committing L3/4 actions,
+     * which would otherwise do nothing. */
+    if (eth_type_mpls(base->dl_type) && !eth_type_mpls(flow->dl_type)) {
+        commit_mpls_action(flow, base, odp_actions);
+        mpls_done = true;
+    }
     slow1 = commit_set_nw_action(flow, base, odp_actions, wc, use_masked);
     commit_set_port_action(flow, base, odp_actions, wc, use_masked);
     slow2 = commit_set_icmp_action(flow, base, odp_actions, wc);
-    commit_mpls_action(flow, base, odp_actions);
+    if (!mpls_done) {
+        commit_mpls_action(flow, base, odp_actions);
+    }
     commit_vlan_action(flow->vlan_tci, base, odp_actions, wc);
     commit_set_priority_action(flow, base, odp_actions, wc, use_masked);
     commit_set_pkt_mark_action(flow, base, odp_actions, wc, use_masked);
diff --git a/lib/ofp-actions.c b/lib/ofp-actions.c
index 15dbdec8d..db5ca07d4 100644
--- a/lib/ofp-actions.c
+++ b/lib/ofp-actions.c
@@ -609,7 +609,7 @@ static void
 format_OUTPUT(const struct ofpact_output *a, struct ds *s)
 {
     if (ofp_to_u16(a->port) < ofp_to_u16(OFPP_MAX)) {
-        ds_put_format(s, "%soutput:%s%"PRIu16,
+        ds_put_format(s, "%soutput:%s%"PRIu32,
                       colors.special, colors.end, a->port);
     } else {
         ofputil_format_port(a->port, s);
@@ -4966,7 +4966,7 @@ format_SAMPLE(const struct ofpact_sample *a, struct ds *s)
                   colors.param, colors.end, a->obs_domain_id,
                   colors.param, colors.end, a->obs_point_id);
     if (a->sampling_port != OFPP_NONE) {
-        ds_put_format(s, ",%ssampling_port=%s%"PRIu16,
+        ds_put_format(s, ",%ssampling_port=%s%"PRIu32,
                       colors.param, colors.end, a->sampling_port);
     }
     ds_put_format(s, "%s)%s", colors.paren, colors.end);
@@ -5778,7 +5778,7 @@ parse_OUTPUT_TRUNC(const char *arg, struct ofpbuf *ofpacts OVS_UNUSED,
 static void
 format_OUTPUT_TRUNC(const struct ofpact_output_trunc *a, struct ds *s)
 {
-     ds_put_format(s, "%soutput%s(port=%"PRIu16",max_len=%"PRIu32")",
+     ds_put_format(s, "%soutput%s(port=%"PRIu32",max_len=%"PRIu32")",
                    colors.special, colors.end, a->port, a->max_len);
 }
 
@@ -6396,7 +6396,7 @@ OVS_INSTRUCTIONS
 const char *
 ovs_instruction_name_from_type(enum ovs_instruction_type type)
 {
-    return inst_info[type].name;
+    return type < ARRAY_SIZE(inst_info) ? inst_info[type].name : NULL;
 }
 
 int
diff --git a/lib/ofp-parse.c b/lib/ofp-parse.c
index 76452aaa8..7d63f4164 100644
--- a/lib/ofp-parse.c
+++ b/lib/ofp-parse.c
@@ -1704,7 +1704,9 @@ parse_ofp_group_mod_file(const char *file_name, int command,
                 fclose(stream);
             }
 
-            return xasprintf("%s:%d: %s", file_name, line_number, error);
+            char *ret = xasprintf("%s:%d: %s", file_name, line_number, error);
+            free(error);
+            return ret;
         }
         *usable_protocols &= usable;
         *n_gms += 1;
diff --git a/lib/ofp-print.c b/lib/ofp-print.c
index 4a22e71b1..701739d12 100644
--- a/lib/ofp-print.c
+++ b/lib/ofp-print.c
@@ -506,6 +506,8 @@ ofputil_capabilities_to_name(uint32_t bit)
     case OFPUTIL_C_STP:          return "STP";
     case OFPUTIL_C_GROUP_STATS:  return "GROUP_STATS";
     case OFPUTIL_C_PORT_BLOCKED: return "PORT_BLOCKED";
+    case OFPUTIL_C_BUNDLES:      return "BUNDLES";
+    case OFPUTIL_C_FLOW_MONITORING: return "FLOW_MONITORING";
     }
 
     return NULL;
@@ -1261,6 +1263,7 @@ ofp_print_queue_get_config_reply(struct ds *string,
         ofp_print_error(string, retval);
     }
     ds_chomp(string, ' ');
+    free(queues);
 }
 
 static void
@@ -2086,7 +2089,8 @@ ofp_print_role_status_message(struct ds *string, const struct ofp_header *oh)
         break;
     case OFPCRR_N_REASONS:
     default:
-        OVS_NOT_REACHED();
+        ds_put_cstr(string, "(unknown)");
+        break;
     }
 }
 
@@ -2820,7 +2824,13 @@ print_table_instruction_features(
 
             for (i = 0; i < 32; i++) {
                 if (tif->instructions & (1u << i)) {
-                    ds_put_format(s, "%s,", ovs_instruction_name_from_type(i));
+                    const char *name = ovs_instruction_name_from_type(i);
+                    if (name) {
+                        ds_put_cstr(s, name);
+                    } else {
+                        ds_put_format(s, "%d", i);
+                    }
+                    ds_put_char(s, ',');
                 }
             }
             ds_chomp(s, ',');
diff --git a/lib/ofp-util.c b/lib/ofp-util.c
index 5b23ac757..1f24b7d2a 100644
--- a/lib/ofp-util.c
+++ b/lib/ofp-util.c
@@ -159,6 +159,7 @@ ofputil_match_from_ofp10_match(const struct ofp10_match *ofmatch,
     /* Initialize match->wc. */
     memset(&match->flow, 0, sizeof match->flow);
     ofputil_wildcard_from_ofpfw10(ofpfw, &match->wc);
+    memset(&match->tun_md, 0, sizeof match->tun_md);
 
     /* Initialize most of match->flow. */
     match->flow.nw_src = ofmatch->nw_src;
@@ -2585,7 +2586,7 @@ ofputil_pull_queue_get_config_reply10(struct ofpbuf *msg,
 
         hdr = ofpbuf_at_assert(msg, 0, sizeof *hdr);
         prop_len = ntohs(hdr->len);
-        if (prop_len < sizeof *hdr || prop_len > msg->size || prop_len % 8) {
+        if (prop_len < sizeof *hdr || prop_len > len || prop_len % 8) {
             return OFPERR_OFPBRC_BAD_LEN;
         }
 
@@ -4074,7 +4075,9 @@ ofputil_decode_packet_in_private(const struct ofp_header *oh, bool loose,
         uint64_t type;
 
         error = ofpprop_pull(&continuation, &payload, &type);
-        ovs_assert(!error);
+        if (error) {
+            break;
+        }
 
         switch (type) {
         case NXCPT_BRIDGE:
@@ -4137,7 +4140,7 @@ ofputil_decode_packet_in_private(const struct ofp_header *oh, bool loose,
         ofputil_packet_in_private_destroy(pin);
     }
 
-    return 0;
+    return error;
 }
 
 /* Frees data in 'pin' that is dynamically allocated by
@@ -4207,7 +4210,7 @@ ofputil_decode_packet_out(struct ofputil_packet_out *po,
     if (ofp_to_u16(po->in_port) >= ofp_to_u16(OFPP_MAX)
         && po->in_port != OFPP_LOCAL
         && po->in_port != OFPP_NONE && po->in_port != OFPP_CONTROLLER) {
-        VLOG_WARN_RL(&bad_ofmsg_rl, "packet-out has bad input port %#"PRIx16,
+        VLOG_WARN_RL(&bad_ofmsg_rl, "packet-out has bad input port %#"PRIx32,
                      po->in_port);
         return OFPERR_OFPBRC_BAD_PORT;
     }
@@ -4654,6 +4657,9 @@ BUILD_ASSERT_DECL((int) OFPUTIL_C_PORT_STATS == OFPC_PORT_STATS);
 BUILD_ASSERT_DECL((int) OFPUTIL_C_IP_REASM == OFPC_IP_REASM);
 BUILD_ASSERT_DECL((int) OFPUTIL_C_QUEUE_STATS == OFPC_QUEUE_STATS);
 BUILD_ASSERT_DECL((int) OFPUTIL_C_ARP_MATCH_IP == OFPC_ARP_MATCH_IP);
+BUILD_ASSERT_DECL((int) OFPUTIL_C_PORT_BLOCKED == OFPC12_PORT_BLOCKED);
+BUILD_ASSERT_DECL((int) OFPUTIL_C_BUNDLES == OFPC14_BUNDLES);
+BUILD_ASSERT_DECL((int) OFPUTIL_C_FLOW_MONITORING == OFPC14_FLOW_MONITORING);
 
 static uint32_t
 ofputil_capabilities_mask(enum ofp_version ofp_version)
@@ -4665,10 +4671,12 @@ ofputil_capabilities_mask(enum ofp_version ofp_version)
         return OFPC_COMMON | OFPC_ARP_MATCH_IP;
     case OFP12_VERSION:
     case OFP13_VERSION:
+        return OFPC_COMMON | OFPC12_PORT_BLOCKED;
     case OFP14_VERSION:
     case OFP15_VERSION:
     case OFP16_VERSION:
-        return OFPC_COMMON | OFPC12_PORT_BLOCKED;
+        return OFPC_COMMON | OFPC12_PORT_BLOCKED | OFPC14_BUNDLES
+            | OFPC14_FLOW_MONITORING;
     default:
         /* Caller needs to check osf->header.version itself */
         return 0;
@@ -4794,7 +4802,6 @@ ofputil_encode_switch_features(const struct ofputil_switch_features *features,
     osf->n_buffers = htonl(features->n_buffers);
     osf->n_tables = features->n_tables;
 
-    osf->capabilities = htonl(features->capabilities & OFPC_COMMON);
     osf->capabilities = htonl(features->capabilities &
                               ofputil_capabilities_mask(version));
     switch (version) {
@@ -7124,7 +7131,7 @@ ofputil_port_to_string(ofp_port_t port,
 #undef OFPUTIL_NAMED_PORT
 
     default:
-        snprintf(namebuf, bufsize, "%"PRIu16, port);
+        snprintf(namebuf, bufsize, "%"PRIu32, port);
         break;
     }
 }
@@ -8690,6 +8697,7 @@ ofputil_pull_ofp11_buckets(struct ofpbuf *msg, size_t buckets_length,
         if (!ob) {
             VLOG_WARN_RL(&bad_ofmsg_rl, "buckets end with %"PRIuSIZE" leftover bytes",
                          buckets_length);
+            ofputil_bucket_list_destroy(buckets);
             return OFPERR_OFPGMFC_BAD_BUCKET;
         }
 
@@ -8697,11 +8705,13 @@ ofputil_pull_ofp11_buckets(struct ofpbuf *msg, size_t buckets_length,
         if (ob_len < sizeof *ob) {
             VLOG_WARN_RL(&bad_ofmsg_rl, "OpenFlow message bucket length "
                          "%"PRIuSIZE" is not valid", ob_len);
+            ofputil_bucket_list_destroy(buckets);
             return OFPERR_OFPGMFC_BAD_BUCKET;
         } else if (ob_len > buckets_length) {
             VLOG_WARN_RL(&bad_ofmsg_rl, "OpenFlow message bucket length "
                          "%"PRIuSIZE" exceeds remaining buckets data size %"PRIuSIZE,
                          ob_len, buckets_length);
+            ofputil_bucket_list_destroy(buckets);
             return OFPERR_OFPGMFC_BAD_BUCKET;
         }
         buckets_length -= ob_len;
@@ -8721,6 +8731,7 @@ ofputil_pull_ofp11_buckets(struct ofpbuf *msg, size_t buckets_length,
         if (error) {
             ofpbuf_uninit(&ofpacts);
             ofputil_bucket_list_destroy(buckets);
+            free(bucket);
             return OFPERR_OFPGMFC_BAD_WATCH;
         }
         bucket->watch_group = ntohl(ob->watch_group);
@@ -9097,8 +9108,13 @@ ofputil_decode_ofp15_group_desc_reply(struct ofputil_group_desc *gd,
      * Such properties are valid for group desc replies so
      * claim that the group mod command is OFPGC15_ADD to
      * satisfy the check in parse_group_prop_ntr_selection_method() */
-    return parse_ofp15_group_properties(msg, gd->type, OFPGC15_ADD, &gd->props,
-                                        length - sizeof *ogds - bucket_list_len);
+    error = parse_ofp15_group_properties(
+        msg, gd->type, OFPGC15_ADD, &gd->props,
+        length - sizeof *ogds - bucket_list_len);
+    if (error) {
+        ofputil_bucket_list_destroy(&gd->buckets);
+    }
+    return error;
 }
 
 /* Converts a group description reply in 'msg' into an abstract
@@ -9335,6 +9351,7 @@ ofputil_pull_ofp11_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,
         && gm->command == OFPGC11_DELETE
         && !ovs_list_is_empty(&gm->buckets)) {
         error = OFPERR_OFPGMFC_INVALID_GROUP;
+        ofputil_bucket_list_destroy(&gm->buckets);
     }
 
     return error;
@@ -9386,51 +9403,26 @@ ofputil_pull_ofp15_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,
     }
 
     bucket_list_len = ntohs(ogm->bucket_array_len);
+    if (bucket_list_len > msg->size) {
+        return OFPERR_OFPBRC_BAD_LEN;
+    }
     error = ofputil_pull_ofp15_buckets(msg, bucket_list_len, ofp_version,
                                        gm->type, &gm->buckets);
     if (error) {
         return error;
     }
 
-    return parse_ofp15_group_properties(msg, gm->type, gm->command, &gm->props,
-                                        msg->size);
+    error = parse_ofp15_group_properties(msg, gm->type, gm->command,
+                                         &gm->props, msg->size);
+    if (error) {
+        ofputil_bucket_list_destroy(&gm->buckets);
+    }
+    return error;
 }
 
-/* Converts OpenFlow group mod message 'oh' into an abstract group mod in
- * 'gm'.  Returns 0 if successful, otherwise an OpenFlow error code. */
-enum ofperr
-ofputil_decode_group_mod(const struct ofp_header *oh,
-                         struct ofputil_group_mod *gm)
+static enum ofperr
+ofputil_check_group_mod(const struct ofputil_group_mod *gm)
 {
-    ofputil_init_group_properties(&gm->props);
-
-    enum ofp_version ofp_version = oh->version;
-    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));
-    ofpraw_pull_assert(&msg);
-
-    enum ofperr err;
-    switch (ofp_version)
-    {
-    case OFP11_VERSION:
-    case OFP12_VERSION:
-    case OFP13_VERSION:
-    case OFP14_VERSION:
-        err = ofputil_pull_ofp11_group_mod(&msg, ofp_version, gm);
-        break;
-
-    case OFP15_VERSION:
-    case OFP16_VERSION:
-        err = ofputil_pull_ofp15_group_mod(&msg, ofp_version, gm);
-        break;
-
-    case OFP10_VERSION:
-    default:
-        OVS_NOT_REACHED();
-    }
-    if (err) {
-        return err;
-    }
-
     switch (gm->type) {
     case OFPGT11_INDIRECT:
         if (gm->command != OFPGC11_DELETE
@@ -9492,6 +9484,48 @@ ofputil_decode_group_mod(const struct ofp_header *oh,
     return 0;
 }
 
+/* Converts OpenFlow group mod message 'oh' into an abstract group mod in
+ * 'gm'.  Returns 0 if successful, otherwise an OpenFlow error code. */
+enum ofperr
+ofputil_decode_group_mod(const struct ofp_header *oh,
+                         struct ofputil_group_mod *gm)
+{
+    ofputil_init_group_properties(&gm->props);
+
+    enum ofp_version ofp_version = oh->version;
+    struct ofpbuf msg = ofpbuf_const_initializer(oh, ntohs(oh->length));
+    ofpraw_pull_assert(&msg);
+
+    enum ofperr err;
+    switch (ofp_version)
+    {
+    case OFP11_VERSION:
+    case OFP12_VERSION:
+    case OFP13_VERSION:
+    case OFP14_VERSION:
+        err = ofputil_pull_ofp11_group_mod(&msg, ofp_version, gm);
+        break;
+
+    case OFP15_VERSION:
+    case OFP16_VERSION:
+        err = ofputil_pull_ofp15_group_mod(&msg, ofp_version, gm);
+        break;
+
+    case OFP10_VERSION:
+    default:
+        OVS_NOT_REACHED();
+    }
+    if (err) {
+        return err;
+    }
+
+    err = ofputil_check_group_mod(gm);
+    if (err) {
+        ofputil_uninit_group_mod(gm);
+    }
+    return err;
+}
+
 /* Destroys 'bms'. */
 void
 ofputil_encode_bundle_msgs(struct ofputil_bundle_msg *bms, size_t n_bms,
@@ -10002,14 +10036,21 @@ ofputil_decode_bundle_add(const struct ofp_header *oh,
                           enum ofptype *typep)
 {
     struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));
+
+    /* Pull the outer ofp_header. */
     enum ofpraw raw = ofpraw_pull_assert(&b);
     ovs_assert(raw == OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE
                || raw == OFPRAW_ONFT13_BUNDLE_ADD_MESSAGE);
 
+    /* Pull the bundle_ctrl header. */
     const struct ofp14_bundle_ctrl_msg *m = ofpbuf_pull(&b, sizeof *m);
     msg->bundle_id = ntohl(m->bundle_id);
     msg->flags = ntohs(m->flags);
 
+    /* Pull the inner ofp_header. */
+    if (b.size < sizeof(struct ofp_header)) {
+        return OFPERR_OFPBFC_MSG_BAD_LEN;
+    }
     msg->msg = b.data;
     if (msg->msg->version != oh->version) {
         return OFPERR_OFPBFC_BAD_VERSION;
diff --git a/lib/ovs-router.c b/lib/ovs-router.c
index e27514a74..935b60a81 100644
--- a/lib/ovs-router.c
+++ b/lib/ovs-router.c
@@ -198,6 +198,9 @@ ovs_router_insert__(uint8_t priority, const struct in6_addr *ip6_dst,
     p->plen = plen;
     p->priority = priority;
     err = get_src_addr(ip6_dst, output_bridge, &p->src_addr);
+    if (err && ipv6_addr_is_set(gw)) {
+        err = get_src_addr(gw, output_bridge, &p->src_addr);
+    }
     if (err) {
         free(p);
         return err;
@@ -316,7 +319,7 @@ ovs_router_add(struct unixctl_conn *conn, int argc,
     }
     err = ovs_router_insert__(plen + 32, &ip6, plen, argv[2], &gw6);
     if (err) {
-        unixctl_command_reply(conn, "Error while inserting route.");
+        unixctl_command_reply_error(conn, "Error while inserting route.");
     } else {
         unixctl_command_reply(conn, "OK");
     }
@@ -399,7 +402,7 @@ ovs_router_lookup_cmd(struct unixctl_conn *conn, int argc OVS_UNUSED,
         struct ds ds = DS_EMPTY_INITIALIZER;
         ds_put_format(&ds, "src ");
         ipv6_format_mapped(&src, &ds);
-        ds_put_format(&ds, "gateway ");
+        ds_put_format(&ds, "\ngateway ");
         ipv6_format_mapped(&gw, &ds);
         ds_put_format(&ds, "\ndev %s\n", iface);
         unixctl_command_reply(conn, ds_cstr(&ds));
diff --git a/lib/ovsdb-types.c b/lib/ovsdb-types.c
index 20a84440b..50a32a722 100644
--- a/lib/ovsdb-types.c
+++ b/lib/ovsdb-types.c
@@ -364,6 +364,7 @@ ovsdb_base_type_from_json(struct ovsdb_base_type *base,
 
     error = ovsdb_atomic_type_from_json(&base->type, type);
     if (error) {
+        ovsdb_error_destroy(ovsdb_parser_destroy(&parser));
         return error;
     }
 
diff --git a/lib/packets.c b/lib/packets.c
index e4c29d509..72a118c8b 100644
--- a/lib/packets.c
+++ b/lib/packets.c
@@ -1454,6 +1454,26 @@ packet_csum_pseudoheader6(const struct ovs_16aligned_ip6_hdr *ip6)
 
     return partial;
 }
+
+/* Calculate the IPv6 upper layer checksum according to RFC2460. We pass the
+   ip6_nxt and ip6_plen values, so it will also work if extension headers
+   are present. */
+uint16_t
+packet_csum_upperlayer6(const struct ovs_16aligned_ip6_hdr *ip6,
+                        const void *data, uint8_t l4_protocol,
+                        uint16_t l4_size)
+{
+    uint32_t partial = 0;
+
+    partial = csum_continue(partial, &ip6->ip6_src, sizeof ip6->ip6_src);
+    partial = csum_continue(partial, &ip6->ip6_dst, sizeof ip6->ip6_dst);
+    partial = csum_add16(partial, htons(l4_protocol));
+    partial = csum_add16(partial, htons(l4_size));
+
+    partial = csum_continue(partial, data, l4_size);
+
+    return csum_finish(partial);
+}
 #endif
 
 void
diff --git a/lib/packets.h b/lib/packets.h
index dcfcd04b2..3661be47a 100644
--- a/lib/packets.h
+++ b/lib/packets.h
@@ -576,6 +576,18 @@ char *ip_parse_cidr_len(const char *s, int *n, ovs_be32 *ip,
 #define IPPROTO_SCTP 132
 #endif
 
+#ifndef IPPROTO_DCCP
+#define IPPROTO_DCCP 33
+#endif
+
+#ifndef IPPROTO_IGMP
+#define IPPROTO_IGMP 2
+#endif
+
+#ifndef IPPROTO_UDPLITE
+#define IPPROTO_UDPLITE 136
+#endif
+
 /* TOS fields. */
 #define IP_ECN_NOT_ECT 0x0
 #define IP_ECN_ECT_1 0x01
@@ -830,6 +842,8 @@ struct icmp6_header {
 BUILD_ASSERT_DECL(ICMP6_HEADER_LEN == sizeof(struct icmp6_header));
 
 uint32_t packet_csum_pseudoheader6(const struct ovs_16aligned_ip6_hdr *);
+uint16_t packet_csum_upperlayer6(const struct ovs_16aligned_ip6_hdr *,
+                                 const void *, uint8_t, uint16_t);
 
 /* Neighbor Discovery option field.
  * ND options are always a multiple of 8 bytes in size. */
diff --git a/lib/rconn.c b/lib/rconn.c
index 0c1812a27..8a2986403 100644
--- a/lib/rconn.c
+++ b/lib/rconn.c
@@ -558,19 +558,23 @@ run_ACTIVE(struct rconn *rc)
 {
     if (timed_out(rc)) {
         unsigned int base = MAX(rc->last_activity, rc->state_entered);
-        int version;
-
         VLOG_DBG("%s: idle %u seconds, sending inactivity probe",
                  rc->name, (unsigned int) (time_now() - base));
 
-        version = rconn_get_version__(rc);
-        ovs_assert(version >= 0 && version <= 0xff);
-
         /* Ordering is important here: rconn_send() can transition to BACKOFF,
          * and we don't want to transition back to IDLE if so, because then we
          * can end up queuing a packet with vconn == NULL and then *boom*. */
         state_transition(rc, S_IDLE);
-        rconn_send__(rc, make_echo_request(version), NULL);
+
+        /* Send an echo request if we can.  (If version negotiation is not
+         * complete, that is, if we did not yet receive a "hello" message from
+         * the peer, we do not know the version to use, so we don't send
+         * anything.) */
+        int version = rconn_get_version__(rc);
+        if (version >= 0 && version <= 0xff) {
+            rconn_send__(rc, make_echo_request(version), NULL);
+        }
+
         return;
     }
 
diff --git a/lib/route-table.c b/lib/route-table.c
index 0457de327..00f95e3ae 100644
--- a/lib/route-table.c
+++ b/lib/route-table.c
@@ -188,7 +188,7 @@ route_table_parse(struct ofpbuf *buf, struct route_table_msg *change)
 
     static const struct nl_policy policy[] = {
         [RTA_DST] = { .type = NL_A_U32, .optional = true  },
-        [RTA_OIF] = { .type = NL_A_U32, .optional = false },
+        [RTA_OIF] = { .type = NL_A_U32, .optional = true },
         [RTA_GATEWAY] = { .type = NL_A_U32, .optional = true },
     };
 
diff --git a/lib/stp.c b/lib/stp.c
index ecef01287..2ffe5c219 100644
--- a/lib/stp.c
+++ b/lib/stp.c
@@ -302,7 +302,7 @@ stp_create(const char *name, stp_identifier bridge_id,
 
     stp_stop_timer(&stp->tcn_timer);
     stp_stop_timer(&stp->topology_change_timer);
-    stp_start_timer(&stp->hello_timer, 0);
+    stp_start_timer(&stp->hello_timer, stp->hello_time);
 
     stp->send_bpdu = send_bpdu;
     stp->aux = aux;
diff --git a/lib/stream-windows.c b/lib/stream-windows.c
index 637920b10..c4279d7a0 100644
--- a/lib/stream-windows.c
+++ b/lib/stream-windows.c
@@ -39,6 +39,9 @@ static void maybe_unlink_and_free(char *path);
 /* Default prefix of a local named pipe. */
 #define LOCAL_PREFIX "\\\\.\\pipe\\"
 
+/* Size of the allowed PSIDs for securing Named Pipe. */
+#define ALLOWED_PSIDS_SIZE 2
+
 /* This function has the purpose to remove all the slashes received in s. */
 static char *
 remove_slashes(char *s)
@@ -398,16 +401,99 @@ static HANDLE
 create_pnpipe(char *name)
 {
     SECURITY_ATTRIBUTES sa;
-    sa.nLength = sizeof(sa);
-    sa.lpSecurityDescriptor = NULL;
+    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
+    DWORD aclSize;
+    PSID allowedPsid[ALLOWED_PSIDS_SIZE];
+    PSID remoteAccessSid;
+    PACL acl = NULL;
+    PSECURITY_DESCRIPTOR psd = NULL;
+    HANDLE npipe;
+
+    /* Disable access over network. */
+    if (!AllocateAndInitializeSid(&sia, 1, SECURITY_NETWORK_RID,
+                                  0, 0, 0, 0, 0, 0, 0, &remoteAccessSid)) {
+        VLOG_ERR_RL(&rl, "Error creating Remote Access SID.");
+        goto handle_error;
+    }
+
+    aclSize = sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) +
+              GetLengthSid(remoteAccessSid) - sizeof(DWORD);
+
+    /* Allow Windows Services to access the Named Pipe. */
+    if (!AllocateAndInitializeSid(&sia, 1, SECURITY_LOCAL_SYSTEM_RID,
+                                  0, 0, 0, 0, 0, 0, 0, &allowedPsid[0])) {
+        VLOG_ERR_RL(&rl, "Error creating Services SID.");
+        goto handle_error;
+    }
+
+    /* Allow Administrators to access the Named Pipe. */
+    if (!AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID,
+                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0,
+                                  &allowedPsid[1])) {
+        VLOG_ERR_RL(&rl, "Error creating Administrator SID.");
+        goto handle_error;
+    }
+
+    for (int i = 0; i < ALLOWED_PSIDS_SIZE; i++) {
+        aclSize += sizeof(ACCESS_ALLOWED_ACE) +
+                   GetLengthSid(allowedPsid[i]) -
+                   sizeof(DWORD);
+    }
+
+    acl = xmalloc(aclSize);
+    if (!InitializeAcl(acl, aclSize, ACL_REVISION)) {
+        VLOG_ERR_RL(&rl, "Error initializing ACL.");
+        goto handle_error;
+    }
+
+    /* Add denied ACL. */
+    if (!AddAccessDeniedAce(acl, ACL_REVISION,
+                            GENERIC_ALL, remoteAccessSid)) {
+        VLOG_ERR_RL(&rl, "Error adding remote access ACE.");
+        goto handle_error;
+    }
+
+    /* Add allowed ACLs. */
+    for (int i = 0; i < ALLOWED_PSIDS_SIZE; i++) {
+        if (!AddAccessAllowedAce(acl, ACL_REVISION,
+                                 GENERIC_ALL, allowedPsid[i])) {
+            VLOG_ERR_RL(&rl, "Error adding ACE.");
+            goto handle_error;
+        }
+    }
+
+    psd = xmalloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
+    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) {
+        VLOG_ERR_RL(&rl, "Error initializing Security Descriptor.");
+        goto handle_error;
+    }
+
+    /* Set DACL. */
+    if (!SetSecurityDescriptorDacl(psd, TRUE, acl, FALSE)) {
+        VLOG_ERR_RL(&rl, "Error while setting DACL.");
+        goto handle_error;
+    }
+
+    sa.nLength = sizeof sa;
     sa.bInheritHandle = TRUE;
+    sa.lpSecurityDescriptor = psd;
+
     if (strlen(name) > 256) {
         VLOG_ERR_RL(&rl, "Named pipe name too long.");
-        return INVALID_HANDLE_VALUE;
+        goto handle_error;
     }
-    return CreateNamedPipe(name, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
-                           PIPE_TYPE_MESSAGE | PIPE_READMODE_BYTE | PIPE_WAIT,
-                           64, BUFSIZE, BUFSIZE, 0, &sa);
+
+    npipe = CreateNamedPipe(name, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
+                            PIPE_TYPE_MESSAGE | PIPE_READMODE_BYTE | PIPE_WAIT,
+                            64, BUFSIZE, BUFSIZE, 0, &sa);
+    free(acl);
+    free(psd);
+    return npipe;
+
+handle_error:
+    free(acl);
+    free(psd);
+    return INVALID_HANDLE_VALUE;
 }
 
 /* Passive named pipe connect.  This function creates a new named pipe and
diff --git a/lib/table.man b/lib/table.man
index a8f109465..244b9cf4c 100644
--- a/lib/table.man
+++ b/lib/table.man
@@ -36,8 +36,10 @@ as text strings.
 .
 .IP "\fB\-d \fIformat\fR"
 .IQ "\fB\-\-data=\fIformat\fR"
-Sets the formatting for cells within output tables.  The following
-types of \fIformat\fR are available:
+Sets the formatting for cells within output tables unless the table
+format is set to \fBjson\fR, in which case \fBjson\fR formatting is
+always used when formatting cells.  The following types of \fIformat\fR
+are available:
 .RS
 .IP "\fBstring\fR (default)"
 The simple format described in the \fBDatabase Values\fR
@@ -49,13 +51,11 @@ are omitted around sets, maps, and empty columns, items within sets
 and maps are space-separated, and strings are never quoted.  This
 format may be easier for scripts to parse.
 .IP "\fBjson\fR"
-JSON.
+The RFC 4627 JSON format as described above.
 .RE
 .IP
-The \fBjson\fR output format always outputs cells in JSON format,
-ignoring this option.
 .
-.IP "\fB\-\-no\-heading\fR"
+.IP "\fB\-\-no\-headings\fR"
 This option suppresses the heading row that otherwise appears in the
 first row of table output.
 .
diff --git a/lib/tnl-neigh-cache.c b/lib/tnl-neigh-cache.c
index 499efffbf..a28ce1de8 100644
--- a/lib/tnl-neigh-cache.c
+++ b/lib/tnl-neigh-cache.c
@@ -126,8 +126,8 @@ tnl_neigh_set__(const char name[IFNAMSIZ], const struct in6_addr *dst,
             return;
         }
         tnl_neigh_delete(neigh);
-        seq_change(tnl_conf_seq);
     }
+    seq_change(tnl_conf_seq);
 
     neigh = xmalloc(sizeof *neigh);
 
diff --git a/lib/tnl-ports.c b/lib/tnl-ports.c
index ffa13899a..7fb988a24 100644
--- a/lib/tnl-ports.c
+++ b/lib/tnl-ports.c
@@ -51,6 +51,7 @@ static struct ovs_list addr_list;
 
 struct tnl_port {
     odp_port_t port;
+    struct ovs_refcount ref_cnt;
     ovs_be16 tp_port;
     uint8_t nw_proto;
     char dev_name[IFNAMSIZ];
@@ -195,7 +196,8 @@ tnl_port_map_insert(odp_port_t port, ovs_be16 tp_port,
     ovs_mutex_lock(&mutex);
     LIST_FOR_EACH(p, node, &port_list) {
         if (tp_port == p->tp_port && p->nw_proto == nw_proto) {
-             goto out;
+            ovs_refcount_ref(&p->ref_cnt);
+            goto out;
         }
     }
 
@@ -204,6 +206,7 @@ tnl_port_map_insert(odp_port_t port, ovs_be16 tp_port,
     p->tp_port = tp_port;
     p->nw_proto = nw_proto;
     ovs_strlcpy(p->dev_name, dev_name, sizeof p->dev_name);
+    ovs_refcount_init(&p->ref_cnt);
     ovs_list_insert(&port_list, &p->node);
 
     LIST_FOR_EACH(ip_dev, node, &addr_list) {
@@ -256,29 +259,22 @@ tnl_port_map_delete(ovs_be16 tp_port, const char type[])
 {
     struct tnl_port *p, *next;
     struct ip_device *ip_dev;
-    bool found = false;
     uint8_t nw_proto;
 
     nw_proto = tnl_type_to_nw_proto(type);
 
     ovs_mutex_lock(&mutex);
     LIST_FOR_EACH_SAFE(p, next, node, &port_list) {
-        if (p->tp_port == tp_port && p->nw_proto == nw_proto) {
+        if (p->tp_port == tp_port && p->nw_proto == nw_proto &&
+                    ovs_refcount_unref_relaxed(&p->ref_cnt) == 1) {
             ovs_list_remove(&p->node);
-            found = true;
+            LIST_FOR_EACH(ip_dev, node, &addr_list) {
+                ipdev_map_delete(ip_dev, p->tp_port, p->nw_proto);
+            }
+            free(p);
             break;
         }
     }
-
-    if (!found) {
-        goto out;
-    }
-    LIST_FOR_EACH(ip_dev, node, &addr_list) {
-        ipdev_map_delete(ip_dev, p->tp_port, p->nw_proto);
-    }
-
-    free(p);
-out:
     ovs_mutex_unlock(&mutex);
 }
 
diff --git a/lib/tun-metadata.c b/lib/tun-metadata.c
index 36006e3ba..ed2883504 100644
--- a/lib/tun-metadata.c
+++ b/lib/tun-metadata.c
@@ -33,7 +33,7 @@
 
 struct tun_meta_entry {
     struct hmap_node node;      /* In struct tun_table's key_hmap. */
-    uint32_t key;               /* (class << 16) | type. */
+    uint32_t key;               /* (class << 8) | type. */
     struct tun_metadata_loc loc;
     bool valid;                 /* True if allocated to a class and type. */
 };
diff --git a/lib/vconn.c b/lib/vconn.c
index d5a17f626..d3f83642c 100644
--- a/lib/vconn.c
+++ b/lib/vconn.c
@@ -744,18 +744,6 @@ vconn_recv_block(struct vconn *vconn, struct ofpbuf **msgp)
     return retval;
 }
 
-static void
-vconn_add_bundle_error(const struct ofp_header *oh, struct ovs_list *errors)
-{
-    if (errors) {
-        struct vconn_bundle_error *err = xmalloc(sizeof *err);
-        size_t len = ntohs(oh->length);
-
-        memcpy(err->ofp_msg_data, oh, MIN(len, sizeof err->ofp_msg_data));
-        ovs_list_push_back(errors, &err->list_node);
-    }
-}
-
 static int
 vconn_recv_xid__(struct vconn *vconn, ovs_be32 xid, struct ofpbuf **replyp,
                  struct ovs_list *errors)
@@ -781,13 +769,13 @@ vconn_recv_xid__(struct vconn *vconn, ovs_be32 xid, struct ofpbuf **replyp,
 
         error = ofptype_decode(&type, oh);
         if (!error && type == OFPTYPE_ERROR) {
-            vconn_add_bundle_error(oh, errors);
+            ovs_list_push_back(errors, &reply->list_node);
         } else {
             VLOG_DBG_RL(&bad_ofmsg_rl, "%s: received reply with xid %08"PRIx32
                         " != expected %08"PRIx32,
                         vconn->name, ntohl(recv_xid), ntohl(xid));
+            ofpbuf_delete(reply);
         }
-        ofpbuf_delete(reply);
     }
 }
 
@@ -960,7 +948,8 @@ vconn_bundle_reply_validate(struct ofpbuf *reply,
     }
 
     if (type == OFPTYPE_ERROR) {
-        vconn_add_bundle_error(oh, errors);
+        struct ofpbuf *copy = ofpbuf_clone(reply);
+        ovs_list_push_back(errors, &copy->list_node);
         return ofperr_decode_msg(oh, NULL);
     }
     if (type != OFPTYPE_BUNDLE_CONTROL) {
@@ -1032,13 +1021,13 @@ vconn_recv_error(struct vconn *vconn, struct ovs_list *errors)
             oh = reply->data;
             ofperr = ofptype_decode(&type, oh);
             if (!ofperr && type == OFPTYPE_ERROR) {
-                vconn_add_bundle_error(oh, errors);
+                ovs_list_push_back(errors, &reply->list_node);
             } else {
                 VLOG_DBG_RL(&bad_ofmsg_rl,
                             "%s: received unexpected reply with xid %08"PRIx32,
                             vconn->name, ntohl(oh->xid));
+                ofpbuf_delete(reply);
             }
-            ofpbuf_delete(reply);
         }
     } while (!error);
 }
@@ -1091,6 +1080,8 @@ vconn_bundle_add_msg(struct vconn *vconn, struct ofputil_bundle_ctrl_msg *bc,
     return error;
 }
 
+/* Appends ofpbufs for received errors, if any, to 'errors'.  The caller must
+ * free the received errors. */
 int
 vconn_bundle_transact(struct vconn *vconn, struct ovs_list *requests,
                       uint16_t flags, struct ovs_list *errors)
diff --git a/manpages.mk b/manpages.mk
index fa9e59b07..c18a1abb5 100644
--- a/manpages.mk
+++ b/manpages.mk
@@ -2,13 +2,17 @@
 
 ovn/utilities/ovn-sbctl.8: \
 	ovn/utilities/ovn-sbctl.8.in \
+	lib/common.man \
 	lib/db-ctl-base.man \
 	lib/table.man \
+	lib/vlog.man \
 	ovsdb/remote-active.man \
 	ovsdb/remote-passive.man
 ovn/utilities/ovn-sbctl.8.in:
+lib/common.man:
 lib/db-ctl-base.man:
 lib/table.man:
+lib/vlog.man:
 ovsdb/remote-active.man:
 ovsdb/remote-passive.man:
 
diff --git a/ofproto/bond.c b/ofproto/bond.c
index 1d0c3ce3f..dbcba9acf 100644
--- a/ofproto/bond.c
+++ b/ofproto/bond.c
@@ -187,6 +187,7 @@ static struct bond_slave *choose_output_slave(const struct bond *,
                                               struct flow_wildcards *,
                                               uint16_t vlan)
     OVS_REQ_RDLOCK(rwlock);
+static void update_recirc_rules__(struct bond *bond);
 
 /* Attempts to parse 's' as the name of a bond balancing mode.  If successful,
  * stores the mode in '*balance' and returns true.  Otherwise returns false
@@ -239,6 +240,9 @@ bond_create(const struct bond_settings *s, struct ofproto_dpif *ofproto)
     ovs_refcount_init(&bond->ref_cnt);
     hmap_init(&bond->pr_rule_ops);
 
+    bond->active_slave_mac = eth_addr_zero;
+    bond->active_slave_changed = false;
+
     bond_reconfigure(bond, s);
     return bond;
 }
@@ -258,7 +262,6 @@ bond_ref(const struct bond *bond_)
 void
 bond_unref(struct bond *bond)
 {
-    struct bond_pr_rule_op *pr_op;
     struct bond_slave *slave;
 
     if (!bond || ovs_refcount_unref_relaxed(&bond->ref_cnt) != 1) {
@@ -277,18 +280,18 @@ bond_unref(struct bond *bond)
     hmap_destroy(&bond->slaves);
 
     ovs_mutex_destroy(&bond->mutex);
-    free(bond->hash);
-    free(bond->name);
-
-    HMAP_FOR_EACH_POP (pr_op, hmap_node, &bond->pr_rule_ops) {
-        free(pr_op);
-    }
-    hmap_destroy(&bond->pr_rule_ops);
 
+    /* Free bond resources. Remove existing post recirc rules. */
     if (bond->recirc_id) {
         recirc_free_id(bond->recirc_id);
+        bond->recirc_id = 0;
     }
+    free(bond->hash);
+    bond->hash = NULL;
+    update_recirc_rules__(bond);
 
+    hmap_destroy(&bond->pr_rule_ops);
+    free(bond->name);
     free(bond);
 }
 
@@ -316,9 +319,17 @@ add_pr_rule(struct bond *bond, const struct match *match,
     hmap_insert(&bond->pr_rule_ops, &pr_op->hmap_node, hash);
 }
 
+/* This function should almost never be called directly.
+ * 'update_recirc_rules()' should be called instead.  Since
+ * this function modifies 'bond->pr_rule_ops', it is only
+ * safe when 'rwlock' is held.
+ *
+ * However, when the 'bond' is the only reference in the system,
+ * calling this function avoid acquiring lock only to satisfy
+ * lock annotation. Currently, only 'bond_unref()' calls
+ * this function directly.  */
 static void
-update_recirc_rules(struct bond *bond)
-    OVS_REQ_WRLOCK(rwlock)
+update_recirc_rules__(struct bond *bond)
 {
     struct match match;
     struct bond_pr_rule_op *pr_op, *next_op;
@@ -388,6 +399,12 @@ update_recirc_rules(struct bond *bond)
     ofpbuf_uninit(&ofpacts);
 }
 
+static void
+update_recirc_rules(struct bond *bond)
+    OVS_REQ_RDLOCK(rwlock)
+{
+    update_recirc_rules__(bond);
+}
 
 /* Updates 'bond''s overall configuration to 's'.
  *
@@ -454,9 +471,6 @@ bond_reconfigure(struct bond *bond, const struct bond_settings *s)
         bond_entry_reset(bond);
     }
 
-    bond->active_slave_mac = s->active_slave_mac;
-    bond->active_slave_changed = false;
-
     ovs_rwlock_unlock(&rwlock);
     return revalidate;
 }
@@ -485,10 +499,13 @@ bond_find_slave_by_mac(const struct bond *bond, const struct eth_addr mac)
 static void
 bond_active_slave_changed(struct bond *bond)
 {
-    struct eth_addr mac;
-
-    netdev_get_etheraddr(bond->active_slave->netdev, &mac);
-    bond->active_slave_mac = mac;
+    if (bond->active_slave) {
+        struct eth_addr mac;
+        netdev_get_etheraddr(bond->active_slave->netdev, &mac);
+        bond->active_slave_mac = mac;
+    } else {
+        bond->active_slave_mac = eth_addr_zero;
+    }
     bond->active_slave_changed = true;
     seq_change(connectivity_seq_get());
 }
@@ -906,17 +923,16 @@ bool
 bond_may_recirc(const struct bond *bond, uint32_t *recirc_id,
                 uint32_t *hash_bias)
 {
-    if (bond->balance == BM_TCP && bond->recirc_id) {
-        if (recirc_id) {
-            *recirc_id = bond->recirc_id;
-        }
-        if (hash_bias) {
-            *hash_bias = bond->basis;
-        }
-        return true;
-    } else {
-        return false;
+    bool may_recirc = bond->balance == BM_TCP && bond->recirc_id;
+
+    if (recirc_id) {
+        *recirc_id = may_recirc ? bond->recirc_id : 0;
     }
+    if (hash_bias) {
+        *hash_bias = may_recirc ? bond->basis : 0;
+    }
+
+    return may_recirc;
 }
 
 static void
@@ -944,12 +960,16 @@ bond_update_post_recirc_rules__(struct bond* bond, const bool force)
 }
 
 void
-bond_update_post_recirc_rules(struct bond* bond, const bool force)
+bond_update_post_recirc_rules(struct bond *bond, uint32_t *recirc_id,
+                              uint32_t *hash_basis)
 {
     ovs_rwlock_wrlock(&rwlock);
-    bond_update_post_recirc_rules__(bond, force);
+    if (bond_may_recirc(bond, recirc_id, hash_basis)) {
+        bond_update_post_recirc_rules__(bond, false);
+    }
     ovs_rwlock_unlock(&rwlock);
 }
+
 
 /* Rebalancing. */
 
@@ -1624,6 +1644,8 @@ bond_entry_reset(struct bond *bond)
     } else {
         free(bond->hash);
         bond->hash = NULL;
+        /* Remove existing post recirc rules. */
+        update_recirc_rules(bond);
     }
 }
 
@@ -1856,6 +1878,7 @@ bond_choose_active_slave(struct bond *bond)
             bond_active_slave_changed(bond);
         }
     } else if (old_active_slave) {
+        bond_active_slave_changed(bond);
         VLOG_INFO_RL(&rl, "bond %s: all interfaces disabled", bond->name);
     }
 }
diff --git a/ofproto/bond.h b/ofproto/bond.h
index 9a5ea9e21..6e1221d23 100644
--- a/ofproto/bond.h
+++ b/ofproto/bond.h
@@ -120,7 +120,8 @@ void bond_rebalance(struct bond *);
  * Bond module pulls stats from those post recirculation rules. If rebalancing
  * is needed, those rules are updated with new output actions.
 */
-void bond_update_post_recirc_rules(struct bond *, const bool force);
+void bond_update_post_recirc_rules(struct bond *, uint32_t *recirc_id,
+                                   uint32_t *hash_basis);
 bool bond_may_recirc(const struct bond *, uint32_t *recirc_id,
                      uint32_t *hash_bias);
 #endif /* bond.h */
diff --git a/ofproto/connmgr.c b/ofproto/connmgr.c
index 8a40bd0c5..cc629a60e 100644
--- a/ofproto/connmgr.c
+++ b/ofproto/connmgr.c
@@ -761,12 +761,12 @@ update_in_band_remotes(struct connmgr *mgr)
         if (!mgr->in_band) {
             in_band_create(mgr->ofproto, mgr->local_port_name, &mgr->in_band);
         }
-        in_band_set_queue(mgr->in_band, mgr->in_band_queue);
     } else {
         /* in_band_run() needs a chance to delete any existing in-band flows.
          * We will destroy mgr->in_band after it's done with that. */
     }
     if (mgr->in_band) {
+        in_band_set_queue(mgr->in_band, mgr->in_band_queue);
         in_band_set_remotes(mgr->in_band, addrs, n_addrs);
     }
 
@@ -2225,22 +2225,22 @@ ofmonitor_flush(struct connmgr *mgr)
     struct ofconn *ofconn;
 
     LIST_FOR_EACH (ofconn, node, &mgr->all_conns) {
-        struct ofpbuf *msg;
+        struct rconn_packet_counter *counter = ofconn->monitor_counter;
 
+        struct ofpbuf *msg;
         LIST_FOR_EACH_POP (msg, list_node, &ofconn->updates) {
-            unsigned int n_bytes;
-
-            ofconn_send(ofconn, msg, ofconn->monitor_counter);
-            n_bytes = rconn_packet_counter_n_bytes(ofconn->monitor_counter);
-            if (!ofconn->monitor_paused && n_bytes > 128 * 1024) {
-                struct ofpbuf *pause;
-
-                COVERAGE_INC(ofmonitor_pause);
-                ofconn->monitor_paused = monitor_seqno++;
-                pause = ofpraw_alloc_xid(OFPRAW_NXT_FLOW_MONITOR_PAUSED,
-                                         OFP10_VERSION, htonl(0), 0);
-                ofconn_send(ofconn, pause, ofconn->monitor_counter);
-            }
+            ofconn_send(ofconn, msg, counter);
+        }
+
+        if (!ofconn->monitor_paused
+            && rconn_packet_counter_n_bytes(counter) > 128 * 1024) {
+            struct ofpbuf *pause;
+
+            COVERAGE_INC(ofmonitor_pause);
+            ofconn->monitor_paused = monitor_seqno++;
+            pause = ofpraw_alloc_xid(OFPRAW_NXT_FLOW_MONITOR_PAUSED,
+                                     OFP10_VERSION, htonl(0), 0);
+            ofconn_send(ofconn, pause, counter);
         }
     }
 }
diff --git a/ofproto/in-band.c b/ofproto/in-band.c
index 4bb47c0b9..3d3675ed0 100644
--- a/ofproto/in-band.c
+++ b/ofproto/in-band.c
@@ -119,9 +119,11 @@ refresh_remote(struct in_band *ib, struct in_band_remote *r)
     retval = netdev_get_next_hop(ib->local_netdev, &r->remote_addr.sin_addr,
                                  &next_hop_inaddr, &next_hop_dev);
     if (retval) {
-        VLOG_WARN("%s: cannot find route for controller ("IP_FMT"): %s",
-                  ib->ofproto->name, IP_ARGS(r->remote_addr.sin_addr.s_addr),
-                  ovs_strerror(retval));
+        VLOG_WARN_RL(&rl, "%s: cannot find route for controller "
+                     "("IP_FMT"): %s",
+                     ib->ofproto->name,
+                     IP_ARGS(r->remote_addr.sin_addr.s_addr),
+                     ovs_strerror(retval));
         return 1;
     }
     if (!next_hop_inaddr.s_addr) {
diff --git a/ofproto/netflow.c b/ofproto/netflow.c
index 55f781497..cd4aa7e17 100644
--- a/ofproto/netflow.c
+++ b/ofproto/netflow.c
@@ -413,6 +413,14 @@ netflow_unref(struct netflow *nf)
         atomic_count_dec(&netflow_count);
         collectors_destroy(nf->collectors);
         ofpbuf_uninit(&nf->packet);
+
+        struct netflow_flow *nf_flow, *next;
+        HMAP_FOR_EACH_SAFE (nf_flow, next, hmap_node, &nf->flows) {
+            hmap_remove(&nf->flows, &nf_flow->hmap_node);
+            free(nf_flow);
+        }
+        hmap_destroy(&nf->flows);
+
         free(nf);
     }
 }
diff --git a/ofproto/ofproto-dpif-ipfix.c b/ofproto/ofproto-dpif-ipfix.c
index abea49249..adf1e7725 100644
--- a/ofproto/ofproto-dpif-ipfix.c
+++ b/ofproto/ofproto-dpif-ipfix.c
@@ -868,6 +868,15 @@ dpif_ipfix_flow_exporter_set_options(
     return true;
 }
 
+static void
+remove_flow_exporter(struct dpif_ipfix *di,
+                     struct dpif_ipfix_flow_exporter_map_node *node)
+{
+    hmap_remove(&di->flow_exporter_map, &node->node);
+    dpif_ipfix_flow_exporter_destroy(&node->exporter);
+    free(node);
+}
+
 void
 dpif_ipfix_set_options(
     struct dpif_ipfix *di,
@@ -878,7 +887,6 @@ dpif_ipfix_set_options(
     int i;
     struct ofproto_ipfix_flow_exporter_options *options;
     struct dpif_ipfix_flow_exporter_map_node *node, *next;
-    size_t n_broken_flow_exporters_options = 0;
 
     ovs_mutex_lock(&mutex);
     dpif_ipfix_bridge_exporter_set_options(&di->bridge_exporter,
@@ -897,38 +905,29 @@ dpif_ipfix_set_options(
                         hash_int(options->collector_set_id, 0));
         }
         if (!dpif_ipfix_flow_exporter_set_options(&node->exporter, options)) {
-            n_broken_flow_exporters_options++;
+            remove_flow_exporter(di, node);
         }
         options++;
     }
 
-    ovs_assert(hmap_count(&di->flow_exporter_map) >=
-               (n_flow_exporters_options - n_broken_flow_exporters_options));
-
     /* Remove dropped flow exporters, if any needs to be removed. */
-    if (hmap_count(&di->flow_exporter_map) > n_flow_exporters_options) {
-        HMAP_FOR_EACH_SAFE (node, next, node, &di->flow_exporter_map) {
-            /* This is slow but doesn't take any extra memory, and
-             * this table is not supposed to contain many rows anyway. */
-            options = (struct ofproto_ipfix_flow_exporter_options *)
-                flow_exporters_options;
-            for (i = 0; i < n_flow_exporters_options; i++) {
-              if (node->exporter.options->collector_set_id
-                  == options->collector_set_id) {
-                  break;
-              }
-              options++;
-            }
-            if (i == n_flow_exporters_options) {  // Not found.
-                hmap_remove(&di->flow_exporter_map, &node->node);
-                dpif_ipfix_flow_exporter_destroy(&node->exporter);
-                free(node);
+    HMAP_FOR_EACH_SAFE (node, next, node, &di->flow_exporter_map) {
+        /* This is slow but doesn't take any extra memory, and
+         * this table is not supposed to contain many rows anyway. */
+        options = (struct ofproto_ipfix_flow_exporter_options *)
+            flow_exporters_options;
+        for (i = 0; i < n_flow_exporters_options; i++) {
+            if (node->exporter.options->collector_set_id
+                == options->collector_set_id) {
+                break;
             }
+            options++;
+        }
+        if (i == n_flow_exporters_options) {  // Not found.
+            remove_flow_exporter(di, node);
         }
     }
 
-    ovs_assert(hmap_count(&di->flow_exporter_map) ==
-               (n_flow_exporters_options - n_broken_flow_exporters_options));
     ovs_mutex_unlock(&mutex);
 }
 
diff --git a/ofproto/ofproto-dpif-mirror.c b/ofproto/ofproto-dpif-mirror.c
index 675adf300..4659a7d93 100644
--- a/ofproto/ofproto-dpif-mirror.c
+++ b/ofproto/ofproto-dpif-mirror.c
@@ -18,7 +18,7 @@
 
 #include <errno.h>
 
-#include "openvswitch/hmap.h"
+#include "cmap.h"
 #include "hmapx.h"
 #include "ofproto.h"
 #include "vlan-bitmap.h"
@@ -31,7 +31,7 @@ BUILD_ASSERT_DECL(sizeof(mirror_mask_t) * CHAR_BIT >= MAX_MIRRORS);
 
 struct mbridge {
     struct mirror *mirrors[MAX_MIRRORS];
-    struct hmap mbundles;
+    struct cmap mbundles;
 
     bool need_revalidate;
     bool has_mirrors;
@@ -40,7 +40,7 @@ struct mbridge {
 };
 
 struct mbundle {
-    struct hmap_node hmap_node; /* In parent 'mbridge' map. */
+    struct cmap_node cmap_node; /* In parent 'mbridge' map. */
     struct ofbundle *ofbundle;
 
     mirror_mask_t src_mirrors;  /* Mirrors triggered when packet received. */
@@ -56,7 +56,12 @@ struct mirror {
     /* Selection criteria. */
     struct hmapx srcs;          /* Contains "struct mbundle*"s. */
     struct hmapx dsts;          /* Contains "struct mbundle*"s. */
-    unsigned long *vlans;       /* Bitmap of chosen VLANs, NULL selects all. */
+
+    /* This is accessed by handler threads assuming RCU protection (see
+     * mirror_get()), but can be manipulated by mirror_set() without any
+     * explicit synchronization. */
+    OVSRCU_TYPE(unsigned long *) vlans;       /* Bitmap of chosen VLANs, NULL
+                                               * selects all. */
 
     /* Output (exactly one of out == NULL and out_vlan == -1 is true). */
     struct mbundle *out;        /* Output port or NULL. */
@@ -86,7 +91,7 @@ mbridge_create(void)
     mbridge = xzalloc(sizeof *mbridge);
     ovs_refcount_init(&mbridge->ref_cnt);
 
-    hmap_init(&mbridge->mbundles);
+    cmap_init(&mbridge->mbundles);
     return mbridge;
 }
 
@@ -103,7 +108,7 @@ mbridge_ref(const struct mbridge *mbridge_)
 void
 mbridge_unref(struct mbridge *mbridge)
 {
-    struct mbundle *mbundle, *next;
+    struct mbundle *mbundle;
     size_t i;
 
     if (!mbridge) {
@@ -117,12 +122,12 @@ mbridge_unref(struct mbridge *mbridge)
             }
         }
 
-        HMAP_FOR_EACH_SAFE (mbundle, next, hmap_node, &mbridge->mbundles) {
+        CMAP_FOR_EACH (mbundle, cmap_node, &mbridge->mbundles) {
             mbridge_unregister_bundle(mbridge, mbundle->ofbundle);
         }
 
-        hmap_destroy(&mbridge->mbundles);
-        free(mbridge);
+        cmap_destroy(&mbridge->mbundles);
+        ovsrcu_postpone(free, mbridge);
     }
 }
 
@@ -149,7 +154,7 @@ mbridge_register_bundle(struct mbridge *mbridge, struct ofbundle *ofbundle)
 
     mbundle = xzalloc(sizeof *mbundle);
     mbundle->ofbundle = ofbundle;
-    hmap_insert(&mbridge->mbundles, &mbundle->hmap_node,
+    cmap_insert(&mbridge->mbundles, &mbundle->cmap_node,
                 hash_pointer(ofbundle, 0));
 }
 
@@ -175,8 +180,9 @@ mbridge_unregister_bundle(struct mbridge *mbridge, struct ofbundle *ofbundle)
         }
     }
 
-    hmap_remove(&mbridge->mbundles, &mbundle->hmap_node);
-    free(mbundle);
+    cmap_remove(&mbridge->mbundles, &mbundle->cmap_node,
+                hash_pointer(ofbundle, 0));
+    ovsrcu_postpone(free, mbundle);
 }
 
 mirror_mask_t
@@ -233,6 +239,8 @@ mirror_set(struct mbridge *mbridge, void *aux, const char *name,
         mirror->snaplen = 0;
     }
 
+    unsigned long *vlans = ovsrcu_get(unsigned long *, &mirror->vlans);
+
     /* Get the new configuration. */
     if (out_bundle) {
         out = mbundle_lookup(mbridge, out_bundle);
@@ -250,23 +258,28 @@ mirror_set(struct mbridge *mbridge, void *aux, const char *name,
     /* If the configuration has not changed, do nothing. */
     if (hmapx_equals(&srcs_map, &mirror->srcs)
         && hmapx_equals(&dsts_map, &mirror->dsts)
-        && vlan_bitmap_equal(mirror->vlans, src_vlans)
+        && vlan_bitmap_equal(vlans, src_vlans)
         && mirror->out == out
-        && mirror->out_vlan == out_vlan)
+        && mirror->out_vlan == out_vlan
+        && mirror->snaplen == snaplen)
     {
         hmapx_destroy(&srcs_map);
         hmapx_destroy(&dsts_map);
         return 0;
     }
 
+    /* XXX: Not sure if these need to be thread safe. */
     hmapx_swap(&srcs_map, &mirror->srcs);
     hmapx_destroy(&srcs_map);
 
     hmapx_swap(&dsts_map, &mirror->dsts);
     hmapx_destroy(&dsts_map);
 
-    free(mirror->vlans);
-    mirror->vlans = vlan_bitmap_clone(src_vlans);
+    if (vlans || src_vlans) {
+        ovsrcu_postpone(free, vlans);
+        vlans = vlan_bitmap_clone(src_vlans);
+        ovsrcu_set(&mirror->vlans, vlans);
+    }
 
     mirror->out = out;
     mirror->out_vlan = out_vlan;
@@ -274,7 +287,7 @@ mirror_set(struct mbridge *mbridge, void *aux, const char *name,
 
     /* Update mbundles. */
     mirror_bit = MIRROR_MASK_C(1) << mirror->idx;
-    HMAP_FOR_EACH (mbundle, hmap_node, &mirror->mbridge->mbundles) {
+    CMAP_FOR_EACH (mbundle, cmap_node, &mirror->mbridge->mbundles) {
         if (hmapx_contains(&mirror->srcs, mbundle)) {
             mbundle->src_mirrors |= mirror_bit;
         } else {
@@ -313,7 +326,7 @@ mirror_destroy(struct mbridge *mbridge, void *aux)
     }
 
     mirror_bit = MIRROR_MASK_C(1) << mirror->idx;
-    HMAP_FOR_EACH (mbundle, hmap_node, &mbridge->mbundles) {
+    CMAP_FOR_EACH (mbundle, cmap_node, &mbridge->mbundles) {
         mbundle->src_mirrors &= ~mirror_bit;
         mbundle->dst_mirrors &= ~mirror_bit;
         mbundle->mirror_out &= ~mirror_bit;
@@ -321,10 +334,16 @@ mirror_destroy(struct mbridge *mbridge, void *aux)
 
     hmapx_destroy(&mirror->srcs);
     hmapx_destroy(&mirror->dsts);
-    free(mirror->vlans);
+
+    unsigned long *vlans = ovsrcu_get(unsigned long *, &mirror->vlans);
+    if (vlans) {
+        ovsrcu_postpone(free, vlans);
+    }
 
     mbridge->mirrors[mirror->idx] = NULL;
-    free(mirror);
+    /* mirror_get() might have just read the pointer, so we must postpone the
+     * free. */
+    ovsrcu_postpone(free, mirror);
 
     mirror_update_dups(mbridge);
 
@@ -377,6 +396,9 @@ mirror_update_stats(struct mbridge *mbridge, mirror_mask_t mirrors,
             continue;
         }
 
+        /* XXX: This is not thread safe, yet we are calling these from the
+         * handler and revalidation threads.  But then, maybe these stats do
+         * not need to be very accurate. */
         m->packet_count += packets;
         m->byte_count += bytes;
     }
@@ -390,7 +412,10 @@ mirror_update_stats(struct mbridge *mbridge, mirror_mask_t mirrors,
  * in which a 1-bit indicates that the mirror includes a particular VLAN,
  * '*dup_mirrors' receives a bitmap of mirrors whose output duplicates mirror
  * 'index', '*out' receives the output ofbundle (if any), and '*out_vlan'
- * receives the output VLAN (if any). */
+ * receives the output VLAN (if any).
+ *
+ * Everything returned here is assumed to be RCU protected.
+ */
 bool
 mirror_get(struct mbridge *mbridge, int index, const unsigned long **vlans,
            mirror_mask_t *dup_mirrors, struct ofbundle **out,
@@ -406,8 +431,10 @@ mirror_get(struct mbridge *mbridge, int index, const unsigned long **vlans,
     if (!mirror) {
         return false;
     }
+    /* Assume 'mirror' is RCU protected, i.e., it will not be freed until this
+     * thread quiesces. */
 
-    *vlans = mirror->vlans;
+    *vlans = ovsrcu_get(unsigned long *, &mirror->vlans);
     *dup_mirrors = mirror->dup_mirrors;
     *out = mirror->out ? mirror->out->ofbundle : NULL;
     *out_vlan = mirror->out_vlan;
@@ -421,9 +448,9 @@ static struct mbundle *
 mbundle_lookup(const struct mbridge *mbridge, struct ofbundle *ofbundle)
 {
     struct mbundle *mbundle;
+    uint32_t hash = hash_pointer(ofbundle, 0);
 
-    HMAP_FOR_EACH_IN_BUCKET (mbundle, hmap_node, hash_pointer(ofbundle, 0),
-                             &mbridge->mbundles) {
+    CMAP_FOR_EACH_WITH_HASH (mbundle, cmap_node, hash, &mbridge->mbundles) {
         if (mbundle->ofbundle == ofbundle) {
             return mbundle;
         }
@@ -431,7 +458,7 @@ mbundle_lookup(const struct mbridge *mbridge, struct ofbundle *ofbundle)
     return NULL;
 }
 
-/* Looks up each of the 'n_ofbundlees' pointers in 'ofbundlees' as mbundles and
+/* Looks up each of the 'n_ofbundles' pointers in 'ofbundles' as mbundles and
  * adds the ones that are found to 'mbundles'. */
 static void
 mbundle_lookup_multiple(const struct mbridge *mbridge,
diff --git a/ofproto/ofproto-dpif-mirror.h b/ofproto/ofproto-dpif-mirror.h
index b00536ac7..eed63ec4a 100644
--- a/ofproto/ofproto-dpif-mirror.h
+++ b/ofproto/ofproto-dpif-mirror.h
@@ -25,19 +25,31 @@ typedef uint32_t mirror_mask_t;
 struct ofproto_dpif;
 struct ofbundle;
 
-struct mbridge *mbridge_create(void);
+/* The following functions are used by handler threads without any locking,
+ * assuming RCU protection. */
+
 struct mbridge *mbridge_ref(const struct mbridge *);
 void mbridge_unref(struct mbridge *);
 bool mbridge_has_mirrors(struct mbridge *);
-bool mbridge_need_revalidate(struct mbridge *);
-
-void mbridge_register_bundle(struct mbridge *, struct ofbundle *);
-void mbridge_unregister_bundle(struct mbridge *, struct ofbundle *);
 
 mirror_mask_t mirror_bundle_out(struct mbridge *, struct ofbundle *);
 mirror_mask_t mirror_bundle_src(struct mbridge *, struct ofbundle *);
 mirror_mask_t mirror_bundle_dst(struct mbridge *, struct ofbundle *);
 
+void mirror_update_stats(struct mbridge*, mirror_mask_t, uint64_t packets,
+                         uint64_t bytes);
+bool mirror_get(struct mbridge *, int index, const unsigned long **vlans,
+                mirror_mask_t *dup_mirrors, struct ofbundle **out,
+                int *snaplen, int *out_vlan);
+
+/* The remaining functions are assumed to be called by the main thread only. */
+
+struct mbridge *mbridge_create(void);
+bool mbridge_need_revalidate(struct mbridge *);
+
+void mbridge_register_bundle(struct mbridge *, struct ofbundle *);
+void mbridge_unregister_bundle(struct mbridge *, struct ofbundle *);
+
 int mirror_set(struct mbridge *, void *aux, const char *name,
                struct ofbundle **srcs, size_t n_srcs,
                struct ofbundle **dsts, size_t n_dsts,
@@ -46,10 +58,5 @@ int mirror_set(struct mbridge *, void *aux, const char *name,
 void mirror_destroy(struct mbridge *, void *aux);
 int mirror_get_stats(struct mbridge *, void *aux, uint64_t *packets,
                      uint64_t *bytes);
-void mirror_update_stats(struct mbridge*, mirror_mask_t, uint64_t packets,
-                         uint64_t bytes);
-bool mirror_get(struct mbridge *, int index, const unsigned long **vlans,
-                mirror_mask_t *dup_mirrors, struct ofbundle **out,
-                int *snaplen, int *out_vlan);
 
 #endif /* ofproto-dpif-mirror.h */
diff --git a/ofproto/ofproto-dpif-upcall.c b/ofproto/ofproto-dpif-upcall.c
index bffbf3561..45e8eb304 100644
--- a/ofproto/ofproto-dpif-upcall.c
+++ b/ofproto/ofproto-dpif-upcall.c
@@ -1205,7 +1205,7 @@ upcall_cb(const struct dp_packet *packet, const struct flow *flow, ovs_u128 *ufi
                    upcall.put_actions.size);
     }
 
-    if (OVS_UNLIKELY(!megaflow)) {
+    if (OVS_UNLIKELY(!megaflow && wc)) {
         flow_wildcards_init_for_packet(wc, flow);
     }
 
@@ -1501,7 +1501,7 @@ ukey_create_from_upcall(struct upcall *upcall, struct flow_wildcards *wc)
     bool megaflow;
     struct odp_flow_key_parms odp_parms = {
         .flow = upcall->flow,
-        .mask = &wc->masks,
+        .mask = wc ? &wc->masks : NULL,
     };
 
     odp_parms.support = ofproto_dpif_get_support(upcall->ofproto)->odp;
@@ -1516,7 +1516,7 @@ ukey_create_from_upcall(struct upcall *upcall, struct flow_wildcards *wc)
 
     atomic_read_relaxed(&enable_megaflows, &megaflow);
     ofpbuf_use_stack(&maskbuf, &maskstub, sizeof maskstub);
-    if (megaflow) {
+    if (megaflow && wc) {
         odp_parms.key_buf = &keybuf;
         odp_flow_key_from_mask(&odp_parms, &maskbuf);
     }
@@ -1561,20 +1561,20 @@ ukey_create_from_dpif_flow(const struct udpif *udpif,
      * relies on OVS userspace internal state, we need to delete all old
      * datapath flows with either a non-zero recirc_id in the key, or any
      * recirculation actions upon OVS restart. */
-    NL_ATTR_FOR_EACH_UNSAFE (a, left, flow->key, flow->key_len) {
+    NL_ATTR_FOR_EACH (a, left, flow->key, flow->key_len) {
         if (nl_attr_type(a) == OVS_KEY_ATTR_RECIRC_ID
             && nl_attr_get_u32(a) != 0) {
             return EINVAL;
         }
     }
-    NL_ATTR_FOR_EACH_UNSAFE (a, left, flow->actions, flow->actions_len) {
+    NL_ATTR_FOR_EACH (a, left, flow->actions, flow->actions_len) {
         if (nl_attr_type(a) == OVS_ACTION_ATTR_RECIRC) {
             return EINVAL;
         }
     }
 
     dump_seq = seq_read(udpif->dump_seq);
-    reval_seq = seq_read(udpif->reval_seq);
+    reval_seq = seq_read(udpif->reval_seq) - 1; /* Ensure revalidation. */
     ofpbuf_use_const(&actions, &flow->actions, flow->actions_len);
     *ukey = ukey_create__(flow->key, flow->key_len,
                           flow->mask, flow->mask_len, flow->ufid_present,
@@ -2462,7 +2462,7 @@ upcall_unixctl_enable_ufid(struct unixctl_conn *conn, int argc OVS_UNUSED,
 static void
 upcall_unixctl_set_flow_limit(struct unixctl_conn *conn,
                               int argc OVS_UNUSED,
-                              const char *argv[] OVS_UNUSED,
+                              const char *argv[],
                               void *aux OVS_UNUSED)
 {
     struct ds ds = DS_EMPTY_INITIALIZER;
diff --git a/ofproto/ofproto-dpif-xlate.c b/ofproto/ofproto-dpif-xlate.c
index a17047d2d..ecd1feba4 100644
--- a/ofproto/ofproto-dpif-xlate.c
+++ b/ofproto/ofproto-dpif-xlate.c
@@ -30,6 +30,7 @@
 #include "cfm.h"
 #include "connmgr.h"
 #include "coverage.h"
+#include "csum.h"
 #include "dp-packet.h"
 #include "dpif.h"
 #include "in-band.h"
@@ -1019,6 +1020,7 @@ xlate_xbridge_remove(struct xlate_cfg *xcfg, struct xbridge *xbridge)
     mbridge_unref(xbridge->mbridge);
     dpif_sflow_unref(xbridge->sflow);
     dpif_ipfix_unref(xbridge->ipfix);
+    netflow_unref(xbridge->netflow);
     stp_unref(xbridge->stp);
     rstp_unref(xbridge->rstp);
     hmap_destroy(&xbridge->xports);
@@ -1658,7 +1660,7 @@ lookup_input_bundle(const struct xbridge *xbridge, ofp_port_t in_port,
         static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);
 
         VLOG_WARN_RL(&rl, "bridge %s: received packet on unknown "
-                     "port %"PRIu16, xbridge->name, in_port);
+                     "port %"PRIu32, xbridge->name, in_port);
     }
     return NULL;
 }
@@ -1902,15 +1904,23 @@ output_normal(struct xlate_ctx *ctx, const struct xbundle *out_xbundle,
         struct flow_wildcards *wc = ctx->wc;
         struct ofport_dpif *ofport;
 
-        if (ctx->xbridge->support.odp.recirc) {
-            use_recirc = bond_may_recirc(
-                out_xbundle->bond, &xr.recirc_id, &xr.hash_basis);
-
-            if (use_recirc) {
-                /* Only TCP mode uses recirculation. */
+        if (ctx->xbridge->support.odp.recirc
+            && bond_may_recirc(out_xbundle->bond, NULL, NULL)) {
+            /* To avoid unnecessary locking, bond_may_recirc() is first
+             * called outside of the 'rwlock'. After acquiring the lock,
+             * bond_update_post_recirc_rules() will check again to make
+             * sure bond configuration has not been changed.
+             *
+             * In case recirculation is not actually in use, 'xr.recirc_id'
+             * will be set to '0', Since a valid 'recirc_id' can
+             * not be zero.  */
+            bond_update_post_recirc_rules(out_xbundle->bond,
+                                          &xr.recirc_id,
+                                          &xr.hash_basis);
+            if (xr.recirc_id) {
+                /* Use recirculation instead of output. */
+                use_recirc = true;
                 xr.hash_alg = OVS_HASH_ALG_L4;
-                bond_update_post_recirc_rules(out_xbundle->bond, false);
-
                 /* Recirculation does not require unmasking hash fields. */
                 wc = NULL;
             }
@@ -2173,9 +2183,20 @@ update_mcast_snooping_table4__(const struct xbridge *xbridge,
     OVS_REQ_WRLOCK(ms->rwlock)
 {
     static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(60, 30);
+    const struct igmp_header *igmp;
     int count;
+    size_t offset;
     ovs_be32 ip4 = flow->igmp_group_ip4;
 
+    offset = (char *) dp_packet_l4(packet) - (char *) dp_packet_data(packet);
+    igmp = dp_packet_at(packet, offset, IGMP_HEADER_LEN);
+    if (!igmp || csum(igmp, dp_packet_l4_size(packet)) != 0) {
+        VLOG_DBG_RL(&rl, "bridge %s: multicast snooping received bad IGMP "
+                    "checksum on port %s in VLAN %d",
+                    xbridge->name, in_xbundle->name, vlan);
+        return;
+    }
+
     switch (ntohs(flow->tp_src)) {
     case IGMP_HOST_MEMBERSHIP_REPORT:
     case IGMPV2_HOST_MEMBERSHIP_REPORT:
@@ -2221,7 +2242,22 @@ update_mcast_snooping_table6__(const struct xbridge *xbridge,
     OVS_REQ_WRLOCK(ms->rwlock)
 {
     static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(60, 30);
+    const struct mld_header *mld;
     int count;
+    size_t offset;
+
+    offset = (char *) dp_packet_l4(packet) - (char *) dp_packet_data(packet);
+    mld = dp_packet_at(packet, offset, MLD_HEADER_LEN);
+
+    if (!mld ||
+        packet_csum_upperlayer6(dp_packet_l3(packet),
+                                mld, IPPROTO_ICMPV6,
+                                dp_packet_l4_size(packet)) != 0) {
+        VLOG_DBG_RL(&rl, "bridge %s: multicast snooping received bad MLD "
+                    "checksum on port %s in VLAN %d",
+                    xbridge->name, in_xbundle->name, vlan);
+        return;
+    }
 
     switch (ntohs(flow->tp_src)) {
     case MLD_QUERY:
@@ -2326,11 +2362,14 @@ xlate_normal_mcast_send_mrouters(struct xlate_ctx *ctx,
     xcfg = ovsrcu_get(struct xlate_cfg *, &xcfgp);
     LIST_FOR_EACH(mrouter, mrouter_node, &ms->mrouter_lru) {
         mcast_xbundle = xbundle_lookup(xcfg, mrouter->port);
-        if (mcast_xbundle && mcast_xbundle != in_xbundle) {
+        if (mcast_xbundle && mcast_xbundle != in_xbundle
+            && mrouter->vlan == vlan) {
             xlate_report(ctx, "forwarding to mcast router port");
             output_normal(ctx, mcast_xbundle, vlan);
         } else if (!mcast_xbundle) {
             xlate_report(ctx, "mcast router port is unknown, dropping");
+        } else if (mrouter->vlan != vlan) {
+            xlate_report(ctx, "mcast router is on another vlan, dropping");
         } else {
             xlate_report(ctx, "mcast router port is input port, dropping");
         }
@@ -2502,6 +2541,13 @@ xlate_normal(struct xlate_ctx *ctx)
         struct mcast_group *grp = NULL;
 
         if (is_igmp(flow, wc)) {
+            /*
+             * IGMP packets need to take the slow path, in order to be
+             * processed for mdb updates. That will prevent expires
+             * firing off even after hosts have sent reports.
+             */
+            ctx->xout->slow |= SLOW_ACTION;
+
             memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);
             if (mcast_snooping_is_membership(flow->tp_src) ||
                 mcast_snooping_is_query(flow->tp_src)) {
@@ -2509,12 +2555,6 @@ xlate_normal(struct xlate_ctx *ctx)
                     update_mcast_snooping_table(ctx->xbridge, flow, vlan,
                                                 in_xbundle, ctx->xin->packet);
                 }
-                /*
-                 * IGMP packets need to take the slow path, in order to be
-                 * processed for mdb updates. That will prevent expires
-                 * firing off even after hosts have sent reports.
-                 */
-                ctx->xout->slow |= SLOW_ACTION;
             }
 
             if (mcast_snooping_is_membership(flow->tp_src)) {
@@ -3036,6 +3076,10 @@ compose_output_action__(struct xlate_ctx *ctx, ofp_port_t ofp_port,
                 }
                 return;
             }
+        } else if ((xport->cfm && cfm_should_process_flow(xport->cfm, flow, wc))
+                   || (xport->bfd && bfd_should_process_flow(xport->bfd, flow,
+                                                             wc))) {
+            /* Pass; STP should not block link health detection. */
         } else if (!xport_stp_forward_state(xport) ||
                    !xport_rstp_forward_state(xport)) {
             if (ctx->xbridge->stp != NULL) {
@@ -3860,7 +3904,8 @@ compose_mpls_push_action(struct xlate_ctx *ctx, struct ofpact_push_mpls *mpls)
         return;
     }
 
-    flow_push_mpls(flow, n, mpls->ethertype, ctx->wc);
+    /* Update flow's MPLS stack, and clear L3/4 fields to mark them invalid. */
+    flow_push_mpls(flow, n, mpls->ethertype, ctx->wc, true);
 }
 
 static void
@@ -4598,9 +4643,9 @@ put_ct_nat(struct xlate_ctx *ctx)
 static void
 compose_conntrack_action(struct xlate_ctx *ctx, struct ofpact_conntrack *ofc)
 {
-    ovs_u128 old_ct_label = ctx->base_flow.ct_label;
+    ovs_u128 old_ct_label = ctx->xin->flow.ct_label;
     ovs_u128 old_ct_label_mask = ctx->wc->masks.ct_label;
-    uint32_t old_ct_mark = ctx->base_flow.ct_mark;
+    uint32_t old_ct_mark = ctx->xin->flow.ct_mark;
     uint32_t old_ct_mark_mask = ctx->wc->masks.ct_mark;
     size_t ct_offset;
     uint16_t zone;
@@ -4635,9 +4680,9 @@ compose_conntrack_action(struct xlate_ctx *ctx, struct ofpact_conntrack *ofc)
 
     /* Restore the original ct fields in the key. These should only be exposed
      * after recirculation to another table. */
-    ctx->base_flow.ct_mark = old_ct_mark;
+    ctx->xin->flow.ct_mark = old_ct_mark;
     ctx->wc->masks.ct_mark = old_ct_mark_mask;
-    ctx->base_flow.ct_label = old_ct_label;
+    ctx->xin->flow.ct_label = old_ct_label;
     ctx->wc->masks.ct_label = old_ct_label_mask;
 
     if (ofc->recirc_table == NX_CT_RECIRC_NONE) {
@@ -4648,6 +4693,7 @@ compose_conntrack_action(struct xlate_ctx *ctx, struct ofpact_conntrack *ofc)
         /* Use ct_* fields from datapath during recirculation upcall. */
         ctx->conntracked = true;
         compose_recirculate_and_fork(ctx, ofc->recirc_table);
+        ctx->conntracked = false;
     }
 }
 
@@ -5485,6 +5531,7 @@ xlate_actions(struct xlate_in *xin, struct xlate_out *xout)
         ctx.table_id = state->table_id;
         xlate_report(&ctx, "- Resuming from table %"PRIu8, ctx.table_id);
 
+        ctx.conntracked = state->conntracked;
         if (!state->conntracked) {
             clear_conntrack(flow);
         }
diff --git a/ofproto/ofproto-dpif.c b/ofproto/ofproto-dpif.c
index a86dd3f78..d5c8e9287 100644
--- a/ofproto/ofproto-dpif.c
+++ b/ofproto/ofproto-dpif.c
@@ -1510,6 +1510,8 @@ destruct(struct ofproto *ofproto_)
     hmap_destroy(&ofproto->bundles);
     mac_learning_unref(ofproto->ml);
     mcast_snooping_unref(ofproto->ms);
+    stp_unref(ofproto->stp);
+    rstp_unref(ofproto->rstp);
 
     sset_destroy(&ofproto->ports);
     sset_destroy(&ofproto->ghost_ports);
@@ -1715,7 +1717,15 @@ set_tables_version(struct ofproto *ofproto_, ovs_version_t version)
 {
     struct ofproto_dpif *ofproto = ofproto_dpif_cast(ofproto_);
 
-    atomic_store_relaxed(&ofproto->tables_version, version);
+    /* Use memory_order_release to signify that any prior memory accesses can
+     * not be reordered to happen after this atomic store.  This makes sure the
+     * new version is properly set up when the readers can read this 'version'
+     * value. */
+    atomic_store_explicit(&ofproto->tables_version, version,
+                          memory_order_release);
+    /* 'need_revalidate' can be reordered to happen before the atomic_store
+     * above, but it does not matter as this variable is not accessed by other
+     * threads. */
     ofproto->backer->need_revalidate = REV_FLOW_TABLE;
 }
 
@@ -2863,6 +2873,7 @@ bundle_destroy(struct ofbundle *bundle)
     }
 
     bundle_flush_macs(bundle, true);
+    mcast_snooping_flush_bundle(ofproto->ms, bundle);
     hmap_remove(&ofproto->bundles, &bundle->hmap_node);
     free(bundle->name);
     free(bundle->trunks);
@@ -3048,6 +3059,7 @@ bundle_set(struct ofproto *ofproto_, void *aux,
      * everything on this port and force flow revalidation. */
     if (need_flush) {
         bundle_flush_macs(bundle, false);
+        mcast_snooping_flush_bundle(ofproto->ms, bundle);
     }
 
     return 0;
@@ -3906,8 +3918,12 @@ ofproto_dpif_get_tables_version(struct ofproto_dpif *ofproto OVS_UNUSED)
 {
     ovs_version_t version;
 
-    atomic_read_relaxed(&ofproto->tables_version, &version);
-
+    /* Use memory_order_acquire to signify that any following memory accesses
+     * can not be reordered to happen before this atomic read.  This makes sure
+     * all following reads relate to this or a newer version, but never to an
+     * older version. */
+    atomic_read_explicit(&ofproto->tables_version, &version,
+                         memory_order_acquire);
     return version;
 }
 
@@ -4033,7 +4049,7 @@ rule_dpif_lookup_from_table(struct ofproto_dpif *ofproto,
 
             port = ofp_port_to_ofport(ofproto, old_in_port);
             if (!port) {
-                VLOG_WARN_RL(&rl, "packet-in on unknown OpenFlow port %"PRIu16,
+                VLOG_WARN_RL(&rl, "packet-in on unknown OpenFlow port %"PRIu32,
                              old_in_port);
             } else if (!(port->up.pp.config & OFPUTIL_PC_NO_PACKET_IN)) {
                 rule = ofproto->miss_rule;
@@ -5584,6 +5600,8 @@ ofproto_dpif_delete_internal_flow(struct ofproto_dpif *ofproto,
         .match = *match,
         .priority = priority,
         .table_id = TBL_INTERNAL,
+        .out_port = OFPP_ANY,
+        .out_group = OFPG_ANY,
         .flags = OFPUTIL_FF_HIDDEN_FIELDS | OFPUTIL_FF_NO_READONLY,
         .command = OFPFC_DELETE_STRICT,
     };
diff --git a/ofproto/ofproto-provider.h b/ofproto/ofproto-provider.h
index 2964b7444..d5e2144d4 100644
--- a/ofproto/ofproto-provider.h
+++ b/ofproto/ofproto-provider.h
@@ -1891,6 +1891,7 @@ struct ofproto_flow_mod {
     bool modify_cookie;
     /* Fields derived from ofputil_flow_mod. */
     bool modify_may_add_flow;
+    bool modify_keep_counts;
     enum nx_flow_update_event event;
 
     /* These are only used during commit execution.
diff --git a/ofproto/ofproto-unixctl.man b/ofproto/ofproto-unixctl.man
index 53e5549c5..ce4f7a239 100644
--- a/ofproto/ofproto-unixctl.man
+++ b/ofproto/ofproto-unixctl.man
@@ -135,10 +135,3 @@ necessary because the command does not ordinarily imply a particular
 OpenFlow version.  One exception is that, when \fIactions\fR includes
 an action that only OpenFlow 1.1 and later supports (such as
 \fBpush_vlan\fR), \fB\-consistent\fR is automatically enabled.
-.IP "\fBofproto/self\-check\fR [\fIswitch\fR]"
-Runs an internal consistency check on \fIswitch\fR, if specified,
-otherwise on all ofproto instances, and responds with a brief summary
-of the results.  If the summary reports any errors, then the Open
-vSwitch logs should contain more detailed information.  Please pass
-along errors reported by this command to the Open vSwitch developers
-as bugs.
diff --git a/ofproto/ofproto.c b/ofproto/ofproto.c
index d76e91cf2..887a02195 100644
--- a/ofproto/ofproto.c
+++ b/ofproto/ofproto.c
@@ -970,7 +970,7 @@ ofproto_port_set_stp(struct ofproto *ofproto, ofp_port_t ofp_port,
 {
     struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
-        VLOG_WARN("%s: cannot configure STP on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot configure STP on nonexistent port %"PRIu32,
                   ofproto->name, ofp_port);
         return ENODEV;
     }
@@ -992,7 +992,7 @@ ofproto_port_get_stp_status(struct ofproto *ofproto, ofp_port_t ofp_port,
     struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
         VLOG_WARN_RL(&rl, "%s: cannot get STP status on nonexistent "
-                     "port %"PRIu16, ofproto->name, ofp_port);
+                     "port %"PRIu32, ofproto->name, ofp_port);
         return ENODEV;
     }
 
@@ -1013,7 +1013,7 @@ ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
     struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
         VLOG_WARN_RL(&rl, "%s: cannot get STP stats on nonexistent "
-                     "port %"PRIu16, ofproto->name, ofp_port);
+                     "port %"PRIu32, ofproto->name, ofp_port);
         return ENODEV;
     }
 
@@ -1068,7 +1068,7 @@ ofproto_port_set_rstp(struct ofproto *ofproto, ofp_port_t ofp_port,
 {
     struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
-        VLOG_WARN("%s: cannot configure RSTP on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot configure RSTP on nonexistent port %"PRIu32,
                 ofproto->name, ofp_port);
         return ENODEV;
     }
@@ -1092,7 +1092,7 @@ ofproto_port_get_rstp_status(struct ofproto *ofproto, ofp_port_t ofp_port,
     struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
         VLOG_WARN_RL(&rl, "%s: cannot get RSTP status on nonexistent "
-                "port %"PRIu16, ofproto->name, ofp_port);
+                "port %"PRIu32, ofproto->name, ofp_port);
         return ENODEV;
     }
 
@@ -1120,7 +1120,7 @@ ofproto_port_set_queues(struct ofproto *ofproto, ofp_port_t ofp_port,
     struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
 
     if (!ofport) {
-        VLOG_WARN("%s: cannot set queues on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot set queues on nonexistent port %"PRIu32,
                   ofproto->name, ofp_port);
         return ENODEV;
     }
@@ -1141,7 +1141,7 @@ ofproto_port_set_lldp(struct ofproto *ofproto,
 
     ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
-        VLOG_WARN("%s: cannot configure LLDP on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot configure LLDP on nonexistent port %"PRIu32,
                   ofproto->name, ofp_port);
         return;
     }
@@ -1149,7 +1149,7 @@ ofproto_port_set_lldp(struct ofproto *ofproto,
              ? ofproto->ofproto_class->set_lldp(ofport, cfg)
              : EOPNOTSUPP);
     if (error) {
-        VLOG_WARN("%s: lldp configuration on port %"PRIu16" (%s) failed (%s)",
+        VLOG_WARN("%s: lldp configuration on port %"PRIu32" (%s) failed (%s)",
                   ofproto->name, ofp_port, netdev_get_name(ofport->netdev),
                   ovs_strerror(error));
     }
@@ -1234,7 +1234,7 @@ ofproto_port_set_cfm(struct ofproto *ofproto, ofp_port_t ofp_port,
 
     ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
-        VLOG_WARN("%s: cannot configure CFM on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot configure CFM on nonexistent port %"PRIu32,
                   ofproto->name, ofp_port);
         return;
     }
@@ -1246,7 +1246,7 @@ ofproto_port_set_cfm(struct ofproto *ofproto, ofp_port_t ofp_port,
              ? ofproto->ofproto_class->set_cfm(ofport, s)
              : EOPNOTSUPP);
     if (error) {
-        VLOG_WARN("%s: CFM configuration on port %"PRIu16" (%s) failed (%s)",
+        VLOG_WARN("%s: CFM configuration on port %"PRIu32" (%s) failed (%s)",
                   ofproto->name, ofp_port, netdev_get_name(ofport->netdev),
                   ovs_strerror(error));
     }
@@ -1263,7 +1263,7 @@ ofproto_port_set_bfd(struct ofproto *ofproto, ofp_port_t ofp_port,
 
     ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
-        VLOG_WARN("%s: cannot configure bfd on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot configure bfd on nonexistent port %"PRIu32,
                   ofproto->name, ofp_port);
         return;
     }
@@ -1272,7 +1272,7 @@ ofproto_port_set_bfd(struct ofproto *ofproto, ofp_port_t ofp_port,
              ? ofproto->ofproto_class->set_bfd(ofport, cfg)
              : EOPNOTSUPP);
     if (error) {
-        VLOG_WARN("%s: bfd configuration on port %"PRIu16" (%s) failed (%s)",
+        VLOG_WARN("%s: bfd configuration on port %"PRIu32" (%s) failed (%s)",
                   ofproto->name, ofp_port, netdev_get_name(ofport->netdev),
                   ovs_strerror(error));
     }
@@ -2088,7 +2088,7 @@ ofproto_port_set_config(struct ofproto *ofproto, ofp_port_t ofp_port,
 
     ofport = ofproto_get_port(ofproto, ofp_port);
     if (!ofport) {
-        VLOG_WARN("%s: cannot configure datapath on nonexistent port %"PRIu16,
+        VLOG_WARN("%s: cannot configure datapath on nonexistent port %"PRIu32,
                   ofproto->name, ofp_port);
         return;
     }
@@ -2097,7 +2097,7 @@ ofproto_port_set_config(struct ofproto *ofproto, ofp_port_t ofp_port,
              ? ofproto->ofproto_class->port_set_config(ofport, cfg)
              : EOPNOTSUPP);
     if (error) {
-        VLOG_WARN("%s: datapath configuration on port %"PRIu16
+        VLOG_WARN("%s: datapath configuration on port %"PRIu32
                   " (%s) failed (%s)",
                   ofproto->name, ofp_port, netdev_get_name(ofport->netdev),
                   ovs_strerror(error));
@@ -2370,7 +2370,7 @@ ofport_open(struct ofproto *ofproto,
 
     error = netdev_open(ofproto_port->name, ofproto_port->type, &netdev);
     if (error) {
-        VLOG_WARN_RL(&rl, "%s: ignoring port %s (%"PRIu16") because netdev %s "
+        VLOG_WARN_RL(&rl, "%s: ignoring port %s (%"PRIu32") because netdev %s "
                      "cannot be opened (%s)",
                      ofproto->name,
                      ofproto_port->name, ofproto_port->ofp_port,
@@ -3397,7 +3397,7 @@ handle_features_request(struct ofconn *ofconn, const struct ofp_header *oh)
     features.n_tables = ofproto_get_n_visible_tables(ofproto);
     features.capabilities = (OFPUTIL_C_FLOW_STATS | OFPUTIL_C_TABLE_STATS |
                              OFPUTIL_C_PORT_STATS | OFPUTIL_C_QUEUE_STATS |
-                             OFPUTIL_C_GROUP_STATS);
+                             OFPUTIL_C_GROUP_STATS | OFPUTIL_C_BUNDLES);
     if (arp_match_ip) {
         features.capabilities |= OFPUTIL_C_ARP_MATCH_IP;
     }
@@ -5004,7 +5004,6 @@ replace_rule_finish(struct ofproto *ofproto, struct ofproto_flow_mod *ofm,
                     struct ovs_list *dead_cookies)
     OVS_REQUIRES(ofproto_mutex)
 {
-    bool forward_counts = !(new_rule->flags & OFPUTIL_FF_RESET_COUNTS);
     struct rule *replaced_rule;
 
     replaced_rule = (old_rule && old_rule->removed_reason != OFPRR_EVICTION)
@@ -5013,10 +5012,10 @@ replace_rule_finish(struct ofproto *ofproto, struct ofproto_flow_mod *ofm,
     /* Insert the new flow to the ofproto provider.  A non-NULL 'replaced_rule'
      * is a duplicate rule the 'new_rule' is replacing.  The provider should
      * link the packet and byte counts from the old rule to the new one if
-     * 'forward_counts' is 'true'.  The 'replaced_rule' will be deleted right
-     * after this call. */
+     * 'modify_keep_counts' is 'true'.  The 'replaced_rule' will be deleted
+     * right after this call. */
     ofproto->ofproto_class->rule_insert(new_rule, replaced_rule,
-                                        forward_counts);
+                                        ofm->modify_keep_counts);
     learned_cookies_inc(ofproto, rule_get_actions(new_rule));
 
     if (old_rule) {
@@ -6379,7 +6378,10 @@ handle_group_request(struct ofconn *ofconn,
     ovs_mutex_lock(&ofproto_mutex);
     if (group_id == OFPG_ALL) {
         CMAP_FOR_EACH (group, cmap_node, &ofproto->groups) {
-            cb(group, &replies);
+            if (versions_visible_in_version(&group->versions,
+                                            OVS_VERSION_MAX)) {
+                cb(group, &replies);
+            }
         }
     } else {
         group = ofproto_group_lookup__(ofproto, group_id, OVS_VERSION_MAX);
@@ -7164,6 +7166,9 @@ ofproto_flow_mod_init(struct ofproto *ofproto, struct ofproto_flow_mod *ofm,
 
     ofm->modify_may_add_flow = (fm->new_cookie != OVS_BE64_MAX
                                 && fm->cookie_mask == htonll(0));
+    /* Old flags must be kept when modifying a flow, but we still must
+     * honor the reset counts flag if present in the flow mod. */
+    ofm->modify_keep_counts = !(fm->flags & OFPUTIL_FF_RESET_COUNTS);
 
     /* Initialize state needed by ofproto_flow_mod_uninit(). */
     ofm->temp_rule = NULL;
diff --git a/ofproto/pinsched.c b/ofproto/pinsched.c
index 51f176050..500115ad2 100644
--- a/ofproto/pinsched.c
+++ b/ofproto/pinsched.c
@@ -94,6 +94,12 @@ adjust_limits(int *rate_limit, int *burst_limit)
 static void
 pinqueue_destroy(struct pinsched *ps, struct pinqueue *q)
 {
+    if (ps->next_txq == q) {
+        advance_txq(ps);
+        if (ps->next_txq == q) {
+            ps->next_txq = NULL;
+        }
+    }
     hmap_remove(&ps->queues, &q->node);
     free(q);
 }
diff --git a/ofproto/tunnel.c b/ofproto/tunnel.c
index 9a69071c0..41c359dc1 100644
--- a/ofproto/tunnel.c
+++ b/ofproto/tunnel.c
@@ -435,6 +435,7 @@ tnl_port_send(const struct ofport_dpif *ofport, struct flow *flow,
             flow->tunnel.ipv6_dst = in6addr_any;
         }
     }
+    flow->tunnel.tp_dst = cfg->dst_port;
     flow->pkt_mark |= tnl_port->match.pkt_mark;
     wc->masks.pkt_mark |= tnl_port->match.pkt_mark;
 
diff --git a/ovn/controller/ofctrl.c b/ovn/controller/ofctrl.c
index 1d8fbf308..5f1bdff60 100644
--- a/ovn/controller/ofctrl.c
+++ b/ovn/controller/ofctrl.c
@@ -826,7 +826,8 @@ ofctrl_put(struct hmap *flow_table, struct shash *pending_ct_zones,
      * criteria for being backlogged appear very conservative, but the socket
      * between ovn-controller and OVS provides some buffering.) */
     if (state != S_UPDATE_FLOWS
-        || rconn_packet_counter_n_packets(tx_counter)) {
+        || rconn_packet_counter_n_packets(tx_counter)
+        || rconn_get_version(swconn) < 0) {
         ovn_flow_table_clear(flow_table);
         ovn_group_table_clear(groups, false);
         return;
diff --git a/ovn/controller/ovn-controller.c b/ovn/controller/ovn-controller.c
index 4ac1425ef..f0b600632 100644
--- a/ovn/controller/ovn-controller.c
+++ b/ovn/controller/ovn-controller.c
@@ -165,6 +165,7 @@ create_br_int(struct controller_ctx *ctx,
     bridges[cfg->n_bridges] = bridge;
     ovsrec_open_vswitch_verify_bridges(cfg);
     ovsrec_open_vswitch_set_bridges(cfg, bridges, cfg->n_bridges + 1);
+    free(bridges);
 
     return bridge;
 }
diff --git a/ovn/controller/patch.c b/ovn/controller/patch.c
index c9a5dd9c7..7c3a362e8 100644
--- a/ovn/controller/patch.c
+++ b/ovn/controller/patch.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, 2016 Nicira, Inc.
+/* Copyright (c) 2015, 2016, 2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,7 +43,7 @@ match_patch_port(const struct ovsrec_port *port, const char *peer)
             continue;
         }
         const char *iface_peer = smap_get(&iface->options, "peer");
-        if (peer && !strcmp(iface_peer, peer)) {
+        if (iface_peer && !strcmp(iface_peer, peer)) {
             return true;
         }
     }
diff --git a/ovn/controller/physical.c b/ovn/controller/physical.c
index c5866b4c6..8e9c0a181 100644
--- a/ovn/controller/physical.c
+++ b/ovn/controller/physical.c
@@ -63,7 +63,7 @@ static struct hmap tunnels = HMAP_INITIALIZER(&tunnels);
  * used to reach that chassis. */
 struct chassis_tunnel {
     struct hmap_node hmap_node;
-    const char *chassis_id;
+    char *chassis_id;
     ofp_port_t ofport;
     enum chassis_tunnel_type type;
 };
@@ -127,8 +127,8 @@ put_encapsulation(enum mf_field_id mff_ovn_geneve,
         put_load(outport, mff_ovn_geneve, 0, 32, ofpacts);
         put_move(MFF_LOG_INPORT, 0, mff_ovn_geneve, 16, 15, ofpacts);
     } else if (tun->type == STT) {
-        put_load(datapath->tunnel_key | (outport << 24), MFF_TUN_ID, 0, 64,
-                 ofpacts);
+        put_load(datapath->tunnel_key | ((uint64_t) outport << 24),
+                 MFF_TUN_ID, 0, 64, ofpacts);
         put_move(MFF_LOG_INPORT, 0, MFF_TUN_ID, 40, 15, ofpacts);
     } else if (tun->type == VXLAN) {
         put_load(datapath->tunnel_key, MFF_TUN_ID, 0, 24, ofpacts);
@@ -722,7 +722,7 @@ physical_run(struct controller_ctx *ctx, enum mf_field_id mff_ovn_geneve,
                     tun = xmalloc(sizeof *tun);
                     hmap_insert(&tunnels, &tun->hmap_node,
                                 hash_string(chassis_id, 0));
-                    tun->chassis_id = chassis_id;
+                    tun->chassis_id = xstrdup(chassis_id);
                     tun->ofport = u16_to_ofp(ofport);
                     tun->type = tunnel_type;
                     physical_map_changed = true;
@@ -744,6 +744,7 @@ physical_run(struct controller_ctx *ctx, enum mf_field_id mff_ovn_geneve,
         if (!simap_find(&new_tunnel_to_ofport, tun->chassis_id)) {
             hmap_remove(&tunnels, &tun->hmap_node);
             physical_map_changed = true;
+            free(tun->chassis_id);
             free(tun);
         }
     }
diff --git a/ovn/controller/pinctrl.c b/ovn/controller/pinctrl.c
index 323faa10c..b15adfaf8 100644
--- a/ovn/controller/pinctrl.c
+++ b/ovn/controller/pinctrl.c
@@ -385,13 +385,13 @@ compose_out_dhcpv6_opts(struct ofpbuf *userdata,
             return false;
         }
 
-        uint8_t *userdata_opt_data = ofpbuf_try_pull(userdata,
-                                                     userdata_opt->len);
+        size_t size = ntohs(userdata_opt->size);
+        uint8_t *userdata_opt_data = ofpbuf_try_pull(userdata, size);
         if (!userdata_opt_data) {
             return false;
         }
 
-        switch (userdata_opt->code) {
+        switch (ntohs(userdata_opt->opt_code)) {
         case DHCPV6_OPT_SERVER_ID_CODE:
         {
             /* The Server Identifier option carries a DUID
@@ -405,7 +405,7 @@ compose_out_dhcpv6_opts(struct ofpbuf *userdata,
                 out_dhcpv6_opts, sizeof *opt_server_id);
 
             opt_server_id->opt.code = htons(DHCPV6_OPT_SERVER_ID_CODE);
-            opt_server_id->opt.len = htons(userdata_opt->len + 4);
+            opt_server_id->opt.len = htons(size + 4);
             opt_server_id->duid_type = htons(DHCPV6_DUID_LL);
             opt_server_id->hw_type = htons(DHCPV6_HW_TYPE_ETH);
             memcpy(&opt_server_id->mac, userdata_opt_data,
@@ -415,7 +415,7 @@ compose_out_dhcpv6_opts(struct ofpbuf *userdata,
 
         case DHCPV6_OPT_IA_ADDR_CODE:
         {
-            if (userdata_opt->len != sizeof(struct in6_addr)) {
+            if (size != sizeof(struct in6_addr)) {
                 return false;
             }
 
@@ -444,9 +444,8 @@ compose_out_dhcpv6_opts(struct ofpbuf *userdata,
             struct dhcpv6_opt_ia_addr *opt_ia_addr = ofpbuf_put_zeros(
                 out_dhcpv6_opts, sizeof *opt_ia_addr);
             opt_ia_addr->opt.code = htons(DHCPV6_OPT_IA_ADDR_CODE);
-            opt_ia_addr->opt.len = htons(userdata_opt->len + 8);
-            memcpy(opt_ia_addr->ipv6.s6_addr, userdata_opt_data,
-                   userdata_opt->len);
+            opt_ia_addr->opt.len = htons(size + 8);
+            memcpy(opt_ia_addr->ipv6.s6_addr, userdata_opt_data, size);
             opt_ia_addr->t1 = OVS_BE32_MAX;
             opt_ia_addr->t2 = OVS_BE32_MAX;
             break;
@@ -457,8 +456,8 @@ compose_out_dhcpv6_opts(struct ofpbuf *userdata,
             struct dhcpv6_opt_header *opt_dns = ofpbuf_put_zeros(
                 out_dhcpv6_opts, sizeof *opt_dns);
             opt_dns->code = htons(DHCPV6_OPT_DNS_SERVER_CODE);
-            opt_dns->len = htons(userdata_opt->len);
-            ofpbuf_put(out_dhcpv6_opts, userdata_opt_data, userdata_opt->len);
+            opt_dns->len = htons(size);
+            ofpbuf_put(out_dhcpv6_opts, userdata_opt_data, size);
             break;
         }
 
@@ -467,11 +466,10 @@ compose_out_dhcpv6_opts(struct ofpbuf *userdata,
             struct dhcpv6_opt_header *opt_dsl = ofpbuf_put_zeros(
                 out_dhcpv6_opts, sizeof *opt_dsl);
             opt_dsl->code = htons(DHCPV6_OPT_DOMAIN_SEARCH_CODE);
-            opt_dsl->len = htons(userdata_opt->len + 2);
-            uint8_t *data = ofpbuf_put_zeros(out_dhcpv6_opts,
-                                              userdata_opt->len + 2);
-            *data = userdata_opt->len;
-            memcpy(data + 1, userdata_opt_data, userdata_opt->len);
+            opt_dsl->len = htons(size + 2);
+            uint8_t *data = ofpbuf_put_zeros(out_dhcpv6_opts, size + 2);
+            *data = size;
+            memcpy(data + 1, userdata_opt_data, size);
             break;
         }
 
diff --git a/ovn/lib/actions.c b/ovn/lib/actions.c
index 59131dde2..e4ac65a43 100644
--- a/ovn/lib/actions.c
+++ b/ovn/lib/actions.c
@@ -844,6 +844,7 @@ parse_ct_lb_action(struct action_context *ctx)
         while (!lexer_match(ctx->lexer, LEX_T_RPAREN)) {
             if (ctx->lexer->token.type != LEX_T_INTEGER
                 || mf_subvalue_width(&ctx->lexer->token.value) > 32) {
+                free(dsts);
                 lexer_syntax_error(ctx->lexer, "expecting IPv4 address");
                 return;
             }
@@ -1527,21 +1528,26 @@ encode_put_dhcpv6_option(const struct ovnact_dhcp_option *o,
                          struct ofpbuf *ofpacts)
 {
     struct dhcp_opt6_header *opt = ofpbuf_put_uninit(ofpacts, sizeof *opt);
-    opt->code = o->option->code;
-
     const union expr_constant *c = o->value.values;
     size_t n_values = o->value.n_values;
+    size_t size;
+
+    opt->opt_code = htons(o->option->code);
+
     if (!strcmp(o->option->type, "ipv6")) {
-        opt->len = n_values * sizeof(struct in6_addr);
+        size = n_values * sizeof(struct in6_addr);
+        opt->size = htons(size);
         for (size_t i = 0; i < n_values; i++) {
             ofpbuf_put(ofpacts, &c[i].value.ipv6, sizeof(struct in6_addr));
         }
     } else if (!strcmp(o->option->type, "mac")) {
-        opt->len = sizeof(struct eth_addr);
-        ofpbuf_put(ofpacts, &c->value.mac, opt->len);
+        size = sizeof(struct eth_addr);
+        opt->size = htons(size);
+        ofpbuf_put(ofpacts, &c->value.mac, size);
     } else if (!strcmp(o->option->type, "str")) {
-        opt->len = strlen(c->string);
-        ofpbuf_put(ofpacts, c->string, opt->len);
+        size = strlen(c->string);
+        opt->size = htons(size);
+        ofpbuf_put(ofpacts, c->string, size);
     }
 }
 
diff --git a/ovn/lib/expr.c b/ovn/lib/expr.c
index a197474e3..3585d868e 100644
--- a/ovn/lib/expr.c
+++ b/ovn/lib/expr.c
@@ -581,6 +581,10 @@ make_cmp(struct expr_context *ctx,
         }
     }
 
+    if (!cs->n_values) {
+        e = expr_create_boolean(r == EXPR_R_NE);
+        goto exit;
+    }
     e = make_cmp__(f, r, &cs->values[0]);
     for (size_t i = 1; i < cs->n_values; i++) {
         e = expr_combine(r == EXPR_R_EQ ? EXPR_T_OR : EXPR_T_AND,
diff --git a/ovn/lib/ovn-dhcp.h b/ovn/lib/ovn-dhcp.h
index ecfcc03a7..d5561edfa 100644
--- a/ovn/lib/ovn-dhcp.h
+++ b/ovn/lib/ovn-dhcp.h
@@ -109,9 +109,10 @@ dhcp_opts_destroy(struct hmap *dhcp_opts)
     hmap_destroy(dhcp_opts);
 }
 
+/* Used in the OpenFlow PACKET_IN userdata */
 struct dhcp_opt6_header {
-    uint16_t code;
-    uint16_t len;
+    ovs_be16 opt_code;
+    ovs_be16 size;
 };
 
 /* Supported DHCPv6 Message Types */
diff --git a/ovn/northd/ovn-northd.c b/ovn/northd/ovn-northd.c
index d6a9dec85..467162905 100644
--- a/ovn/northd/ovn-northd.c
+++ b/ovn/northd/ovn-northd.c
@@ -1890,7 +1890,8 @@ lsp_is_up(const struct nbrec_logical_switch_port *lsp)
 
 static bool
 build_dhcpv4_action(struct ovn_port *op, ovs_be32 offer_ip,
-                    struct ds *options_action, struct ds *response_action)
+                    struct ds *options_action, struct ds *response_action,
+                    struct ds *ipv4_addr_match)
 {
     if (!op->nbsp->dhcpv4_options) {
         /* CMS has disabled native DHCPv4 for this lport. */
@@ -1940,10 +1941,15 @@ build_dhcpv4_action(struct ovn_port *op, ovs_be32 offer_ip,
     ds_put_format(options_action,
                   REGBIT_DHCP_OPTS_RESULT" = put_dhcp_opts(offerip = "
                   IP_FMT", ", IP_ARGS(offer_ip));
-    struct smap_node *node;
-    SMAP_FOR_EACH(node, &dhcpv4_options) {
+
+    /* We're not using SMAP_FOR_EACH because we want a consistent order of the
+     * options on different architectures (big or little endian, SSE4.2) */
+    const struct smap_node **sorted_opts = smap_sort(&dhcpv4_options);
+    for (size_t i = 0; i < smap_count(&dhcpv4_options); i++) {
+        const struct smap_node *node = sorted_opts[i];
         ds_put_format(options_action, "%s = %s, ", node->key, node->value);
     }
+    free(sorted_opts);
 
     ds_chomp(options_action, ' ');
     ds_chomp(options_action, ',');
@@ -1955,6 +1961,9 @@ build_dhcpv4_action(struct ovn_port *op, ovs_be32 offer_ip,
                   "output;",
                   server_mac, IP_ARGS(offer_ip), server_ip);
 
+    ds_put_format(ipv4_addr_match,
+                  "ip4.src == "IP_FMT" && ip4.dst == {%s, 255.255.255.255}",
+                  IP_ARGS(offer_ip), server_ip);
     smap_destroy(&dhcpv4_options);
     return true;
 }
@@ -1984,9 +1993,9 @@ build_dhcpv6_action(struct ovn_port *op, struct in6_addr *offer_ip,
         return false;
     }
 
+    const struct smap *options_map = &op->nbsp->dhcpv6_options->options;
     /* "server_id" should be the MAC address. */
-    const char *server_mac = smap_get(&op->nbsp->dhcpv6_options->options,
-                                      "server_id");
+    const char *server_mac = smap_get(options_map, "server_id");
     struct eth_addr ea;
     if (!server_mac || !eth_addr_from_string(server_mac, &ea)) {
         /* "server_id" should be present in the dhcpv6_options. */
@@ -2009,10 +2018,18 @@ build_dhcpv6_action(struct ovn_port *op, struct in6_addr *offer_ip,
     ds_put_format(options_action,
                   REGBIT_DHCP_OPTS_RESULT" = put_dhcpv6_opts(ia_addr = %s, ",
                   ia_addr);
-    struct smap_node *node;
-    SMAP_FOR_EACH (node, &op->nbsp->dhcpv6_options->options) {
-        ds_put_format(options_action, "%s = %s, ", node->key, node->value);
+
+    /* We're not using SMAP_FOR_EACH because we want a consistent order of the
+     * options on different architectures (big or little endian, SSE4.2) */
+    const struct smap_node **sorted_opts = smap_sort(options_map);
+    for (size_t i = 0; i < smap_count(options_map); i++) {
+        const struct smap_node *node = sorted_opts[i];
+        if (strcmp(node->key, "dhcpv6_stateless")) {
+            ds_put_format(options_action, "%s = %s, ", node->key, node->value);
+        }
     }
+    free(sorted_opts);
+
     ds_chomp(options_action, ' ');
     ds_chomp(options_action, ',');
     ds_put_cstr(options_action, "); next;");
@@ -2670,13 +2687,14 @@ build_lswitch_flows(struct hmap *datapaths, struct hmap *ports,
     }
 
     /* Ingress table 9: ARP/ND responder, skip requests coming from localnet
-     * ports. (priority 100). */
+     * and vtep ports. (priority 100). */
     HMAP_FOR_EACH (op, key_node, ports) {
         if (!op->nbsp) {
             continue;
         }
 
-        if (!strcmp(op->nbsp->type, "localnet")) {
+        if ((!strcmp(op->nbsp->type, "localnet")) ||
+            (!strcmp(op->nbsp->type, "vtep"))) {
             ds_clear(&match);
             ds_put_format(&match, "inport == %s", op->json_key);
             ovn_lflow_add(lflows, op->od, S_SWITCH_IN_ARP_ND_RSP, 100,
@@ -2810,9 +2828,10 @@ build_lswitch_flows(struct hmap *datapaths, struct hmap *ports,
             for (size_t j = 0; j < op->lsp_addrs[i].n_ipv4_addrs; j++) {
                 struct ds options_action = DS_EMPTY_INITIALIZER;
                 struct ds response_action = DS_EMPTY_INITIALIZER;
+                struct ds ipv4_addr_match = DS_EMPTY_INITIALIZER;
                 if (build_dhcpv4_action(
                         op, op->lsp_addrs[i].ipv4_addrs[j].addr,
-                        &options_action, &response_action)) {
+                        &options_action, &response_action, &ipv4_addr_match)) {
                     struct ds match = DS_EMPTY_INITIALIZER;
                     ds_put_format(
                         &match, "inport == %s && eth.src == %s && "
@@ -2823,15 +2842,39 @@ build_lswitch_flows(struct hmap *datapaths, struct hmap *ports,
                     ovn_lflow_add(lflows, op->od, S_SWITCH_IN_DHCP_OPTIONS,
                                   100, ds_cstr(&match),
                                   ds_cstr(&options_action));
+                    ds_clear(&match);
+                    /* Allow ip4.src = OFFER_IP and
+                     * ip4.dst = {SERVER_IP, 255.255.255.255} for the below
+                     * cases
+                     *  -  When the client wants to renew the IP by sending
+                     *     the DHCPREQUEST to the server ip.
+                     *  -  When the client wants to renew the IP by
+                     *     broadcasting the DHCPREQUEST.
+                     */
+                    ds_put_format(
+                        &match, "inport == %s && eth.src == %s && "
+                        "%s && udp.src == 68 && udp.dst == 67", op->json_key,
+                        op->lsp_addrs[i].ea_s, ds_cstr(&ipv4_addr_match));
+
+                    ovn_lflow_add(lflows, op->od, S_SWITCH_IN_DHCP_OPTIONS,
+                                  100, ds_cstr(&match),
+                                  ds_cstr(&options_action));
+                    ds_clear(&match);
+
                     /* If REGBIT_DHCP_OPTS_RESULT is set, it means the
-                     * put_dhcp_opts action  is successful */
-                    ds_put_cstr(&match, " && "REGBIT_DHCP_OPTS_RESULT);
+                     * put_dhcp_opts action  is successful. */
+                    ds_put_format(
+                        &match, "inport == %s && eth.src == %s && "
+                        "ip4 && udp.src == 68 && udp.dst == 67"
+                        " && "REGBIT_DHCP_OPTS_RESULT, op->json_key,
+                        op->lsp_addrs[i].ea_s);
                     ovn_lflow_add(lflows, op->od, S_SWITCH_IN_DHCP_RESPONSE,
                                   100, ds_cstr(&match),
                                   ds_cstr(&response_action));
                     ds_destroy(&match);
                     ds_destroy(&options_action);
                     ds_destroy(&response_action);
+                    ds_destroy(&ipv4_addr_match);
                     break;
                 }
             }
@@ -3119,7 +3162,7 @@ build_static_route_flow(struct hmap *lflows, struct ovn_datapath *od,
                         const struct nbrec_logical_router_static_route *route)
 {
     ovs_be32 nexthop;
-    const char *lrp_addr_s;
+    const char *lrp_addr_s = NULL;
     unsigned int plen;
     bool is_ipv4;
 
@@ -3212,7 +3255,7 @@ build_static_route_flow(struct hmap *lflows, struct ovn_datapath *od,
         }
     }
 
-     if (!lrp_addr_s) {
+    if (!out_port || !lrp_addr_s) {
         /* There is no matched out port. */
         static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);
         VLOG_WARN_RL(&rl, "No path for static route %s; next hop %s",
diff --git a/ovn/utilities/ovn-ctl b/ovn/utilities/ovn-ctl
index 8544d1440..0a3ac47de 100755
--- a/ovn/utilities/ovn-ctl
+++ b/ovn/utilities/ovn-ctl
@@ -247,7 +247,7 @@ Commands:
 Options:
   --ovn-northd-priority=NICE     set ovn-northd's niceness (default: $OVN_NORTHD_PRIORITY)
   --ovn-northd-wrapper=WRAPPER   run with a wrapper like valgrind for debugging
-  --ovn-controller-priority=NICE     set ovn-northd's niceness (default: $OVN_CONTROLLER_PRIORITY)
+  --ovn-controller-priority=NICE     set ovn-controller's niceness (default: $OVN_CONTROLLER_PRIORITY)
   --ovn-controller-wrapper=WRAPPER   run with a wrapper like valgrind for debugging
   --ovn-manage-ovsdb=yes|no        Whether or not the OVN databases should be
                                    automatically started and stopped along
diff --git a/ovn/utilities/ovn-sbctl.8.in b/ovn/utilities/ovn-sbctl.8.in
index 5f0462aa5..80363970c 100644
--- a/ovn/utilities/ovn-sbctl.8.in
+++ b/ovn/utilities/ovn-sbctl.8.in
@@ -97,6 +97,9 @@ to approximately \fIsecs\fR seconds.  If the timeout expires,
 would normally happen only if the database cannot be contacted, or if
 the system is overloaded.)
 .
+.so lib/vlog.man
+.so lib/common.man
+.
 .SS "Table Formatting Options"
 These options control the format of output from the \fBlist\fR and
 \fBfind\fR commands.
diff --git a/ovn/utilities/ovn-trace.c b/ovn/utilities/ovn-trace.c
index f5607df2f..9f55c5b6a 100644
--- a/ovn/utilities/ovn-trace.c
+++ b/ovn/utilities/ovn-trace.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 Nicira, Inc.
+ * Copyright (c) 2016, 2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1173,17 +1173,18 @@ execute_get_mac_bind(const struct ovnact_get_mac_bind *bind,
     const struct ovntrace_mac_binding *binding
         = ovntrace_mac_binding_find(dp, port_key, &ip);
 
-    const struct eth_addr mac = binding ? binding->mac : eth_addr_zero;
+    uflow->dl_dst = binding ? binding->mac : eth_addr_zero;
     if (binding) {
         ovntrace_node_append(super, OVNTRACE_NODE_ACTION,
                              "/* MAC binding to "ETH_ADDR_FMT". */",
-                             ETH_ADDR_ARGS(mac));
+                             ETH_ADDR_ARGS(uflow->dl_dst));
     } else {
         ovntrace_node_append(super, OVNTRACE_NODE_ACTION,
                              "/* No MAC binding. */");
     }
     ovntrace_node_append(super, OVNTRACE_NODE_MODIFY,
-                         "eth.dst = "ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));
+                         "eth.dst = "ETH_ADDR_FMT,
+                         ETH_ADDR_ARGS(uflow->dl_dst));
 }
 
 static void
@@ -1219,7 +1220,7 @@ trace_actions(const struct ovnact *ovnacts, size_t ovnacts_len,
             break;
 
         case OVNACT_NEXT:
-            trace__(dp, uflow, table_id + 1, pipeline, super);
+            trace__(dp, uflow, ovnact_get_NEXT(a)->ltable, pipeline, super);
             break;
 
         case OVNACT_LOAD:
@@ -1344,14 +1345,16 @@ trace(const char *dp_s, const char *flow_s)
 {
     const struct ovntrace_datapath *dp = ovntrace_datapath_find_by_name(dp_s);
     if (!dp) {
-        ovs_fatal(0, "unknown datapath \"%s\"", dp_s);
+        return xasprintf("unknown datapath \"%s\"\n", dp_s);
     }
 
     struct flow uflow;
     char *error = expr_parse_microflow(flow_s, &symtab, &address_sets,
                                        ovntrace_lookup_port, dp, &uflow);
     if (error) {
-        ovs_fatal(0, "error parsing flow: %s", error);
+        char *s = xasprintf("error parsing flow: %s\n", error);
+        free(error);
+        return s;
     }
 
     uint32_t in_key = uflow.regs[MFF_LOG_INPORT - MFF_REG0];
diff --git a/ovsdb/monitor.c b/ovsdb/monitor.c
index 69964c6dd..437a53d33 100644
--- a/ovsdb/monitor.c
+++ b/ovsdb/monitor.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 Nicira, Inc.
+ * Copyright (c) 2015, 2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -651,8 +651,8 @@ ovsdb_monitor_table_condition_create(
     ovsdb_condition_clone(&mtc->new_condition, &mtc->old_condition);
     if (ovsdb_condition_is_true(&mtc->old_condition)) {
         condition->n_true_cnd++;
-        ovsdb_monitor_session_condition_set_mode(condition);
     }
+    ovsdb_monitor_session_condition_set_mode(condition);
 
     return NULL;
 }
@@ -687,15 +687,15 @@ ovsdb_monitor_table_condition_update(
                             const struct ovsdb_table *table,
                             const struct json *cond_json)
 {
+    if (!condition) {
+        return NULL;
+    }
+
     struct ovsdb_monitor_table_condition *mtc =
         shash_find_data(&condition->tables, table->schema->name);
     struct ovsdb_error *error;
     struct ovsdb_condition cond = OVSDB_CONDITION_INITIALIZER(&cond);
 
-    if (!condition) {
-        return NULL;
-    }
-
     error = ovsdb_condition_from_json(table->schema, cond_json,
                                       NULL, &cond);
     if (error) {
diff --git a/ovsdb/ovsdb-client.1.in b/ovsdb/ovsdb-client.1.in
index 1bb7419d9..158058393 100644
--- a/ovsdb/ovsdb-client.1.in
+++ b/ovsdb/ovsdb-client.1.in
@@ -46,10 +46,9 @@ ovsdb\-client \- command-line interface to \fBovsdb-server\fR(1)
 .IP "Output formatting options:"
 [\fB\-\-format=\fIformat\fR]
 [\fB\-\-data=\fIformat\fR]
-[\fB\-\-no-heading\fR]
+[\fB\-\-no-headings\fR]
 [\fB\-\-pretty\fR]
 [\fB\-\-bare\fR]
-[\fB\-\-no\-heading\fR]
 [\fB\-\-timestamp\fR]
 .so lib/daemon-syn.man
 .so lib/vlog-syn.man
diff --git a/ovsdb/ovsdb-idlc.in b/ovsdb/ovsdb-idlc.in
index cd4532e39..7261c953c 100755
--- a/ovsdb/ovsdb-idlc.in
+++ b/ovsdb/ovsdb-idlc.in
@@ -493,6 +493,11 @@ void
         for columnName, column in sorted(table.columns.iteritems()):
             if column.type.is_smap():
                 print "    smap_init(&row->%s);" % columnName
+            elif (column.type.n_min == 1 and
+                  column.type.n_max == 1 and
+                  column.type.key.type == ovs.db.types.StringType and
+                  not column.type.value):
+                print "    row->%s = \"\";" % columnName
         print "}"
 
         # First, next functions.
diff --git a/ovsdb/replication.c b/ovsdb/replication.c
index 1c77b1876..2f0605a56 100644
--- a/ovsdb/replication.c
+++ b/ovsdb/replication.c
@@ -485,8 +485,8 @@ reset_database(struct ovsdb *db)
         /* Delete all rows if the table is not blacklisted. */
         if (!blacklist_tables_find(db->schema->name, table_node->name)) {
             struct ovsdb_table *table = table_node->data;
-            struct ovsdb_row *row;
-            HMAP_FOR_EACH (row, hmap_node, &table->rows) {
+            struct ovsdb_row *row, *next;
+            HMAP_FOR_EACH_SAFE (row, next, hmap_node, &table->rows) {
                 ovsdb_txn_row_delete(txn, row);
             }
         }
diff --git a/python/ovs/db/idl.py b/python/ovs/db/idl.py
index 0178050d9..751d2eb76 100644
--- a/python/ovs/db/idl.py
+++ b/python/ovs/db/idl.py
@@ -650,6 +650,7 @@ class Idl(object):
         txn = self._outstanding_txns.pop(msg.id, None)
         if txn:
             txn._process_reply(msg)
+            return True
 
 
 def _uuid_to_row(atom, base):
diff --git a/python/ovs/stream.py b/python/ovs/stream.py
index 97b22acc7..c5fe1dc8e 100644
--- a/python/ovs/stream.py
+++ b/python/ovs/stream.py
@@ -26,16 +26,18 @@ vlog = ovs.vlog.Vlog("stream")
 
 
 def stream_or_pstream_needs_probes(name):
-    """ 1 if the stream or pstream specified by 'name' needs periodic probes to
-    verify connectivity.  For [p]streams which need probes, it can take a long
-    time to notice the connection was dropped.  Returns 0 if probes aren't
-    needed, and -1 if 'name' is invalid"""
-
-    if PassiveStream.is_valid_name(name) or Stream.is_valid_name(name):
-        # Only unix and punix are supported currently.
-        return 0
+    """ True if the stream or pstream specified by 'name' needs periodic probes
+    to verify connectivity.  For [p]streams which need probes, it can take a
+    long time to notice the connection was dropped.  Returns False if probes
+    aren't needed, and None if 'name' is invalid"""
+
+    cls = Stream._find_method(name)
+    if cls:
+        return cls.needs_probes()
+    elif PassiveStream.is_valid_name(name):
+        return PassiveStream.needs_probes(name)
     else:
-        return -1
+        return None
 
 
 class Stream(object):
@@ -266,6 +268,10 @@ class Stream(object):
 
 
 class PassiveStream(object):
+    @staticmethod
+    def needs_probes(name):
+        return False if name.startswith("punix:") else True
+
     @staticmethod
     def is_valid_name(name):
         """Returns True if 'name' is a passive stream name in the form
@@ -368,6 +374,10 @@ Passive %s connection methods:
 
 
 class UnixStream(Stream):
+    @staticmethod
+    def needs_probes():
+        return False
+
     @staticmethod
     def _open(suffix, dscp):
         connect_path = suffix
@@ -377,6 +387,10 @@ Stream.register_method("unix", UnixStream)
 
 
 class TCPStream(Stream):
+    @staticmethod
+    def needs_probes():
+        return True
+
     @staticmethod
     def _open(suffix, dscp):
         error, sock = ovs.socket_util.inet_open_active(socket.SOCK_STREAM,
diff --git a/rhel/etc_init.d_openvswitch b/rhel/etc_init.d_openvswitch
index 3921aab5e..caf24cce8 100755
--- a/rhel/etc_init.d_openvswitch
+++ b/rhel/etc_init.d_openvswitch
@@ -27,6 +27,8 @@
 # Short-Description: Open vSwitch switch
 ### END INIT INFO
 
+SYSTEMCTL_SKIP_REDIRECT=yes
+
 . /usr/share/openvswitch/scripts/ovs-lib || exit 1
 test -e /etc/sysconfig/openvswitch && . /etc/sysconfig/openvswitch
 
diff --git a/rhel/etc_sysconfig_network-scripts_ifdown-ovs b/rhel/etc_sysconfig_network-scripts_ifdown-ovs
index dd98d2323..8c9f3694c 100755
--- a/rhel/etc_sysconfig_network-scripts_ifdown-ovs
+++ b/rhel/etc_sysconfig_network-scripts_ifdown-ovs
@@ -59,7 +59,7 @@ case "$TYPE" in
 	OVSPatchPort|OVSTunnel)
 		ovs-vsctl -t ${TIMEOUT} -- --if-exists del-port "$OVS_BRIDGE" "$DEVICE"
 		;;
-	OVSDPDKPort|OVSDPDKRPort|OVSDPDKVhostPort|OVSDPDKVhostUserPort)
+	OVSDPDKPort|OVSDPDKRPort|OVSDPDKVhostUserPort|OVSDPDKBond)
 		ovs-vsctl -t ${TIMEOUT} -- --if-exists del-port "$OVS_BRIDGE" "$DEVICE"
 		;;
 	*)
diff --git a/rhel/usr_lib_systemd_system_openvswitch.service b/rhel/usr_lib_systemd_system_openvswitch.service
index e823c5454..bdbceaefb 100644
--- a/rhel/usr_lib_systemd_system_openvswitch.service
+++ b/rhel/usr_lib_systemd_system_openvswitch.service
@@ -1,7 +1,7 @@
 [Unit]
 Description=Open vSwitch
 Before=network.target network.service
-After=network-pre.target
+After=network-pre.target ovsdb-server.service ovs-vswitchd.service
 PartOf=network.target
 BindsTo=ovsdb-server.service
 BindsTo=ovs-vswitchd.service
diff --git a/rhel/usr_lib_systemd_system_ovn-controller-vtep.service b/rhel/usr_lib_systemd_system_ovn-controller-vtep.service
index 867a9061a..978a5d809 100644
--- a/rhel/usr_lib_systemd_system_ovn-controller-vtep.service
+++ b/rhel/usr_lib_systemd_system_ovn-controller-vtep.service
@@ -28,3 +28,6 @@ ExecStart=/usr/bin/ovn-controller-vtep -vconsole:emer -vsyslog:err -vfile:info \
           --log-file=/var/log/openvswitch/ovn-controller-vtep.log \
           --no-chdir --pidfile=${OVS_RUNDIR}/ovn-controller-vtep.pid \
           --ovnsb-db=${OVN_DB} --vtep-db=${VTEP_DB}
+
+[Install]
+WantedBy=multi-user.target
diff --git a/rhel/usr_lib_systemd_system_ovn-controller.service b/rhel/usr_lib_systemd_system_ovn-controller.service
index 9bd2f6674..4fa425b6c 100644
--- a/rhel/usr_lib_systemd_system_ovn-controller.service
+++ b/rhel/usr_lib_systemd_system_ovn-controller.service
@@ -18,3 +18,6 @@ Type=oneshot
 RemainAfterExit=yes
 ExecStart=/usr/share/openvswitch/scripts/ovn-ctl start_controller
 ExecStop=/usr/share/openvswitch/scripts/ovn-ctl stop_controller
+
+[Install]
+WantedBy=multi-user.target
diff --git a/rhel/usr_lib_systemd_system_ovn-northd.service b/rhel/usr_lib_systemd_system_ovn-northd.service
index 5b3b03aef..9c9e941b8 100644
--- a/rhel/usr_lib_systemd_system_ovn-northd.service
+++ b/rhel/usr_lib_systemd_system_ovn-northd.service
@@ -10,3 +10,6 @@ RemainAfterExit=yes
 Environment=OVS_RUNDIR=%t/openvswitch OVS_DBDIR=/var/lib/openvswitch
 ExecStart=/usr/share/openvswitch/scripts/ovn-ctl start_northd
 ExecStop=/usr/share/openvswitch/scripts/ovn-ctl stop_northd
+
+[Install]
+WantedBy=multi-user.target
diff --git a/tests/atlocal.in b/tests/atlocal.in
index 55070d887..7ddfc54b8 100644
--- a/tests/atlocal.in
+++ b/tests/atlocal.in
@@ -11,6 +11,11 @@ fi
 
 if test x"$PYTHON3" = x; then
     PYTHON3='@PYTHON3@'
+
+    # PYTHONCOERCECLOCALE=0 disables the Unicode compatibility warning on
+    # stderr that breaks almost any Python3 test (PEP 0538)
+    PYTHONCOERCECLOCALE=0
+    export PYTHONCOERCECLOCALE
 fi
 
 PYTHONPATH=$abs_top_srcdir/python:$abs_top_builddir/tests:$PYTHONPATH
diff --git a/tests/automake.mk b/tests/automake.mk
index d42b57600..94c332d0a 100644
--- a/tests/automake.mk
+++ b/tests/automake.mk
@@ -52,6 +52,7 @@ TESTSUITE_AT = \
 	tests/tunnel.at \
 	tests/tunnel-push-pop.at \
 	tests/tunnel-push-pop-ipv6.at \
+	tests/ovs-router.at \
 	tests/lockfile.at \
 	tests/reconnect.at \
 	tests/ovs-vswitchd.at \
@@ -94,7 +95,8 @@ TESTSUITE_AT = \
 	tests/ovn-nbctl.at \
 	tests/ovn-sbctl.at \
 	tests/ovn-controller.at \
-	tests/ovn-controller-vtep.at
+	tests/ovn-controller-vtep.at \
+	tests/mcast-snooping.at
 
 SYSTEM_KMOD_TESTSUITE_AT = \
 	tests/system-common-macros.at \
diff --git a/tests/bfd.at b/tests/bfd.at
index 8bbf00b27..87c674474 100644
--- a/tests/bfd.at
+++ b/tests/bfd.at
@@ -794,3 +794,39 @@ BFD_VSCTL_LIST_IFACE([p1], ["s/^.*flap_count=\(.*\), forwarding.*$/\1/p"], ["1"]
 
 OVS_VSWITCHD_STOP
 AT_CLEANUP
+
+AT_SETUP([bfd - check that BFD works together with RSTP])
+# Create br0 with interfaces p1
+#    and br1 with interfaces p2
+# with p1 and p2 connected via unix domain socket
+OVS_VSWITCHD_START(
+  [set bridge br0 rstp_enable=true -- \
+   add-br br1 -- \
+   set bridge br1 other-config:hwaddr=aa:66:aa:66:00:00 -- \
+   set bridge br1 datapath-type=dummy -- \
+   set bridge br1 rstp_enable=true -- \
+])
+
+AT_CHECK([ovs-vsctl add-port br0 p1 -- \
+   set interface p1 type=dummy options:pstream=punix:$OVS_RUNDIR/p0.sock bfd:enable=true -- \
+])
+
+AT_CHECK([ovs-vsctl add-port br1 p2 -- \
+   set interface p2 type=dummy options:stream=unix:$OVS_RUNDIR/p0.sock bfd:enable=true -- \
+])
+
+ovs-appctl time/stop
+ovs-appctl time/warp 4100 100
+
+# Forwarding should be true
+BFD_CHECK([p1], [true], [false], [none], [up], [No Diagnostic], [none], [up], [No Diagnostic])
+BFD_CHECK([p2], [true], [false], [none], [up], [No Diagnostic], [none], [up], [No Diagnostic])
+
+# Disable bfd on p2, forwarding on p1 should go to false
+AT_CHECK([ovs-vsctl set interface p2 bfd:enable=false])
+
+ovs-appctl time/warp 5000 100
+BFD_CHECK([p1], [false], [false], [none], [down], [Control Detection Time Expired], [none], [down], [No Diagnostic])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
diff --git a/tests/cfm.at b/tests/cfm.at
index 0033f3029..d686acfbc 100644
--- a/tests/cfm.at
+++ b/tests/cfm.at
@@ -283,3 +283,39 @@ CFM_VSCTL_LIST_IFACE([p1], [cfm_fault_status], [cfm_fault_status    : [[]]])
 
 OVS_VSWITCHD_STOP
 AT_CLEANUP
+
+AT_SETUP([cfm - check that CFM works together with RSTP])
+# Create br0 with interfaces p1
+#    and br1 with interfaces p2
+# with p1 and p2 connected via unix domain socket
+OVS_VSWITCHD_START(
+  [set bridge br0 rstp_enable=true -- \
+   add-br br1 -- \
+   set bridge br1 other-config:hwaddr=aa:66:aa:66:00:00 -- \
+   set bridge br1 datapath-type=dummy -- \
+   set bridge br1 rstp_enable=true -- \
+])
+
+AT_CHECK([ovs-vsctl add-port br0 p0 -- \
+   set interface p0 type=dummy options:pstream=punix:$OVS_RUNDIR/p0.sock cfm_mpid=1 other_config:cfm_interval=300 other_config:cfm_extended=true -- \
+])
+
+AT_CHECK([ovs-vsctl add-port br1 p1 -- \
+   set interface p1 type=dummy options:stream=unix:$OVS_RUNDIR/p0.sock cfm_mpid=2 other_config:cfm_interval=300 other_config:cfm_extended=true -- \
+])
+
+ovs-appctl time/stop
+ovs-appctl time/warp 10100 100
+
+# Forwarding should be true
+CFM_CHECK_EXTENDED([p0], [1], [100], [up], [up], [300ms], [2], [up])
+CFM_CHECK_EXTENDED([p1], [2], [100], [up], [up], [300ms], [1], [up])
+
+# Disable cfm on p1, cfm should receive fault.
+AT_CHECK([ovs-vsctl set interface p1 other_config:cfm_extended=false])
+
+ovs-appctl time/warp 5000 100
+CFM_CHECK_EXTENDED_FAULT([p0], [1], [recv], [0], [up], [up], [300ms])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
diff --git a/tests/mcast-snooping.at b/tests/mcast-snooping.at
new file mode 100644
index 000000000..c03aba3fb
--- /dev/null
+++ b/tests/mcast-snooping.at
@@ -0,0 +1,104 @@
+AT_BANNER([mcast snooping])
+
+AT_SETUP([mcast - check multicasts to trunk ports are not duplicated])
+
+OVS_VSWITCHD_START([])
+
+AT_CHECK([
+    ovs-vsctl set bridge br0 \
+    datapath_type=dummy \
+    mcast_snooping_enable=true \
+    other-config:mcast-snooping-disable-flood-unregistered=true
+], [0])
+
+AT_CHECK([ovs-ofctl add-flow br0 action=normal])
+
+# Create an access port p1 on vlan 1725, and a trunk port p2.
+AT_CHECK([
+    ovs-vsctl add-port br0 p1 tag=1725 -- set Interface p1 type=dummy \
+    other-config:hwaddr=aa:55:aa:55:00:01 ofport_request=1 \
+    -- add-port br0 p2 -- set Interface p2 type=dummy \
+    other-config:hwaddr=aa:55:aa:55:00:02 ofport_request=2
+], [0])
+
+AT_CHECK([ovs-appctl dpif/show], [0], [dnl
+dummy@ovs-dummy: hit:0 missed:0
+	br0:
+		br0 65534/100: (dummy-internal)
+		p1 1/1: (dummy)
+		p2 2/2: (dummy)
+])
+
+# Send IGMPv3 query on p2 with vlan 1725
+# 5c:8a:38:55:25:52 > 01:00:5e:00:00:01, ethertype 802.1Q (0x8100), length 64: vlan 1725, p 0, ethertype IPv4,
+# 172.17.25.1 > 224.0.0.1: igmp query v3
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 \
+'01005e0000015c8a38552552810006bd080046c000240000000001027f00ac111901e0000001940400001164ec1e00000000027d000000000000000000000000'])
+
+# Send IGMPv3 query on p2 with vlan 1728
+# 5c:8a:38:55:25:52 > 01:00:5e:00:00:01, ethertype 802.1Q (0x8100), length 64: vlan 1728, p 0, ethertype IPv4,
+# 172.17.28.1 > 224.0.0.1: igmp query v3
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 \
+'01005e0000015c8a38552552810006c0080046c000240000000001027c00ac111c01e0000001940400001164ec1e00000000027d000000000000000000000000'])
+
+AT_CHECK([ovs-appctl mdb/show br0], [0], [dnl
+ port  VLAN  GROUP                Age
+    2  1725  querier               0
+    2  1728  querier               0
+])
+
+AT_CHECK([ovs-vsctl set Interface p2 options:tx_pcap=p2.pcap])
+
+# Send a multicast packet on p1
+AT_CHECK([
+    ovs-appctl netdev-dummy/receive p1 \
+    'in_port(1),eth(src=aa:55:aa:55:00:01,dst=01:00:5e:5e:01:01),eth_type(0x0800),ipv4(src=10.0.0.1,dst=239.94.1.1,proto=17,tos=0,ttl=64,frag=no),udp(src=0,dst=8000)'
+])
+
+# Check this packet was forwarded exactly once to p2 and has vlan tag 1725
+# aa:55:aa:55:00:01 > 01:00:5e:5e:01:01, ethertype 802.1Q (0x8100), length 46: vlan 1725, p 0, ethertype IPv4,
+# 10.0.0.1.0 > 239.94.1.1.8000: UDP, length 0
+AT_CHECK([ovs-pcap p2.pcap > p2.pcap.txt 2>&1])
+AT_CHECK([cat p2.pcap.txt], [0], [dnl
+01005e5e0101aa55aa550001810006bd08004500001c00000000401180710a000001ef5e010100001f400008e63d
+])
+
+# Clear the mdb, send a IGMP packet with invalid checksum and make sure it
+# does not end up in the mdb.
+AT_CHECK([ovs-appctl mdb/flush br0], [0], [dnl
+table successfully flushed
+])
+
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 \
+'01005e0000015c8a38552552810006bd080046c000240000000001027f00ac111901e0000001940400001164ec1000000000027d000000000000000000000000'])
+
+AT_CHECK([ovs-appctl mdb/show br0], [0], [dnl
+ port  VLAN  GROUP                Age
+])
+
+
+# First send a valid packet to make sure it populates the mdb. Than Clear
+# the mdb, send a MLD packet with invalid checksum and make sure it does
+# not end up in the mdb.
+
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 \
+'3333ff0e4c67000c290e4c6786dd600000000020000100000000000000000000000000000000ff0200000000000000000001ff0e4c673a000502000001008300e7b800000000ff0200000000000000000001ff0e4c67'])
+
+AT_CHECK([ovs-appctl mdb/show br0], [0], [dnl
+ port  VLAN  GROUP                Age
+    2     0  ff02::1:ff0e:4c67           0
+])
+
+AT_CHECK([ovs-appctl mdb/flush br0], [0], [dnl
+table successfully flushed
+])
+
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 \
+'3333ff0e4c67000c290e4c6786dd600000000020000100000000000000000000000000000000ff0200000000000000000001ff0e4c673a000502000001008300e7b000000000ff0200000000000000000001ff0e4c67'])
+
+AT_CHECK([ovs-appctl mdb/show br0], [0], [dnl
+ port  VLAN  GROUP                Age
+])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
diff --git a/tests/mpls-xlate.at b/tests/mpls-xlate.at
index 598a05a1f..9bbf22a99 100644
--- a/tests/mpls-xlate.at
+++ b/tests/mpls-xlate.at
@@ -38,7 +38,9 @@ AT_CHECK([ovs-ofctl -O OpenFlow13 add-flow br0 dl_type=0x8847,in_port=1,mpls_lab
 
 AT_CHECK([ovs-ofctl -O OpenFlow13 add-flow br1 in_port=1,action=output:LOCAL])
 
-
+dnl The following is needed on slow systems, because the flows in the datapath
+dnl will be evicted before the packet can match the recirculation context
+ovs-appctl time/stop
 
 dnl Test MPLS push
 AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(100),eth(src=f8:bc:12:44:34:b6,dst=f8:bc:12:46:58:e0),eth_type(0x0800),ipv4(src=1.1.2.92,dst=1.1.2.88,proto=17,tos=0,ttl=64,frag=no),udp(src=7777,dst=80)'], [0], [stdout])
@@ -132,3 +134,67 @@ AT_CHECK([tail -1 stdout], [0],
 
 OVS_VSWITCHD_STOP
 AT_CLEANUP
+
+AT_SETUP([MPLS xlate action - patch-port])
+
+OVS_VSWITCHD_START(
+  [add-port br0 p0 -- set Interface p0 type=dummy ofport_request=1 -- \
+   add-port br0 p1 -- set Interface p1 type=patch \
+                                       options:peer=p2 ofport_request=2 -- \
+   add-br br1 -- \
+   set bridge br1 other-config:hwaddr=aa:66:aa:66:00:00 -- \
+   set bridge br1 datapath-type=dummy other-config:datapath-id=1234 \
+                  fail-mode=secure -- \
+   add-port br1 p2 -- set Interface p2 type=patch \
+                                       options:peer=p1 -- \
+   add-port br1 p3 -- set Interface p3 type=dummy ofport_request=3])
+
+AT_CHECK([ovs-appctl vlog/set dpif:dbg dpif_netdev:dbg ofproto_dpif_upcall:dbg])
+
+AT_CHECK([ovs-appctl dpif/show], [0], [dnl
+dummy@ovs-dummy: hit:0 missed:0
+	br0:
+		br0 65534/100: (dummy-internal)
+		p0 1/1: (dummy)
+		p1 2/none: (patch: peer=p2)
+	br1:
+		br1 65534/101: (dummy-internal)
+		p2 1/none: (patch: peer=p1)
+		p3 3/3: (dummy)
+])
+
+dnl MPLS PUSH + POP.
+AT_CHECK([ovs-ofctl del-flows br0])
+
+AT_CHECK([ovs-ofctl -O OpenFlow13 add-flow br0 in_port=local,ip,actions=2,1,1])
+
+AT_CHECK([ovs-ofctl -O OpenFlow13 add-flow br1 in_port=1,ip,actions=dec_ttl,push_mpls:0x8847,3])
+
+dnl MPLS push+pop
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(100),eth(src=f8:bc:12:44:34:b6,dst=f8:bc:12:46:58:e0),eth_type(0x0800),ipv4(src=10.1.1.22,dst=10.0.0.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=53295,dst=8080)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: set(ipv4(ttl=63)),push_mpls(label=0,tc=0,ttl=63,bos=1,eth_type=0x8847),3,pop_mpls(eth_type=0x800),set(ipv4(tos=0/0xfc,ttl=64)),1,1
+])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([MPLS xlate action - group bucket])
+
+OVS_VSWITCHD_START
+add_of_ports br0 1
+
+AT_CHECK([ovs-appctl vlog/set dpif:dbg dpif_netdev:dbg ofproto_dpif_upcall:dbg])
+
+AT_CHECK([ovs-ofctl del-flows br0])
+AT_CHECK([ovs-ofctl -O OpenFlow13 add-group br0 'group_id=1234,type=all,bucket=push_mpls:0x8847,output:1'])
+AT_CHECK([ovs-ofctl -O OpenFlow13 add-flow br0 in_port=local,ip,actions=group:1234,output:1,output:1])
+
+dnl MPLS push in a bucket
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(100),eth(src=f8:bc:12:44:34:b6,dst=f8:bc:12:46:58:e0),eth_type(0x0800),ipv4(src=10.1.1.22,dst=10.0.0.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=53295,dst=8080)'], [0], [stdout])
+AT_CHECK([tail -1 stdout], [0],
+  [Datapath actions: push_mpls(label=0,tc=0,ttl=64,bos=1,eth_type=0x8847),1,pop_mpls(eth_type=0x800),1,1
+])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
diff --git a/tests/ofp-print.at b/tests/ofp-print.at
index ecc2c7ad4..4e82cd49f 100644
--- a/tests/ofp-print.at
+++ b/tests/ofp-print.at
@@ -403,6 +403,30 @@ capabilities: FLOW_STATS TABLE_STATS PORT_STATS IP_REASM QUEUE_STATS PORT_BLOCKE
 ])
 AT_CLEANUP
 
+AT_SETUP([OFPT_FEATURES_REPLY - OF1.4])
+AT_KEYWORDS([ofp-print])
+AT_CHECK([ovs-ofctl ofp-print "\
+05 06 00 20 00 00 00 01 00 00 50 54 00 00 00 01 \
+00 00 01 00 ff 00 00 00 00 00 07 6f 00 00 00 00 \
+"], [0], [dnl
+OFPT_FEATURES_REPLY (OF1.4) (xid=0x1): dpid:0000505400000001
+n_tables:255, n_buffers:256
+capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS IP_REASM QUEUE_STATS PORT_BLOCKED BUNDLES FLOW_MONITORING
+])
+AT_CLEANUP
+
+AT_SETUP([OFPT_FEATURES_REPLY - OF1.5])
+AT_KEYWORDS([ofp-print])
+AT_CHECK([ovs-ofctl ofp-print "\
+06 06 00 20 00 00 00 01 00 00 50 54 00 00 00 01 \
+00 00 01 00 ff 00 00 00 00 00 07 6f 00 00 00 00 \
+"], [0], [dnl
+OFPT_FEATURES_REPLY (OF1.5) (xid=0x1): dpid:0000505400000001
+n_tables:255, n_buffers:256
+capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS IP_REASM QUEUE_STATS PORT_BLOCKED BUNDLES FLOW_MONITORING
+])
+AT_CLEANUP
+
 AT_SETUP([OFPT_FEATURES_REPLY - with auxiliary_id - OF1.3])
 AT_KEYWORDS([ofp-print])
 AT_CHECK([ovs-ofctl ofp-print "\
diff --git a/tests/ofproto-dpif.at b/tests/ofproto-dpif.at
index a71282c92..9a32ece26 100644
--- a/tests/ofproto-dpif.at
+++ b/tests/ofproto-dpif.at
@@ -1589,6 +1589,40 @@ NXST_FLOW reply:
 OVS_VSWITCHD_STOP
 AT_CLEANUP
 
+AT_SETUP([ofproto-dpif - controller action without megaflows])
+OVS_VSWITCHD_START
+add_of_ports br0 1
+
+AT_CHECK([ovs-ofctl add-flow br0 in_port=1,action=controller])
+AT_CHECK([ovs-appctl upcall/disable-megaflows], [0], [dnl
+megaflows disabled
+])
+
+AT_CAPTURE_FILE([ofctl_monitor.log])
+AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl -P nxt_packet_in --detach --no-chdir --pidfile 2> ofctl_monitor.log])
+
+for i in 1 2; do
+    AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x1234)'])
+done
+
+OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 4])
+OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
+
+AT_CHECK([ovs-appctl dpctl/dump-flows | sed 's/.*\(packets:\)/\1/' | sed 's/used:[[0-9]].[[0-9]]*s/used:0.001s/'], [0], [dnl
+flow-dump from non-dpdk interfaces:
+packets:1, bytes:14, used:0.001s, actions:userspace(pid=0,slow_path(controller))
+])
+
+AT_CHECK([cat ofctl_monitor.log], [0], [dnl
+NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=14 in_port=1 (via action) data_len=14 (unbuffered)
+vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,dl_type=0x1234
+NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=14 in_port=1 (via action) data_len=14 (unbuffered)
+vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,dl_type=0x1234
+])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
 AT_SETUP([ofproto-dpif - MPLS handling])
 OVS_VSWITCHD_START([dnl
    add-port br0 p1 -- set Interface p1 type=dummy
@@ -4270,6 +4304,46 @@ AT_CHECK_UNQUOTED([tail -1 stdout], [0],
 OVS_VSWITCHD_STOP
 AT_CLEANUP
 
+AT_SETUP([ofproto-dpif - mirroring, select_all with snaplen and reset snaplen])
+AT_KEYWORDS([mirror mirrors mirroring])
+OVS_VSWITCHD_START
+add_of_ports br0 1 2 3
+ovs-vsctl \
+        set Bridge br0 mirrors=@m --\
+        --id=@p3 get Port p3 --\
+        --id=@m create Mirror name=mymirror select_all=true output_port=@p3 snaplen=100
+
+AT_DATA([flows.txt], [dnl
+in_port=1 actions=output:2
+in_port=2 actions=output:1
+])
+AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
+
+flow="in_port(1),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=1,tos=0,ttl=128,frag=no),icmp(type=8,code=0)"
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow"], [0], [stdout])
+AT_CHECK_UNQUOTED([tail -1 stdout], [0],
+  [Datapath actions: trunc(100),3,2
+])
+
+ovs-vsctl set mirror mymirror snaplen=77
+
+flow="in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=1,tos=0,ttl=128,frag=no),icmp(type=8,code=0)"
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow"], [0], [stdout])
+AT_CHECK_UNQUOTED([tail -1 stdout], [0],
+  [Datapath actions: trunc(77),3,1
+])
+
+ovs-vsctl set mirror mymirror snaplen=65535
+
+flow="in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=1,tos=0,ttl=128,frag=no),icmp(type=8,code=0)"
+AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow"], [0], [stdout])
+AT_CHECK_UNQUOTED([tail -1 stdout], [0],
+  [Datapath actions: 3,1
+])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
 AT_SETUP([ofproto-dpif - mirroring, select_src with snaplen])
 AT_KEYWORDS([mirror mirrors mirroring])
 OVS_VSWITCHD_START
@@ -6241,6 +6315,13 @@ AT_SETUP([ofproto-dpif - Flow IPFIX sanity check])
 OVS_VSWITCHD_START
 add_of_ports br0 1 2
 
+# Check for regression against a bug where an invalid target caused an
+# assertion failure and a crash.
+AT_CHECK([ovs-vsctl -- --id=@br0 get Bridge br0 \
+                    -- --id=@ipfix create IPFIX targets=\"xyzzy\" \
+                    -- --id=@cs create Flow_Sample_Collector_Set id=0 bridge=@br0 ipfix=@ipfix],
+         [0], [ignore])
+
 AT_CHECK([ovs-vsctl -- --id=@br0 get Bridge br0 \
                     -- --id=@ipfix create IPFIX targets=\"127.0.0.1:4739\" \
                     -- --id=@cs create Flow_Sample_Collector_Set id=1 bridge=@br0 ipfix=@ipfix],
@@ -6274,7 +6355,9 @@ flow-dump from non-dpdk interfaces:
 packets:2, bytes:68, used:0.001s, actions:drop
 ])
 
-OVS_VSWITCHD_STOP(["/sending to collector failed/d"])
+OVS_VSWITCHD_STOP(["/sending to collector failed/d
+/xyzzy/d
+/no collectors/d"])
 AT_CLEANUP
 
 dnl Flow IPFIX sanity check for tunnel set
@@ -6340,7 +6423,7 @@ AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(3),eth(src=50:54:00:00:00:
 dnl Make sure flow sample action in datapath is behind set tunnel
 dnl action at egress point of tunnel port.
 AT_CHECK([tail -1 stdout], [0], [dnl
-Datapath actions: set(tunnel(tun_id=0x5,src=2.2.2.2,dst=1.1.1.1,tos=0x1,ttl=64,flags(df|key))),sample(sample=100.0%,actions(userspace(pid=0,flow_sample(probability=65535,collector_set_id=1,obs_domain_id=0,obs_point_id=0,output_port=1),tunnel_out_port=1))),1,set(tunnel(tun_id=0x6,src=2.2.2.3,dst=1.1.1.2,tos=0x1,ttl=64,flags(df|key))),sample(sample=100.0%,actions(userspace(pid=0,flow_sample(probability=65535,collector_set_id=1,obs_domain_id=0,obs_point_id=0,output_port=7471),tunnel_out_port=7471))),7471
+Datapath actions: set(tunnel(tun_id=0x5,src=2.2.2.2,dst=1.1.1.1,tos=0x1,ttl=64,flags(df|key))),sample(sample=100.0%,actions(userspace(pid=0,flow_sample(probability=65535,collector_set_id=1,obs_domain_id=0,obs_point_id=0,output_port=1),tunnel_out_port=1))),1,set(tunnel(tun_id=0x6,src=2.2.2.3,dst=1.1.1.2,tos=0x1,ttl=64,tp_dst=7471,flags(df|key))),sample(sample=100.0%,actions(userspace(pid=0,flow_sample(probability=65535,collector_set_id=1,obs_domain_id=0,obs_point_id=0,output_port=7471),tunnel_out_port=7471))),7471
 ])
 
 dnl Remove the flow which contains sample action.
@@ -6422,6 +6505,180 @@ AT_CHECK([strip_xids < stdout | sed -n 's/duration=[[0-9]]*\.[[0-9]]*s/duration=
 OVS_VSWITCHD_STOP
 AT_CLEANUP
 
+AT_SETUP([ofproto-dpif - flow stats reset_counts])
+OVS_VSWITCHD_START
+flow="ip,actions=NORMAL"
+
+ovs-appctl time/stop
+
+AT_CHECK([ovs-ofctl add-flow br0 $flow])
+
+warp_and_dump_NXM () {
+    AT_CHECK([ovs-appctl time/warp 1000], [0], [ignore])
+    AT_CHECK([ovs-appctl revalidator/purge], [0])
+
+    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br0], [0], [stdout])
+    if [[ $5 -gt 0 ]]; then
+        expected=" cookie=0x0, duration=$1s, table=0, n_packets=$2, n_bytes=$3, idle_age=$4, hard_age=$5, ip actions=NORMAL"
+    else
+        expected=" cookie=0x0, duration=$1s, table=0, n_packets=$2, n_bytes=$3, idle_age=$4, ip actions=NORMAL"
+    fi
+    AT_CHECK_UNQUOTED([strip_xids < stdout | sed -n 's/duration=\([[0-9]]*\)\.*[[0-9]]*s/duration=\1s/p' | sort], [0], [dnl
+$expected
+])
+}
+
+warp_and_dump_OF () {
+    AT_CHECK([ovs-appctl time/warp 1000], [0], [ignore])
+    AT_CHECK([ovs-appctl revalidator/purge], [0])
+
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 dump-flows br0], [0], [stdout])
+    if [[ $1 -lt 13 -o "$5X" = "X" ]]; then
+        expected=" cookie=0x0, duration=$2s, table=0, n_packets=$3, n_bytes=$4, ip actions=NORMAL"
+    else
+        expected=" cookie=0x0, duration=$2s, table=0, n_packets=$3, n_bytes=$4, $5 ip actions=NORMAL"
+    fi
+    AT_CHECK_UNQUOTED([strip_xids < stdout | sed -n 's/duration=\([[0-9]]*\)\.*[[0-9]]*s/duration=\1s/p' | sort], [0], [dnl
+$expected
+])
+}
+
+send_packet () {
+    ovs-appctl netdev-dummy/receive br0 'in_port(0),eth(src=50:54:00:00:00:07,dst=50:54:00:00:00:05),eth_type(0x0800),ipv4(src=192.168.0.2,dst=192.168.0.1,proto=6,tos=0,ttl=64,frag=no)'
+}
+
+# OpenFlow 1.0, implicit reset_counts
+send_packet
+warp_and_dump_NXM   1 1 54 1
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow10 add-flow br0 $flow])
+# add-flow resets duration and counts,
+# but idle age is inherited from the old flow
+warp_and_dump_NXM   1 0 0  2
+
+send_packet
+warp_and_dump_NXM   2 1 54 1
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow10 mod-flows br0 $flow])
+# mod-flows resets hard_age, but not counts
+# but duration and idle_age is inherited from the old flow
+warp_and_dump_NXM   3 1 54  2 1
+
+# OpenFlow 1.1, implicit reset_counts
+send_packet
+warp_and_dump_OF 11 4 2 108
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow11 add-flow br0 $flow])
+# add-flow resets duration and counts,
+# but idle age is inherited from the old flow
+warp_and_dump_NXM   1 0 0  2
+warp_and_dump_OF 11 2 0 0
+
+send_packet
+warp_and_dump_OF 11 3 1 54
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow11 mod-flows br0 $flow])
+# mod-flows resets hard_age, but not counts
+# but duration and idle_age is inherited from the old flow
+warp_and_dump_NXM   4 1 54  2 1
+warp_and_dump_OF 11 5 1 54
+
+# OpenFlow 1.2, explicit reset_counts
+send_packet
+warp_and_dump_OF 12 6 2 108
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow12 add-flow br0 $flow])
+# add-flow without flags resets duration, but not counts,
+# idle age is inherited from the old flow
+warp_and_dump_NXM   1 2 108  2
+warp_and_dump_OF 12 2 2 108
+
+send_packet
+warp_and_dump_OF 12 3 3 162
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow12 mod-flows br0 $flow])
+# mod-flows without flags does not reset duration nor counts,
+# idle age is inherited from the old flow
+warp_and_dump_NXM   4 3 162  2 1
+warp_and_dump_OF 12 5 3 162
+
+send_packet
+warp_and_dump_OF 12 6 4 216
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow12 add-flow br0 reset_counts,$flow])
+# add-flow with reset_counts resets both duration and counts,
+# idle age is inherited from the old flow
+warp_and_dump_NXM   1 0 0  2
+warp_and_dump_OF 12 2 0 0
+
+send_packet
+warp_and_dump_OF 12 3 1 54
+AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow12 mod-flows br0 reset_counts,$flow])
+# mod-flows with reset_counts resets counts, but not duration,
+# idle age is inherited from the old flow
+warp_and_dump_NXM   4 0 0  2 1
+warp_and_dump_OF 12 5 0 0
+
+# OpenFlow > 1.3, explicit reset_counts
+flow_mods_reset_counts () {
+    # Reset to a known state
+    AT_CHECK([ovs-ofctl add-flow br0 $flow])
+
+    send_packet
+    warp_and_dump_OF $1 1 1 54 reset_counts
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 add-flow br0 $flow])
+    # add-flow without flags resets duration, but not counts,
+    # idle age is inherited from the old flow
+    warp_and_dump_NXM   1 1 54  2
+    warp_and_dump_OF $1 2 1 54
+
+    send_packet
+    warp_and_dump_OF $1 3 2 108
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 mod-flows br0 $flow])
+    # mod-flows without flags does not reset duration nor counts,
+    # idle age is inherited from the old flow
+    warp_and_dump_NXM   4 2 108  2 1
+    warp_and_dump_OF $1 5 2 108
+
+    send_packet
+    warp_and_dump_OF $1 6 3 162
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 add-flow br0 reset_counts,$flow])
+    # add-flow with reset_counts resets both duration and counts,
+    # idle age is inherited from the old flow
+    warp_and_dump_NXM   1 0 0  2
+    warp_and_dump_OF $1 2 0 0 reset_counts
+
+    send_packet
+    warp_and_dump_OF $1 3 1 54 reset_counts
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 mod-flows br0 reset_counts,$flow])
+    # mod-flows with reset_counts resets counts, but not duration,
+    # idle age is inherited from the old flow
+    warp_and_dump_NXM   4 0 0  2 1
+    warp_and_dump_OF $1 5 0 0 reset_counts
+
+    # Modify flow having reset_counts flag without reset_counts
+    send_packet
+    warp_and_dump_OF $1 6 1 54 reset_counts
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 mod-flows br0 $flow])
+    warp_and_dump_NXM   7 1 54  2 1
+    warp_and_dump_OF $1 8 1 54 reset_counts
+
+    # Add flow having reset_counts flag without reset_counts
+    send_packet
+    warp_and_dump_OF $1 9 2 108 reset_counts
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 add-flow br0 $flow])
+    warp_and_dump_NXM   1 2 108  2
+    warp_and_dump_OF $1 2 2 108
+
+    # Modify flow w/o reset_counts flag with a flow_mod having reset_counts
+    send_packet
+    warp_and_dump_OF $1 3 3 162
+    AT_CHECK_UNQUOTED([ovs-ofctl -O OpenFlow$1 mod-flows br0 reset_counts,$flow])
+    warp_and_dump_NXM   4 0 0  2 1
+    warp_and_dump_OF $1 5 0 0
+}
+
+# OpenFlow versions >= 1.3 should behave the same way
+flow_mods_reset_counts 13
+flow_mods_reset_counts 14
+flow_mods_reset_counts 15
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
 AT_SETUP([ofproto-dpif - flow stats, set-n-threads])
 OVS_VSWITCHD_START
 AT_CHECK([ovs-ofctl add-flow br0 "ip,actions=NORMAL"])
@@ -8592,13 +8849,13 @@ OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 
 dnl Check this output.
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
-NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=42 ct_mark=0x1,in_port=1 (via action) data_len=42 (unbuffered)
+NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=42 in_port=1 (via action) data_len=42 (unbuffered)
 udp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.1.1.1,nw_dst=10.1.1.2,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=1,tp_dst=2 udp_csum:e9d6
 dnl
-NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=42 ct_mark=0x3,in_port=1 (via action) data_len=42 (unbuffered)
+NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=42 in_port=1 (via action) data_len=42 (unbuffered)
 udp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.1.1.1,nw_dst=10.1.1.2,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=3,tp_dst=4 udp_csum:e9d2
 dnl
-NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=42 ct_mark=0x5,in_port=1 (via action) data_len=42 (unbuffered)
+NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=42 in_port=1 (via action) data_len=42 (unbuffered)
 udp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.1.1.1,nw_dst=10.1.1.2,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=5,tp_dst=6 udp_csum:e9ce
 dnl
 NXT_PACKET_IN (xid=0x0): table_id=1 cookie=0x0 total_len=42 ct_state=est|rpl|trk,ct_mark=0x1,in_port=2 (via action) data_len=42 (unbuffered)
diff --git a/tests/ofproto.at b/tests/ofproto.at
index 6e55270c7..96a5e7ea6 100644
--- a/tests/ofproto.at
+++ b/tests/ofproto.at
@@ -1239,7 +1239,7 @@ do
     AT_CHECK_UNQUOTED([strip_xids < stdout], [0], [dnl
 OFPT_FEATURES_REPLY (OF1.4): dpid:fedcba9876543210
 n_tables:254, n_buffers:256
-capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS QUEUE_STATS
+capabilities: FLOW_STATS TABLE_STATS PORT_STATS GROUP_STATS QUEUE_STATS BUNDLES
 OFPST_PORT_DESC reply (OF1.4):
  LOCAL(br0): addr:aa:55:aa:55:00:00
      config:     $config
diff --git a/tests/ovn.at b/tests/ovn.at
index 56d47e758..65a4bf1ff 100644
--- a/tests/ovn.at
+++ b/tests/ovn.at
@@ -594,6 +594,38 @@ dl_src=00:00:00:00:00:02
 dl_src=00:00:00:00:00:03
 dl_src=ba:be:be:ef:de:ad
 ])
+AT_CHECK([expr_to_flow 'ip4.src == {$set4}'], [0], [dnl
+(no flows)
+])
+AT_CHECK([expr_to_flow 'ip4.src == {1.2.3.4, $set4}'], [0], [dnl
+ip,nw_src=1.2.3.4
+])
+AT_CHECK([expr_to_flow 'ip4.src == 1.2.3.4 || ip4.src == {$set4}'], [0], [dnl
+ip,nw_src=1.2.3.4
+])
+AT_CHECK([expr_to_flow 'ip4.src != {$set4}'], [0], [dnl
+
+])
+AT_CHECK([expr_to_flow 'ip4.src != {1.0.0.0/8, $set4}'], [0], [dnl
+ip,nw_src=0.0.0.0/1.0.0.0
+ip,nw_src=128.0.0.0/1
+ip,nw_src=16.0.0.0/16.0.0.0
+ip,nw_src=2.0.0.0/2.0.0.0
+ip,nw_src=32.0.0.0/32.0.0.0
+ip,nw_src=4.0.0.0/4.0.0.0
+ip,nw_src=64.0.0.0/64.0.0.0
+ip,nw_src=8.0.0.0/8.0.0.0
+])
+AT_CHECK([expr_to_flow 'ip4.src != 1.0.0.0/8 && ip4.src != {$set4}'], [0], [dnl
+ip,nw_src=0.0.0.0/1.0.0.0
+ip,nw_src=128.0.0.0/1
+ip,nw_src=16.0.0.0/16.0.0.0
+ip,nw_src=2.0.0.0/2.0.0.0
+ip,nw_src=32.0.0.0/32.0.0.0
+ip,nw_src=4.0.0.0/4.0.0.0
+ip,nw_src=64.0.0.0/64.0.0.0
+ip,nw_src=8.0.0.0/8.0.0.0
+])
 AT_CLEANUP
 
 AT_SETUP([ovn -- action parsing])
@@ -935,14 +967,14 @@ put_nd(inport, nd.target, nd.sll);
 
 # put_dhcpv6_opts
 reg1[0] = put_dhcpv6_opts(ia_addr = ae70::4, server_id = 00:00:00:00:10:02);
-    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.05.00.10.00.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.04.02.00.06.00.00.00.00.00.10.02,pause)
+    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.05.00.10.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.04.00.02.00.06.00.00.00.00.10.02,pause)
 reg1[0] = put_dhcpv6_opts();
     encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40,pause)
 reg1[0] = put_dhcpv6_opts(dns_server={ae70::1,ae70::2});
     formats as reg1[0] = put_dhcpv6_opts(dns_server = {ae70::1, ae70::2});
-    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.17.00.20.00.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.01.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.02,pause)
+    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.17.00.20.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.01.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.02,pause)
 reg1[0] = put_dhcpv6_opts(domain_search = "ovn.org");
-    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.18.00.07.00.6f.76.6e.2e.6f.72.67,pause)
+    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.18.00.07.6f.76.6e.2e.6f.72.67,pause)
 reg1[0] = put_dhcpv6_opts(x = 1.2.3.4);
     Syntax error at `x' expecting DHCPv6 option name.
 reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, "hi");
@@ -1710,9 +1742,7 @@ vtep-ctl add-ls lsw0
 start_daemon ovs-vtep br-vtep
 start_daemon ovn-controller-vtep --vtep-db=unix:"$ovs_base"/vtep/db.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock
 
-sleep 1
-
-vtep-ctl bind-ls br-vtep br-vtep_n2 0 lsw0
+OVS_WAIT_UNTIL([vtep-ctl bind-ls br-vtep br-vtep_n2 0 lsw0])
 
 OVS_WAIT_UNTIL([test -n "`as vtep vtep-ctl get-replication-mode lsw0 |
                grep -- source`"])
@@ -3579,8 +3609,17 @@ as hv1 ovs-vsctl show
 # This shell function sends a DHCP request packet
 # test_dhcp INPORT SRC_MAC DHCP_TYPE OFFER_IP ...
 test_dhcp() {
-    local inport=$1 src_mac=$2 dhcp_type=$3 offer_ip=$4
-    local request=ffffffffffff${src_mac}080045100110000000008011000000000000ffffffff
+    local inport=$1 src_mac=$2 dhcp_type=$3 offer_ip=$4 use_ip=$5
+    shift; shift; shift; shift; shift;
+    if test $use_ip != 0; then
+        src_ip=$1
+        dst_ip=$2
+        shift; shift;
+    else
+        src_ip=`ip_to_hex 0 0 0 0`
+        dst_ip=`ip_to_hex 255 255 255 255`
+    fi
+    local request=ffffffffffff${src_mac}0800451001100000000080110000${src_ip}${dst_ip}
     # udp header and dhcp header
     request=${request}0044004300fc0000
     request=${request}010106006359aa760000000000000000000000000000000000000000${src_mac}
@@ -3600,7 +3639,7 @@ test_dhcp() {
     request=${request}3501${dhcp_type}ff
 
     if test $offer_ip != 0; then
-        local srv_mac=$5 srv_ip=$6 expected_dhcp_opts=$7
+        local srv_mac=$1 srv_ip=$2 expected_dhcp_opts=$3
         # total IP length will be the IP length of the request packet
         # (which is 272 in our case) + 8 (padding bytes) + (expected_dhcp_opts / 2)
         ip_len=`expr 280 + ${#expected_dhcp_opts} / 2`
@@ -3636,7 +3675,6 @@ test_dhcp() {
         reply=${reply}3501${dhcp_reply_type}${expected_dhcp_opts}00000000ff00000000
         echo $reply >> $inport.expected
     else
-        shift; shift; shift; shift;
         for outport; do
             echo $request >> $outport.expected
         done
@@ -3681,8 +3719,8 @@ as hv1 ovs-ofctl dump-flows br-int
 # Send DHCPDISCOVER.
 offer_ip=`ip_to_hex 10 0 0 4`
 server_ip=`ip_to_hex 10 0 0 1`
-expected_dhcp_opts=0104ffffff0003040a00000136040a000001330400000e10
-test_dhcp 1 f00000000001 01 $offer_ip ff1000000001 $server_ip $expected_dhcp_opts
+expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
+test_dhcp 1 f00000000001 01 $offer_ip 0 ff1000000001 $server_ip $expected_dhcp_opts
 
 # NXT_RESUMEs should be 1.
 OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
@@ -3704,8 +3742,8 @@ rm -f 2.expected
 # Send DHCPREQUEST.
 offer_ip=`ip_to_hex 10 0 0 6`
 server_ip=`ip_to_hex 10 0 0 1`
-expected_dhcp_opts=0104ffffff0003040a00000136040a000001330400000e10
-test_dhcp 2 f00000000002 03 $offer_ip ff1000000001 $server_ip $expected_dhcp_opts
+expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
+test_dhcp 2 f00000000002 03 $offer_ip 0 ff1000000001 $server_ip $expected_dhcp_opts
 
 # NXT_RESUMEs should be 2.
 OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
@@ -3727,7 +3765,7 @@ rm -f 2.expected
 # ls1-lp1 (vif1-tx.pcap) should receive the DHCPv4 request packet twice,
 # one from ovn-controller and the other from "ovs-ofctl resume."
 offer_ip=0
-test_dhcp 2 f00000000002 08 $offer_ip 1 1
+test_dhcp 2 f00000000002 08 $offer_ip 0 1 1
 
 # NXT_RESUMEs should be 3.
 OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
@@ -3743,11 +3781,11 @@ rm -f 2.expected
 # Send DHCPv4 packet on ls2-lp1. It doesn't have any DHCPv4 options defined.
 # ls2-lp2 (vif4-tx.pcap) should receive the DHCPv4 request packet once.
 
-test_dhcp 3 f00000000003 01 0 4
+test_dhcp 3 f00000000003 01 0 4 0
 
 # Send DHCPv4 packet on ls2-lp2. "router" DHCPv4 option is not defined for
 # this lport.
-test_dhcp 4 f00000000004 01 0 3
+test_dhcp 4 f00000000004 01 0 3 0
 
 # NXT_RESUMEs should be 3.
 OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
@@ -3755,6 +3793,64 @@ OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
 OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [3.expected])
 OVN_CHECK_PACKETS([hv1/vif4-tx.pcap], [4.expected])
 
+# Send DHCPREQUEST with ip4.src set to 10.0.0.6 and ip4.dst set to 10.0.0.1.
+offer_ip=`ip_to_hex 10 0 0 6`
+server_ip=`ip_to_hex 10 0 0 1`
+expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
+src_ip=$offer_ip
+dst_ip=$server_ip
+test_dhcp 2 f00000000002 03 $offer_ip 1 $src_ip $dst_ip ff1000000001 $server_ip $expected_dhcp_opts
+
+# NXT_RESUMEs should be 4.
+OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
+
+$PYTHON "$top_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
+cat 2.expected | cut -c -48 > expout
+AT_CHECK([cat 2.packets | cut -c -48], [0], [expout])
+# Skipping the IPv4 checksum.
+cat 2.expected | cut -c 53- > expout
+AT_CHECK([cat 2.packets | cut -c 53-], [0], [expout])
+
+reset_pcap_file hv1-vif1 hv1/vif1
+reset_pcap_file hv1-vif2 hv1/vif2
+rm -f 1.expected
+rm -f 2.expected
+
+# Send DHCPREQUEST with ip4.src set to 10.0.0.6 and ip4.dst set to 255.255.255.255.
+offer_ip=`ip_to_hex 10 0 0 6`
+server_ip=`ip_to_hex 10 0 0 1`
+expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
+src_ip=$offer_ip
+dst_ip=`ip_to_hex 255 255 255 255`
+test_dhcp 2 f00000000002 03 $offer_ip 1 $src_ip $dst_ip ff1000000001 $server_ip $expected_dhcp_opts
+
+# NXT_RESUMEs should be 5.
+OVS_WAIT_UNTIL([test 5 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
+
+$PYTHON "$top_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
+cat 2.expected | cut -c -48 > expout
+AT_CHECK([cat 2.packets | cut -c -48], [0], [expout])
+# Skipping the IPv4 checksum.
+cat 2.expected | cut -c 53- > expout
+AT_CHECK([cat 2.packets | cut -c 53-], [0], [expout])
+
+reset_pcap_file hv1-vif1 hv1/vif1
+reset_pcap_file hv1-vif2 hv1/vif2
+rm -f 1.expected
+rm -f 2.expected
+
+# Send DHCPREQUEST with ip4.src set to 10.0.0.6 and ip4.dst set to 10.0.0.4.
+# The packet should not be received by ovn-controller.
+src_ip=`ip_to_hex 10 0 0 6`
+dst_ip=`ip_to_hex 10 0 0 4`
+test_dhcp 2 f00000000002 03 0 1 $src_ip $dst_ip 1
+
+# NXT_RESUMEs should be 5.
+OVS_WAIT_UNTIL([test 5 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
+
+# vif1-tx.pcap should have received the DHCPv4 request packet
+OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])
+
 as hv1
 OVS_APP_EXIT_AND_WAIT([ovn-controller])
 OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])
diff --git a/tests/ovs-router.at b/tests/ovs-router.at
new file mode 100644
index 000000000..93a730a8c
--- /dev/null
+++ b/tests/ovs-router.at
@@ -0,0 +1,42 @@
+AT_BANNER([ovs-router])
+
+AT_SETUP([appctl - route/add with gateway])
+AT_KEYWORDS([ovs_router])
+AT_XFAIL_IF([test "$IS_WIN32" = "yes"])
+OVS_VSWITCHD_START([add-port br0 p2 -- set Interface p2 type=gre \
+			options:local_ip=2.2.2.2 options:remote_ip=1.1.1.1 \
+			-- add-port br0 p1  -- set interface p1 type=dummy])
+AT_CHECK([ovs-appctl netdev-dummy/ip4addr br0 2.2.2.2/24], [0], [OK
+])
+AT_CHECK([ovs-appctl ovs/route/add 1.1.1.0/24 br0 2.2.2.10], [0], [OK
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([appctl - route/lookup])
+AT_KEYWORDS([ovs_router])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=dummy])
+AT_CHECK([ovs-appctl netdev-dummy/ip4addr br0 192.0.2.1/24], [0], [OK
+])
+AT_CHECK([ovs-appctl ovs/route/add 198.51.100.0/24 br0 192.0.2.254], [0], [OK
+])
+AT_CHECK([ovs-appctl ovs/route/lookup 198.51.100.1], [0], [src 192.0.2.1
+gateway 192.0.2.254
+dev br0
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
+AT_SETUP([appctl - route/lookup6])
+AT_KEYWORDS([ovs_router])
+OVS_VSWITCHD_START([add-port br0 p1 -- set Interface p1 type=dummy])
+AT_CHECK([ovs-appctl netdev-dummy/ip6addr br0 2001:db8:cafe::1/64], [0], [OK
+])
+AT_CHECK([ovs-appctl ovs/route/add 2001:db8:babe::/64 br0 2001:db8:cafe::2], [0], [OK
+])
+AT_CHECK([ovs-appctl ovs/route/lookup 2001:db8:babe::1eaf], [0], [src 2001:db8:cafe::1
+gateway 2001:db8:cafe::2
+dev br0
+])
+OVS_VSWITCHD_STOP
+AT_CLEANUP
diff --git a/tests/ovs-vsctl.at b/tests/ovs-vsctl.at
index 51717869b..14a3879e2 100644
--- a/tests/ovs-vsctl.at
+++ b/tests/ovs-vsctl.at
@@ -762,6 +762,9 @@ AT_CHECK([RUN_OVS_VSCTL([add-br br1])],
   [0], [ignore], [], [OVS_VSCTL_CLEANUP])
 AT_CHECK([RUN_OVS_VSCTL([set-controller br1 tcp:127.0.0.1])],
   [0], [ignore], [], [OVS_VSCTL_CLEANUP])
+AT_CHECK([RUN_OVS_VSCTL([list netflow br0])], [1], [],
+  [ovs-vsctl: no row "br0" in table NetFlow
+], [OVS_VSCTL_CLEANUP])
 AT_CHECK([
     RUN_OVS_VSCTL_TOGETHER([--id=@n create netflow targets='"1.2.3.4:567"'],
                            [set bridge br0 netflow=@n])],
diff --git a/tests/pmd.at b/tests/pmd.at
index 7b63b6713..b715a9252 100644
--- a/tests/pmd.at
+++ b/tests/pmd.at
@@ -259,6 +259,13 @@ NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=42 in_port=1 (via action) data_le
 icmp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.0.0.2,nw_dst=10.0.0.1,nw_tos=0,nw_ecn=0,nw_ttl=64,icmp_type=8,icmp_code=0 icmp_csum:f7ff
 ])
 
+dnl Check resetting to default number of rx queues after removal from the db.
+AT_CHECK([ovs-vsctl remove interface p1 options n_rxq])
+
+AT_CHECK([ovs-appctl dpif/show | grep p1 | sed 's/\(tx_queues=\)[[0-9]]*/\1<cleared>/g'], [0], [dnl
+		p1 1/1: (dummy-pmd: configured_rx_queues=1, configured_tx_queues=<cleared>, requested_rx_queues=1, requested_tx_queues=<cleared>)
+])
+
 OVS_VSWITCHD_STOP
 AT_CLEANUP
 
@@ -330,14 +337,22 @@ AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl --detach --no-chdir --pidfile
 
 AT_CHECK([ovs-appctl netdev-dummy/receive p1 --qid 0 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x0800),ipv4(src=10.0.0.2,dst=10.0.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=8,code=0)'])
 
-AT_CHECK([ovs-appctl netdev-dummy/receive p2 --qid 1 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x0800),ipv4(src=10.0.0.2,dst=10.0.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=8,code=0)'])
-
-OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 4])
+OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=42 in_port=1 (via action) data_len=42 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.0.0.2,nw_dst=10.0.0.1,nw_tos=0,nw_ecn=0,nw_ttl=64,icmp_type=8,icmp_code=0 icmp_csum:f7ff
+])
+
+AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl --detach --no-chdir --pidfile 2> ofctl_monitor.log])
+
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 --qid 1 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x0800),ipv4(src=10.0.0.2,dst=10.0.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=8,code=0)'])
+
+OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])
+OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
+
+AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=42 in_port=2 (via action) data_len=42 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.0.0.2,nw_dst=10.0.0.1,nw_tos=0,nw_ecn=0,nw_ttl=64,icmp_type=8,icmp_code=0 icmp_csum:f7ff
 ])
@@ -355,14 +370,22 @@ AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl --detach --no-chdir --pidfile
 
 AT_CHECK([ovs-appctl netdev-dummy/receive p1 --qid 1 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x0800),ipv4(src=10.0.0.2,dst=10.0.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=8,code=0)'])
 
-AT_CHECK([ovs-appctl netdev-dummy/receive p2 --qid 0 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x0800),ipv4(src=10.0.0.2,dst=10.0.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=8,code=0)'])
-
-OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 4])
+OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])
 OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
 
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=42 in_port=1 (via action) data_len=42 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.0.0.2,nw_dst=10.0.0.1,nw_tos=0,nw_ecn=0,nw_ttl=64,icmp_type=8,icmp_code=0 icmp_csum:f7ff
+])
+
+AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl --detach --no-chdir --pidfile 2> ofctl_monitor.log])
+
+AT_CHECK([ovs-appctl netdev-dummy/receive p2 --qid 0 'in_port(1),eth(src=50:54:00:00:00:09,dst=50:54:00:00:00:0a),eth_type(0x0800),ipv4(src=10.0.0.2,dst=10.0.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=8,code=0)'])
+
+OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 2])
+OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])
+
+AT_CHECK([cat ofctl_monitor.log], [0], [dnl
 NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=42 in_port=2 (via action) data_len=42 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=50:54:00:00:00:09,dl_dst=50:54:00:00:00:0a,nw_src=10.0.0.2,nw_dst=10.0.0.1,nw_tos=0,nw_ecn=0,nw_ttl=64,icmp_type=8,icmp_code=0 icmp_csum:f7ff
 ])
@@ -517,6 +540,62 @@ p1 3 0 2
 OVS_VSWITCHD_STOP(["/dpif_netdev|WARN|There is no PMD thread on core/d"])
 AT_CLEANUP
 
+AT_SETUP([PMD - rxq affinity - NUMA])
+OVS_VSWITCHD_START(
+  [], [], [], [--dummy-numa 0,0,0,1,1])
+AT_CHECK([ovs-appctl vlog/set dpif:dbg dpif_netdev:dbg])
+
+AT_CHECK([ovs-ofctl add-flow br0 actions=controller])
+
+AT_CHECK([ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=7e])
+
+AT_CHECK([ovs-vsctl add-port br0 p1 -- set Interface p1 type=dummy-pmd ofport_request=1 options:n_rxq=2 options:numa_id=0 other_config:pmd-rxq-affinity="0:1,1:2"])
+
+dnl The rxqs should be on the requested cores.
+AT_CHECK([ovs-appctl dpif-netdev/pmd-rxq-show | parse_pmd_rxq_show], [0], [dnl
+p1 0 0 1
+p1 1 0 2
+])
+
+AT_CHECK([ovs-vsctl set Interface p1 other_config:pmd-rxq-affinity="0:3,1:4"])
+
+dnl We moved the queues to different numa node. Expecting threads on
+dnl NUMA node 1 to be created.
+AT_CHECK([ovs-appctl dpif-netdev/pmd-rxq-show | parse_pmd_rxq_show], [0], [dnl
+p1 0 1 3
+p1 1 1 4
+])
+
+AT_CHECK([ovs-vsctl set Interface p1 other_config:pmd-rxq-affinity="0:3,1:1"])
+
+dnl Queues splitted between NUMA nodes.
+AT_CHECK([ovs-appctl dpif-netdev/pmd-rxq-show | parse_pmd_rxq_show], [0], [dnl
+p1 0 1 3
+p1 1 0 1
+])
+
+AT_CHECK([ovs-vsctl remove Interface p1 other_config pmd-rxq-affinity])
+
+dnl We removed the rxq-affinity request.  dpif-netdev should assign queues
+dnl in a round robin fashion.  We just make sure that every rxq is being
+dnl polled again.
+AT_CHECK([ovs-appctl dpif-netdev/pmd-rxq-show | parse_pmd_rxq_show | cut -f 1,2 -d ' ' | sort], [0], [dnl
+p1 0
+p1 1
+])
+
+AT_CHECK([ovs-vsctl set Interface p1 other_config:pmd-rxq-affinity='0:3'])
+
+dnl We explicitly requesting NUMA node 1 for queue 0.
+dnl Queue 1 should be polled by thread from NUMA node 0.
+AT_CHECK([ovs-appctl dpif-netdev/pmd-rxq-show | parse_pmd_rxq_show | cut -f 1,2,3 -d ' '], [0], [dnl
+p1 0 1
+p1 1 0
+])
+
+OVS_VSWITCHD_STOP
+AT_CLEANUP
+
 AT_SETUP([PMD - monitor threads])
 OVS_VSWITCHD_START(
   [], [], [], [--dummy-numa 0,0])
diff --git a/tests/system-traffic.at b/tests/system-traffic.at
index 10b264726..eb10dc8a2 100644
--- a/tests/system-traffic.at
+++ b/tests/system-traffic.at
@@ -1437,12 +1437,8 @@ ADD_VETH(p1, at_ns1, br0, "172.16.0.2/24")
 
 dnl Allow any traffic from ns0->ns1. Only allow nd, return traffic from ns1->ns0.
 AT_DATA([flows.txt], [dnl
-priority=1,action=drop
-priority=10,arp,action=normal
-priority=100,in_port=1,udp,ct_state=-trk,action=ct(commit,table=0)
-priority=100,in_port=1,ip,ct_state=+trk,actions=controller
-priority=100,in_port=2,ip,ct_state=-trk,action=ct(table=0)
-priority=100,in_port=2,ip,ct_state=+trk+rel+rpl,action=controller
+table=0,ip,action=ct(commit,table=1)
+table=1,ip,action=controller
 ])
 
 AT_CHECK([ovs-ofctl --bundle replace-flows br0 flows.txt])
@@ -1451,22 +1447,31 @@ AT_CAPTURE_FILE([ofctl_monitor.log])
 AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl --detach --no-chdir --pidfile 2> ofctl_monitor.log])
 
 dnl 1. Send an ICMP port unreach reply for port 8738, without any previous request
-AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 2 ct\(table=0\) 'f64c473528c9c6f54ecb72db080045c0003d2e8700004001f355ac100004ac1000030303553f0000000045000021317040004011b138ac100003ac10000411112222000d20966369616f0a'])
+AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 2 resubmit\(,0\) 'f64c473528c9c6f54ecb72db080045c0003d2e8700004001f351ac100004ac1000030303da490000000045000021317040004011b138ac100003ac10000411112222000d20966369616f0a'])
 
 dnl 2. Send and UDP packet to port 5555
-AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 1 ct\(commit,table=0\) 'c6f94ecb72dbe64c473528c9080045000021317040004011b138ac100001ac100002a28e15b3000d20966369616f0a'])
+AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 1 resubmit\(,0\) 'c6f94ecb72dbe64c473528c9080045000021317040004011b138ac100001ac100002a28e15b3000d20966369616f0a'])
 
 dnl 3. Send an ICMP port unreach reply for port 5555, related to the first packet
-AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 2 ct\(table=0\) 'e64c473528c9c6f94ecb72db080045c0003d2e8700004001f355ac100002ac1000010303553f0000000045000021317040004011b138ac100001ac100002a28e15b3000d20966369616f0a'])
+AT_CHECK([ovs-ofctl -O OpenFlow13 packet-out br0 2 resubmit\(,0\) 'e64c473528c9c6f94ecb72db080045c0003d2e8700004001f355ac100002ac1000010303553f0000000045000021317040004011b138ac100001ac100002a28e15b3000d20966369616f0a'])
 
 dnl Check this output. We only see the latter two packets, not the first.
 AT_CHECK([cat ofctl_monitor.log], [0], [dnl
-NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=47 ct_state=new|trk,in_port=1 (via action) data_len=47 (unbuffered)
+NXT_PACKET_IN2 (xid=0x0): table_id=1 cookie=0x0 total_len=75 ct_state=inv|trk,in_port=2 (via action) data_len=75 (unbuffered)
+icmp,vlan_tci=0x0000,dl_src=c6:f5:4e:cb:72:db,dl_dst=f6:4c:47:35:28:c9,nw_src=172.16.0.4,nw_dst=172.16.0.3,nw_tos=192,nw_ecn=0,nw_ttl=64,icmp_type=3,icmp_code=3 icmp_csum:da49
+NXT_PACKET_IN2 (xid=0x0): table_id=1 cookie=0x0 total_len=47 ct_state=new|trk,in_port=1 (via action) data_len=47 (unbuffered)
 udp,vlan_tci=0x0000,dl_src=e6:4c:47:35:28:c9,dl_dst=c6:f9:4e:cb:72:db,nw_src=172.16.0.1,nw_dst=172.16.0.2,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=41614,tp_dst=5555 udp_csum:2096
-NXT_PACKET_IN2 (xid=0x0): cookie=0x0 total_len=75 ct_state=rel|rpl|trk,in_port=2 (via action) data_len=75 (unbuffered)
+NXT_PACKET_IN2 (xid=0x0): table_id=1 cookie=0x0 total_len=75 ct_state=rel|rpl|trk,in_port=2 (via action) data_len=75 (unbuffered)
 icmp,vlan_tci=0x0000,dl_src=c6:f9:4e:cb:72:db,dl_dst=e6:4c:47:35:28:c9,nw_src=172.16.0.2,nw_dst=172.16.0.1,nw_tos=192,nw_ecn=0,nw_ttl=64,icmp_type=3,icmp_code=3 icmp_csum:553f
 ])
 
+AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1)], [0], [dnl
+udp,orig=(src=172.16.0.1,dst=172.16.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>)
+])
+
+AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.3)], [0], [dnl
+])
+
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
 
@@ -2103,6 +2108,58 @@ tcp,orig=(src=10.1.1.1,dst=10.1.1.2,sport=<cleared>,dport=<cleared>),reply=(src=
 OVS_TRAFFIC_VSWITCHD_STOP
 AT_CLEANUP
 
+AT_SETUP([conntrack - SNAT with ct_mark change on reply])
+CHECK_CONNTRACK()
+CHECK_CONNTRACK_NAT()
+OVS_TRAFFIC_VSWITCHD_START()
+
+ADD_NAMESPACES(at_ns0, at_ns1)
+
+ADD_VETH(p0, at_ns0, br0, "10.1.1.1/24")
+NS_CHECK_EXEC([at_ns0], [ip link set dev p0 address 80:88:88:88:88:88])
+ADD_VETH(p1, at_ns1, br0, "10.1.1.2/24")
+
+dnl Allow any traffic from ns0->ns1. Only allow nd, return traffic from ns1->ns0.
+AT_DATA([flows.txt], [dnl
+in_port=1,ip,action=ct(commit,zone=1,nat(src=10.1.1.240-10.1.1.255)),2
+in_port=2,ct_state=-trk,ip,action=ct(table=0,zone=1,nat)
+dnl
+dnl Setting the mark fails if the datapath can't find the existing conntrack
+dnl entry after NAT has been reversed and the skb was lost due to an upcall.
+dnl
+in_port=2,ct_state=+trk,ct_zone=1,ip,action=ct(table=1,commit,zone=1,exec(set_field:1->ct_mark)),1
+table=1,in_port=2,ct_mark=1,ct_state=+rpl,ct_zone=1,ip,action=1
+dnl
+dnl ARP
+priority=100 arp arp_op=1 action=move:OXM_OF_ARP_TPA[[]]->NXM_NX_REG2[[]],resubmit(,8),goto_table:10
+priority=10 arp action=normal
+priority=0,action=drop
+dnl
+dnl MAC resolution table for IP in reg2, stores mac in OXM_OF_PKT_REG0
+table=8,reg2=0x0a0101f0/0xfffffff0,action=load:0x808888888888->OXM_OF_PKT_REG0[[]]
+table=8,priority=0,action=load:0->OXM_OF_PKT_REG0[[]]
+dnl ARP responder mac filled in at OXM_OF_PKT_REG0, or 0 for normal action.
+dnl TPA IP in reg2.
+dnl Swaps the fields of the ARP message to turn a query to a response.
+table=10 priority=100 arp xreg0=0 action=normal
+table=10 priority=10,arp,arp_op=1,action=load:2->OXM_OF_ARP_OP[[]],move:OXM_OF_ARP_SHA[[]]->OXM_OF_ARP_THA[[]],move:OXM_OF_PKT_REG0[[0..47]]->OXM_OF_ARP_SHA[[]],move:OXM_OF_ARP_SPA[[]]->OXM_OF_ARP_TPA[[]],move:NXM_NX_REG2[[]]->OXM_OF_ARP_SPA[[]],move:NXM_OF_ETH_SRC[[]]->NXM_OF_ETH_DST[[]],move:OXM_OF_PKT_REG0[[0..47]]->NXM_OF_ETH_SRC[[]],move:NXM_OF_IN_PORT[[]]->NXM_NX_REG3[[0..15]],load:0->NXM_OF_IN_PORT[[]],output:NXM_NX_REG3[[0..15]]
+table=10 priority=0 action=drop
+])
+
+AT_CHECK([ovs-ofctl --bundle add-flows br0 flows.txt])
+
+dnl HTTP requests from p0->p1 should work fine.
+NETNS_DAEMONIZE([at_ns1], [[$PYTHON $srcdir/test-l7.py]], [http0.pid])
+NS_CHECK_EXEC([at_ns0], [ping -c 1 10.1.1.2 | FORMAT_PING], [0], [dnl
+1 packets transmitted, 1 received, 0% packet loss, time 0ms
+])
+
+AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.1.1.2) | sed -e 's/dst=10.1.1.2[[45]][[0-9]]/dst=10.1.1.2XX/'], [0], [dnl
+icmp,orig=(src=10.1.1.1,dst=10.1.1.2,id=<cleared>,type=8,code=0),reply=(src=10.1.1.2,dst=10.1.1.2XX,id=<cleared>,type=0,code=0),zone=1,mark=1
+])
+
+OVS_TRAFFIC_VSWITCHD_STOP
+AT_CLEANUP
 
 AT_SETUP([conntrack - SNAT with port range])
 CHECK_CONNTRACK()
diff --git a/tests/system-userspace-macros.at b/tests/system-userspace-macros.at
index 7e10b6c21..db7dcb3d8 100644
--- a/tests/system-userspace-macros.at
+++ b/tests/system-userspace-macros.at
@@ -55,7 +55,7 @@ m4_define([OVS_TRAFFIC_VSWITCHD_STOP],
 # This is a workaround, and should be removed when offloads are properly
 # supported in netdev-linux.
 m4_define([CONFIGURE_VETH_OFFLOADS],
-    [AT_CHECK([ethtool -K $1 tx off], [0], [ignore])]
+    [AT_CHECK([ethtool -K $1 tx off], [0], [ignore], [ignore])]
 )
 
 # CHECK_CONNTRACK()
diff --git a/tests/test-cmap.c b/tests/test-cmap.c
index e159a164f..2c6fa89eb 100644
--- a/tests/test-cmap.c
+++ b/tests/test-cmap.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2009, 2010, 2013, 2014, 2016 Nicira, Inc.
+ * Copyright (c) 2008, 2009, 2010, 2013, 2014, 2016, 2017 Nicira, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -412,7 +412,6 @@ find_batch(const struct cmap *cmap, const int value)
 {
     size_t i, ret;
     const size_t end = MIN(n_batch, n_elems - value);
-    unsigned long map = ~0;
     uint32_t hashes[N_BATCH_MAX];
     const struct cmap_node *nodes[N_BATCH_MAX];
 
@@ -431,7 +430,7 @@ find_batch(const struct cmap *cmap, const int value)
 
     ret = i;
 
-    map >>= BITMAP_ULONG_BITS - i; /* Clear excess bits. */
+    unsigned long map = i ? ~0UL >> (BITMAP_ULONG_BITS - i) : 0;
     map = cmap_find_batch(cmap, map, hashes, nodes);
 
     ULLONG_FOR_EACH_1(i, map) {
diff --git a/tests/test-ovn.c b/tests/test-ovn.c
index 2e82a6f0d..a28830bb9 100644
--- a/tests/test-ovn.c
+++ b/tests/test-ovn.c
@@ -201,10 +201,12 @@ create_macros(struct shash *macros)
     static const char *const addrs3[] = {
         "00:00:00:00:00:01", "00:00:00:00:00:02", "00:00:00:00:00:03",
     };
+    static const char *const addrs4[] = { NULL };
 
     expr_macros_add(macros, "set1", addrs1, 3);
     expr_macros_add(macros, "set2", addrs2, 3);
     expr_macros_add(macros, "set3", addrs3, 3);
+    expr_macros_add(macros, "set4", addrs4, 0);
 }
 
 static bool
diff --git a/tests/testsuite.at b/tests/testsuite.at
index f5f125315..d782e9267 100644
--- a/tests/testsuite.at
+++ b/tests/testsuite.at
@@ -51,6 +51,7 @@ m4_include([tests/jsonrpc-py.at])
 m4_include([tests/tunnel.at])
 m4_include([tests/tunnel-push-pop.at])
 m4_include([tests/tunnel-push-pop-ipv6.at])
+m4_include([tests/ovs-router.at])
 m4_include([tests/lockfile.at])
 m4_include([tests/reconnect.at])
 m4_include([tests/ovs-vswitchd.at])
@@ -76,3 +77,4 @@ m4_include([tests/ovn-nbctl.at])
 m4_include([tests/ovn-sbctl.at])
 m4_include([tests/ovn-controller.at])
 m4_include([tests/ovn-controller-vtep.at])
+m4_include([tests/mcast-snooping.at])
diff --git a/tests/tunnel.at b/tests/tunnel.at
index 477517e35..fc6e6f951 100644
--- a/tests/tunnel.at
+++ b/tests/tunnel.at
@@ -550,7 +550,7 @@ AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
 dnl Option generation
 AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(2),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=1,tos=0,ttl=128,frag=no),icmp(type=8,code=0)'], [0], [stdout])
 AT_CHECK([tail -1 stdout], [0],
-  [Datapath actions: set(tunnel(dst=1.1.1.1,ttl=64,geneve({class=0xffff,type=0,len=4,0xa}{class=0xffff,type=0x1,len=8,0x1234567890abcdef}),flags(df))),6081
+  [Datapath actions: set(tunnel(dst=1.1.1.1,ttl=64,tp_dst=6081,geneve({class=0xffff,type=0,len=4,0xa}{class=0xffff,type=0x1,len=8,0x1234567890abcdef}),flags(df))),6081
 ])
 
 dnl Option match
@@ -639,7 +639,7 @@ Datapath actions: 2
 AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'recirc_id(0),tunnel(tun_id=0x0,src=1.1.1.1,dst=1.1.1.2,ttl=64,geneve({class=0xffff,type=1,len=0}),flags(df|key)),in_port(6081),skb_mark(0),eth_type(0x0800),ipv4(frag=no)'], [0], [stdout])
 AT_CHECK([tail -2 stdout], [0],
   [Megaflow: pkt_mark=0,recirc_id=0,ip,tun_id=0,tun_src=1.1.1.1,tun_dst=1.1.1.2,tun_tos=0,tun_flags=+df-csum+key,tun_metadata1,tun_metadata2=NP,in_port=1,nw_ecn=0,nw_frag=no
-Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,geneve({class=0xffff,type=0x1,len=0}),flags(df|key))),6081
+Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=6081,geneve({class=0xffff,type=0x1,len=0}),flags(df|key))),6081
 ])
 
 OVS_VSWITCHD_STOP
@@ -660,12 +660,12 @@ AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
 
 AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'tunnel(tun_id=0,src=1.1.1.1,dst=1.1.1.2,ttl=64),in_port(4789)'], [0], [stdout])
 AT_CHECK([tail -1 stdout], [0],
-  [Datapath actions: set(tunnel(tun_id=0x0,ipv6_dst=2001:cafe::1,ttl=64,flags(df|key))),4789
+  [Datapath actions: set(tunnel(tun_id=0x0,ipv6_dst=2001:cafe::1,ttl=64,tp_dst=4789,flags(df|key))),4789
 ])
 
 AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'tunnel(tun_id=0x0,ipv6_src=2001:cafe::1,ipv6_dst=2001:cafe::2,ttl=64),in_port(4789)'], [0], [stdout])
 AT_CHECK([tail -1 stdout], [0],
-  [Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,flags(df|key))),4789
+  [Datapath actions: set(tunnel(tun_id=0x0,dst=1.1.1.1,ttl=64,tp_dst=4789,flags(df|key))),4789
 ])
 
 
diff --git a/utilities/ovs-ctl.in b/utilities/ovs-ctl.in
index dc275f883..7c61ff0d7 100755
--- a/utilities/ovs-ctl.in
+++ b/utilities/ovs-ctl.in
@@ -75,6 +75,12 @@ ovs_vsctl () {
     ovs-vsctl --no-wait "$@"
 }
 
+set_hostname () {
+    # 'hostname -f' needs network connectivity to work.  So we should
+    # call this only after ovs-vswitchd is running.
+    ovs_vsctl set Open_vSwitch . external-ids:hostname="$(hostname -f)"
+}
+
 set_system_ids () {
     set ovs_vsctl set Open_vSwitch .
 
@@ -108,8 +114,6 @@ set_system_ids () {
     esac
     set "$@" external-ids:system-id="\"$SYSTEM_ID\""
 
-    set "$@" external-ids:hostname="\"$(hostname)\""
-
     if test X"$SYSTEM_TYPE" != X; then
         set "$@" system-type="\"$SYSTEM_TYPE\""
     else
@@ -246,6 +250,7 @@ start_forwarding () {
     if test X"$OVS_VSWITCHD" = Xyes; then
         do_start_forwarding
     fi
+    set_hostname &
 }
 
 ## ---- ##
diff --git a/utilities/ovs-ofctl.c b/utilities/ovs-ofctl.c
index 935979af5..9bc7c2430 100644
--- a/utilities/ovs-ofctl.c
+++ b/utilities/ovs-ofctl.c
@@ -679,16 +679,18 @@ transact_multiple_noreply(struct vconn *vconn, struct ovs_list *requests)
 static void
 bundle_print_errors(struct ovs_list *errors, struct ovs_list *requests)
 {
-    struct vconn_bundle_error *error, *next;
+    struct ofpbuf *error, *next;
     struct ofpbuf *bmsg;
 
     INIT_CONTAINER(bmsg, requests, list_node);
 
     LIST_FOR_EACH_SAFE (error, next, list_node, errors) {
+        const struct ofp_header *error_oh = error->data;
+        ovs_be32 error_xid = error_oh->xid;
         enum ofperr ofperr;
         struct ofpbuf payload;
 
-        ofperr = ofperr_decode_msg(&error->ofp_msg, &payload);
+        ofperr = ofperr_decode_msg(error_oh, &payload);
         if (!ofperr) {
             fprintf(stderr, "***decode error***");
         } else {
@@ -704,7 +706,7 @@ bundle_print_errors(struct ovs_list *errors, struct ovs_list *requests)
             LIST_FOR_EACH_CONTINUE (bmsg, list_node, requests) {
                 const struct ofp_header *oh = bmsg->data;
 
-                if (oh->xid == error->ofp_msg.xid) {
+                if (oh->xid == error_xid) {
                     ofp_msg = oh;
                     msg_len = bmsg->size;
                     break;
@@ -713,7 +715,8 @@ bundle_print_errors(struct ovs_list *errors, struct ovs_list *requests)
             fprintf(stderr, "Error %s for: ", ofperr_get_name(ofperr));
             ofp_print(stderr, ofp_msg, msg_len, verbosity + 1);
         }
-        free(error);
+        ofpbuf_uninit(&payload);
+        ofpbuf_delete(error);
     }
     fflush(stderr);
 }
diff --git a/utilities/ovs-tcpdump.in b/utilities/ovs-tcpdump.in
index b29e691c0..538b3b405 100755
--- a/utilities/ovs-tcpdump.in
+++ b/utilities/ovs-tcpdump.in
@@ -18,7 +18,6 @@ import fcntl
 import netifaces
 import os
 import pwd
-import select
 import struct
 import subprocess
 import sys
@@ -230,7 +229,8 @@ class OVSDB(object):
                                  (port_name, txn.get_error()))
         self._txn = None
 
-    def destroy_mirror(self, mirror_name, bridge_name):
+    def destroy_mirror(self, intf_name, bridge_name):
+        mirror_name = 'm_%s' % intf_name
         if not self.mirror_exists(mirror_name):
             return
         txn = self._start_txn()
@@ -426,17 +426,16 @@ def main():
     pipes = _doexec(*([dump_cmd, '-i', mirror_interface] + tcpdargs))
     try:
         while pipes.poll() is None:
-            data = pipes.stdout.readline()
+            data = pipes.stdout.readline().strip('\n')
             if len(data) == 0:
                 raise KeyboardInterrupt
             print(data)
-            if select.select([sys.stdin], [], [], 0.0)[0]:
-                data_in = sys.stdin.read()
-                pipes.stdin.write(data_in)
         raise KeyboardInterrupt
     except KeyboardInterrupt:
-        pipes.terminate()
-        ovsdb.destroy_mirror('m%s' % interface, ovsdb.port_bridge(interface))
+        if pipes.poll() is None:
+            pipes.terminate()
+
+        ovsdb.destroy_mirror(interface, ovsdb.port_bridge(interface))
         ovsdb.destroy_port(mirror_interface, ovsdb.port_bridge(interface))
     except Exception:
         print("Unable to tear down the ports and mirrors.")
diff --git a/vswitchd/bridge.c b/vswitchd/bridge.c
index 6640da785..4b4fd8452 100644
--- a/vswitchd/bridge.c
+++ b/vswitchd/bridge.c
@@ -1449,6 +1449,10 @@ port_configure_rstp(const struct ofproto *ofproto, struct port *port,
         port_s->port_num = 0;
     }
 
+    /* Increment the port num counter, because we only support
+     * RSTP_MAX_PORTS rstp ports. */
+    (*port_num_counter)++;
+
     config_str = smap_get(&port->cfg->other_config, "rstp-path-cost");
     if (config_str) {
         port_s->path_cost = strtoul(config_str, NULL, 10);
@@ -1518,7 +1522,7 @@ bridge_configure_stp(struct bridge *br, bool enable_stp)
                                           STP_DEFAULT_HELLO_TIME);
 
         br_s.max_age = smap_get_ullong(&br->cfg->other_config, "stp-max-age",
-                                       STP_DEFAULT_HELLO_TIME / 1000) * 1000;
+                                       STP_DEFAULT_MAX_AGE / 1000) * 1000;
         br_s.fwd_delay = smap_get_ullong(&br->cfg->other_config,
                                          "stp-forward-delay",
                                          STP_DEFAULT_FWD_DELAY / 1000) * 1000;
@@ -2327,14 +2331,14 @@ iface_refresh_stats(struct iface *iface)
     IFACE_STAT(rx_128_to_255_packets,   "rx_128_to_255_packets")    \
     IFACE_STAT(rx_256_to_511_packets,   "rx_256_to_511_packets")    \
     IFACE_STAT(rx_512_to_1023_packets,  "rx_512_to_1023_packets")   \
-    IFACE_STAT(rx_1024_to_1522_packets, "rx_1024_to_1518_packets")  \
+    IFACE_STAT(rx_1024_to_1522_packets, "rx_1024_to_1522_packets")  \
     IFACE_STAT(rx_1523_to_max_packets,  "rx_1523_to_max_packets")   \
     IFACE_STAT(tx_1_to_64_packets,      "tx_1_to_64_packets")       \
     IFACE_STAT(tx_65_to_127_packets,    "tx_65_to_127_packets")     \
     IFACE_STAT(tx_128_to_255_packets,   "tx_128_to_255_packets")    \
     IFACE_STAT(tx_256_to_511_packets,   "tx_256_to_511_packets")    \
     IFACE_STAT(tx_512_to_1023_packets,  "tx_512_to_1023_packets")   \
-    IFACE_STAT(tx_1024_to_1522_packets, "tx_1024_to_1518_packets")  \
+    IFACE_STAT(tx_1024_to_1522_packets, "tx_1024_to_1522_packets")  \
     IFACE_STAT(tx_1523_to_max_packets,  "tx_1523_to_max_packets")   \
     IFACE_STAT(tx_multicast_packets,    "tx_multicast_packets")     \
     IFACE_STAT(rx_broadcast_packets,    "rx_broadcast_packets")     \
@@ -3854,7 +3858,7 @@ bridge_configure_aa(struct bridge *br)
         union ovsdb_atom atom;
 
         atom.integer = m->isid;
-        if (ovsdb_datum_find_key(mc, &atom, OVSDB_TYPE_UUID) == UINT_MAX) {
+        if (ovsdb_datum_find_key(mc, &atom, OVSDB_TYPE_INTEGER) == UINT_MAX) {
             VLOG_INFO("Deleting isid=%"PRIu32", vlan=%"PRIu16,
                       m->isid, m->vlan);
             bridge_aa_mapping_destroy(m);
@@ -3957,6 +3961,8 @@ bridge_aa_update_trunks(struct port *port, struct bridge_aa_vlan *m)
         /* Force reconfigure of the port. */
         port_configure(port);
     }
+
+    free(trunks);
 }
 
 static void
@@ -4279,6 +4285,9 @@ iface_destroy__(struct iface *iface)
         struct port *port = iface->port;
         struct bridge *br = port->bridge;
 
+        VLOG_INFO("bridge %s: deleted interface %s on port %d",
+                  br->name, iface->name, iface->ofp_port);
+
         if (br->ofproto && iface->ofp_port != OFPP_NONE) {
             ofproto_port_unregister(br->ofproto, iface->ofp_port);
         }
diff --git a/vswitchd/vswitch.xml b/vswitchd/vswitch.xml
index 976f3ca3f..1c5103328 100644
--- a/vswitchd/vswitch.xml
+++ b/vswitchd/vswitch.xml
@@ -73,7 +73,8 @@
       </column>
 
       <column name="external_ids" key="hostname">
-        The hostname for the host running Open vSwitch.
+        The hostname for the host running Open vSwitch. This is a fully
+        qualified domain name since version 2.6.2.
       </column>
 
       <column name="other_config" key="stats-update-interval"
@@ -254,8 +255,9 @@
         </p>
         <p>
           The specifier is a comma-separated string, in ascending order of CPU
-          socket (ex: 1024,2048,4096,8192 would set socket 0 to preallocate
-          1024MB, socket 1 to preallocate 2048MB, etc.)
+          socket. E.g. On a four socket system 1024,0,2048 would set socket 0
+          to preallocate 1024MB, socket 1 to preallocate 0MB, socket 2 to
+          preallocate 2048MB and socket 3 (no value given) to preallocate 0MB.
         </p>
         <p>
           If not specified, the default value is 1024,0. Changing this value
@@ -1405,9 +1407,8 @@
       <dl>
         <dt><code>balance-tcp</code></dt>
         <dd>
-          Balances flows among slaves based on L2, L3, and L4 protocol
-          information such as destination MAC address, IP address, and TCP
-          port.
+          Balances flows among slaves based on L3 and L4 protocol information
+          such as IP addresses and TCP/UDP ports.
         </dd>
       </dl>
 
diff --git a/xenserver/openvswitch-xen.spec.in b/xenserver/openvswitch-xen.spec.in
index 313dc4ccd..f01652a7d 100644
--- a/xenserver/openvswitch-xen.spec.in
+++ b/xenserver/openvswitch-xen.spec.in
@@ -475,6 +475,7 @@ exit 0
 /usr/bin/ovsdb-client
 /usr/bin/ovsdb-tool
 /usr/bin/vtep-ctl
+/usr/bin/ovs-tcpdump
 /usr/lib/xsconsole/plugins-base/XSFeatureVSwitch.py
 /usr/share/man/man1/ovsdb-client.1.gz
 /usr/share/man/man1/ovsdb-server.1.gz
@@ -495,6 +496,7 @@ exit 0
 /usr/share/man/man8/ovs-vsctl.8.gz
 /usr/share/man/man8/ovs-vswitchd.8.gz
 /usr/share/man/man8/vtep-ctl.8.gz
+/usr/share/man/man8/ovs-tcpdump.8.gz
 /var/lib/openvswitch
 /var/log/openvswitch
 %exclude /usr/lib/xsconsole/plugins-base/*.py[co]
